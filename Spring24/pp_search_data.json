[{"url":"cheatsheets/","title":"Cheatsheets","tags":["welcome"],"text":"Cheatsheets Getting Started with Julia - live . Fastrack to Julia  cheatsheet. MATLAB-Julia-Python comparative cheatsheet  by  QuantEcon group Plots.jl cheatsheet"},{"url":".","title":"Welcome","tags":["homepage"],"text":"Topics in Distributional Macroeconomics This website hosts some of the material for the PhD-level course  Topics in Distributional Macroeconomics  at the Tinbergen Institute Amsterdam. The corresponding Github repository is  here . The first edition of the course was in Spring 2022. Nevertheless, much of the material is unfinished. Acknowledgement \nThe design of this website is based on  Computational Thinking , a live online Julia/Pluto textbook. (computationalthinking.mit.edu) Build your own course website using https://github.com/greimel/pluto-course-template"},{"url":"installation/","title":"Software installation","tags":["welcome"],"text":"First-time setup: Install Julia & Pluto Video version: Text and pictures version: Step 1: Install Julia  1.8.2 Go to  https://julialang.org/downloads  and download the current stable release, Julia  1.8.2 , using the correct version for your operating system (Linux x86, Mac, Windows, etc). Step 2: Run Julia After installing,  make sure that you can run Julia . On some systems, this means searching for the â€œJulia  1.8.2 â€ program installed on your computer; in others, it means running the command  julia  in a terminal. Make sure that you can execute  1 + 1 : Make sure that you are able to launch Julia and calculate  1+1  before proceeding! Step 3: Install  Pluto Next we will install the  Pluto , the notebook environment that we will be using during the course. Pluto is a Julia  programming environment  designed for interactivity and quick experiments. Open the  Julia REPL . This is the command-line interface to Julia, similar to the previous screenshot. Here you type  Julia commands , and when you press ENTER, it runs, and you see the result. To install Pluto, we want to run a  package manager command . To switch from  Julia  mode to  Pkg  mode, type  ]  (closing square bracket) at the  julia>  prompt: \njulia> ]\n\n(@v 1.8 ) pkg>\n The line turns blue and the prompt changes to  pkg> , telling you that you are now in  package manager mode . This mode allows you to do operations on  packages  (also called libraries). To install Pluto, run the following (case sensitive) command to  add  (install) the package to your system by downloading it from the internet.\nYou should only need to do this  once  for each installation of Julia: \n(@v 1.8 ) pkg> add Pluto\n This might take a couple of minutes, so you can go get yourself a cup of tea! You can now close the terminal. Step 4: Use a modern browser: Mozilla Firefox or Google Chrome We need a modern browser to view Pluto notebooks with. Firefox and Chrome work best. Second time:  Running Pluto & opening a notebook Repeat the following steps whenever you want to work on a project or homework assignment. Step 1: Start Pluto Start the Julia REPL, like you did during the setup. In the REPL, type: julia> using Pluto\n\njulia> Pluto.run()\n The terminal tells us to go to  http://localhost:1234/  (or a similar URL). Letâ€™s open Firefox or Chrome and type that into the address bar. If youâ€™re curious about what a  Pluto notebook  looks like, have a look at the  Featured Notebooks . These notebooks are useful for learning some basics of Julia programming. If you want to hear the story behind Pluto, have a look a the  JuliaCon presentation . If nothing happens in the browser the first time, close Julia and try again. And please let us know! Step 2a: Opening a notebook from the web This is the main menu - here you can create new notebooks, or open existing ones. Our homework assignments will always be based on a  template notebook , available in this GitHub repository. To start from a template notebook on the web, you can  paste the URL into the blue box  and press ENTER. For example, homework 0 is available  here . Go to this page, and on the top right, click on the button that says â€œEdit or run this notebookâ€. From these instructions, copy the notebook link, and paste it into the box. Press ENTER, and select OK in the confirmation box. The first thing we will want to do is to save the notebook somewhere on our own computer; see below. Step 2b: Opening an existing notebook file When you launch Pluto for the second time, your recent notebooks will appear in the main menu. You can click on them to continue where you left off. If you want to run a local notebook file that you have not opened before, then you need to enter its  full path  into the blue box in the main menu. More on finding full paths in step 3. Step 3: Saving a notebook We first need a folder to save our homework in. Open your file explorer and create one. Next, we need to know the  absolute path  of that folder. Hereâ€™s how you do that in  Windows ,  MacOS  and  Ubuntu . For example, you might have: C:\\Users\\fons\\Documents\\18S191_assignments\\  on Windows /Users/fons/Documents/18S191_assignments/  on MacOS /home/fons/Documents/18S191_assignments/  on Ubuntu Now that we know the absolute path, go back to your Pluto notebook, and at the top of the page, click on  â€œSave notebookâ€¦â€ . This is where you type the  new path+filename for your notebook : Click  Choose . Step 4: Sharing a notebook After working on your notebook (your code is autosaved when you run it), you will find your notebook file in the folder we created in step 3. This the file that you can share with others, or submit as your homework assignment to Canvas. \nconst run = f => f();\nrun(async () => {\nconst versions = await (await fetch(`https://julialang-s3.julialang.org/bin/versions.json`)).json()\nconst version_names = Object.keys(versions).sort().reverse()\nconst stable = version_names.find(v => versions[v].stable)\nconsole.log({stable})\nconst pkg_stable = /\\d+\\.\\d+/.exec(stable)[0]\ndocument.querySelectorAll(\"auto-julia-version\").forEach(el => {\n    console.log(el)\n    el.innerText = el.getAttribute(\"short\") == null ? stable : pkg_stable\n})\n});"},{"url":"search/","title":"Search results","tags":[],"text":"window.init_search(); Search Results \nLoading..."},{"url":"sidebar data/","title":"sidebar data","tags":[],"text":"Dict main \"welcome\" collections \"welcome\" .pages, \"Julia basics\" collections \"julia basics\" .pages, \"Preliminaries\" collections \"preliminaries\" .pages, \"Housing\" collections \"housing\" .pages, \"Long run\" collections \"long run\" .pages, \"Continuous time\" collections \"continuous time\" .pages, , about Dict authors name \"Fabian Greimel\", url \"https www.greimel.eu\" , name \"Enrico Perotti\", url \"https www.enricoperotti.eu\" , title \"Topics in Distributional Macroeconomics\", subtitle \"PhD level Elective Course\", term \"Spring 2024\", institution \"Tinbergen Institute\", institution url \"http www.tinbergen.nl\", institution logo \"tinbergen institute logo.svg\", institution logo darkmode \"tinbergen logo white.svg\" "},{"url":"syllabus/","title":"Syllabus","tags":["welcome"],"text":"Syllabus Course Links official Canvas course page Class schedule Lecture Title Date Lecturer Notebooks Reading 1A Network Basics 1 Feb  7, 2022 Cees basic Julia ,  first networks Jackson Ch. 1 & 2 1B Network Basics 2 Feb 10, 2022 Cees coauthor network ,  power law ,  exercises Jackson Ch. 3 1C Random Networks Feb 11, 2022 Cees notebook Jackson Ch. 4â€“6 & 11 2A Tutorial 1: Twitter Feb 14, 2022 Cees notebook 2B Learning on Networks Feb 17, 2022 Cees notebook Jackson Ch. 8 2C Disease Transmission Feb 18, 2022 Cees notebook 3A no lecture Feb 21, 2022 3B Financial networks 1 Feb 24, 2022 Fabian notebook Allen & Gale (2000) 3C Financial networks 2 Feb 25, 2022 Fabian notebook Acemoglu et al. (2015) 4A Tutorial 2: SIR Feb 28, 2022 Cees notebook 4B Social Connectedness Mar  3, 2022 Fabian notebook Bailey et al. (2018) 4C Network Games Mar  4, 2022 Fabian Jackson Ch. 9 5A Tutorial 3: Financial stability Mar  7, 2022 Fabian notebook 5B Production networks 1 Mar 10, 2022 Fabian notebook Carvalho (2014) ,  Long & Plosser (1982) 5C Production networks 2 Mar 11, 2022 Fabian notebook Carvalho (2014) ,  Acemoglu et al. (2012) 6A Econometrics Mar 14, 2022 Cees 6B Tutorial 4: SCI Mar 17, 2022 Fabian 6C Tutorial 5: Covid Crisis Mar 18, 2022 Fabian"},{"url":"continuous-time/continuous-time-comparison/","title":"Comparing different solution methods","tags":["continuous-time"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 6 section 3 order 3 title \"Comparing different solution methods\" layout \"layout.jlhtml\" tags \"continuous time\" description \"\" using Markdown using InteractiveUtils using EconPDEs using PlutoTest using DataFrameMacros using InfinitesimalGenerators using QuantEcon gth solve using Arpack using StructArrays using PlutoUI using AlgebraOfGraphics, CairoMakie using LinearAlgebra using SparseArrays using DataFrames using Chain chain using Roots find zero, Brent using MarkdownLiteral markdown using HypertextLiteral md\"\"\" `continuous time comparison.jl` | Version 1.0 | last updated May 31, 2023 | \"\"\" markdown \"\"\" Huggett model in continuous time In this notebook, we consider a Huggett economy in continuous time. Income is a htl \" s Poisson process s \" continuous time Markov Chain with two states. We compare the implementation of Achdou et al 2021 algorithm described in their online appendix https benjaminmoll.com wp content uploads 2020 02 HACT Numerical Appendix.pdf , code follows the Matlab code snippets on Ben Moll's website https benjaminmoll.com codes EconPDEs.jl by Mattieu Gomez code adapted from package tests \"\"\" md\"\"\" Model \"\"\" kwdef struct Moll Ïƒ Float64 2. risk aversion coefficient u' c c^ Ïƒ Ï Float64 0.05 rate of time preference z Matrix Float64 0.1 0.2 income state row vector Î» Matrix Float64 0.02 0.03 intensities row vector asset grid parameters N a Int64 500 aâ‚˜áµ¢â‚™ Float64 0.1 aâ‚˜â‚â‚“ Float64 1.0 Î”a Float64 aâ‚˜â‚â‚“ aâ‚˜áµ¢â‚™ N a 1 end function generator Î» Î»â‚â‚‚, Î»â‚‚â‚ Î» Î› Î»â‚â‚‚ Î»â‚â‚‚ Î»â‚‚â‚ Î»â‚‚â‚ end function construct A switch Î», N a id I N a Î»â‚â‚‚, Î»â‚‚â‚ Î» A switch 1 hcat Î»â‚â‚‚ id, Î»â‚â‚‚ id A switch 2 hcat Î»â‚‚â‚ id, Î»â‚‚â‚ id Î»â‚â‚‚ id Î»â‚â‚‚ id Î»â‚‚â‚ id Î»â‚‚â‚ id A switch vcat A switch 1, A switch 2 end md\"\"\" We work with an equi spaced asset grid with N a grid points. The difference between two grid points is denoted by \\Delta a . Section 7 in the online appendix explains how to deal with non uniform grids. \"\"\" function construct a m N a, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“ m range aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, N a asset grid column vector end m Moll md\"\"\" HJB equation implicit method \"\"\" md\"\"\" \\rho v 1 a \\max c u c v 1' a z 1 ra c \\lambda 1 v 2 a v 1 a \\rho v 2 a \\max c u c v 2' a z 2 ra c \\lambda 2 v 1 a v 2 a ```math \\rho \\pmatrix v 1 a \\\\ v 2 a \\pmatrix u c^ 1 a \\\\ u c^ 2 a \\pmatrix v' 1 a z 1 ra c 1^ a \\\\ v' 1 a z 1 ra c 2^ a \\pmatrix \\lambda 1 & \\lambda 1 \\\\ \\lambda 2 & \\lambda 2 \\pmatrix v 1 a \\\\ v 2 a ``` \"\"\" md\"\"\" Algorithm Notation v i,j is short hand notation for v j a i . Start with an initial guess for the value function v i,j ^0 . A natural choice is v i,j ^0 \\frac u z j ra i \\rho . For i 1, ... maxit 1 Approximate v i,j ^n ' , j 1,2 using a finite difference method Notation Superscript n is omitted. forward difference v i,j,F ' \\frac v i 1,j v i,j \\Delta a backward diffrence v i,j,B ' \\frac v i,j v i 1,j \\Delta a The state constraint a \\ge a \\text min needs to be enforced by setting v' 1,j,B u' z j ra \\text min . savings according to forward difference s i,j,F z j ra i u' ^ 1 v' i,j,F savings according to backward difference s i,j,B z j ra i u' ^ 1 v' i,j,B The finite difference approximation of v i,j ^n ' is v' i,j v' i,j,F 1 s i,j,F 0 v' i,j,B 1 s i,j,B 0 \\bar v i,j 1 s i,j,F \\le 0 \\le s i,j,B where \\bar v i,j u' s j r a i . We assume concavity of the value function here so that the case s i,j,F 0 and s i,j,B 0 cannot occur. 2 Compute the consumption policy implied by the value function c i,j ^n u' ^ 1 v i,j ^n ' 3 Find updated value function v^ n 1 ```math \\begin align &\\frac v i,j ^ n 1 v i,j ^ n \\Delta \\rho v i,j ^ n 1 \\\\ &u c i,j ^n v i,j,F ^ n 1 ' z j ra i c i,j,F ^n ^ v i,j,B ^ n 1 ' z j ra i c i,j,B ^n ^ \\lambda j v i, j ^ n 1 v i,j ^ n 1 \\end align ``` where \\Delta is the step size. This is a system of 2N a linear equations. Since v^ n 1 is implicitly defined by the equations above, this approach is referred to as the implicit method. The system of equations can be written in matrix notation as \\frac 1 \\Delta v^ n 1 v^n \\rho v^ n 1 u^n A^n v^ n 1 The 2N a \\times 2N a matrix A^n can be written as a sum of two matrices \\bar A ^n and A \\text switch A^n \\bar A ^n A \\text switch \\begin pmatrix \\bar A 11 ^n & 0 \\\\ 0 & \\bar A 22 ^n \\end pmatrix \\begin pmatrix \\lambda 1 I & \\lambda 1 I \\\\ \\lambda 2 I & \\lambda 2 I \\end pmatrix where I is a N a \\times N a identity matrix. Since A \\text switch stays unchanged, it can be pre computed outside the for loop. The N a \\times N a submatrices \\bar A 11 ^n and \\bar A 22 ^n are tri diagonal The 1 diagonal is filled with x i,j \\frac s^n i,j,B ^ \\Delta a , i 2, \\dots N a The main diagonal is filled with y i,j \\frac s^n i,j,F ^ \\Delta a \\frac s^n i,j,B ^ \\Delta a , i 1, \\dots N a The 1 diagonal is filled with z i,j \\frac s^n i,j,F ^ \\Delta a , i 1, \\dots N a 1 Since A^n is a sparse matrix, computers can solve the system of linear equations quickly even for large N a . 4 Stop if v^ n 1 is close enough to v^n . \"\"\" md\"\"\" Solving HJB with `EconPDEs.jl` \"\"\" md\"\"\" Test from EconPDEs \"\"\" states a, z a, z function dvs v v1, v1a up, v1a down, v2, v2a up, v2a down dvf v1a up, v2a up dvb v1a down, v2a down v v1, v2 dvf, dvb, v end u prime inv x, Ïƒ x^ 1 Ïƒ u prime c, Ïƒ c^ Ïƒ u c, Ïƒ c 0 ? Ïƒ 1 ? log c c^ 1 Ïƒ 1 Ïƒ 10.0 c 100.0 â• â•â•¡ function clean variables nt, solname, statename, n map 1 n do i sol key Symbol solname, i up key Symbol sol key, statename, \" up\" Symbol solname, statename, \" up\" down key Symbol sol key, statename, \" down\" Symbol solname, statename, \" down\" solname nt sol key , up key 2 nt up key 1 , down key 2 nt down key 1 end | DataFrame end â• â•â•¡ function consumption and drift a, z , dv, r, Ïƒ dv max dv, eps 0.0 c u prime inv dv, Ïƒ aÌ‡ z r a c c, aÌ‡, dv end function consumption and driftâ‚€ a, z , r, Ïƒ aÌ‡ zero a c z r a dv u prime c, Ïƒ c, aÌ‡, dv end function consumption and drift upwind state, dvf, dvb, Ïƒ, r, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“ consumption and savings with forward difference dv, aÌ‡, c consumption and drift state, dvf, Ïƒ, r if aÌ‡ 0 && state.a aâ‚˜â‚â‚“ return dv, aÌ‡f aÌ‡, aÌ‡b 0.0, c, aÌ‡ end consumption and savings with backward difference dv, aÌ‡, c consumption and drift state, dvb, Ïƒ, r if aÌ‡ 0 && state.a aâ‚˜áµ¢â‚™ return dv, aÌ‡f 0.0, aÌ‡b aÌ‡, c, aÌ‡ end consumption and derivate of value function at steady state dv, aÌ‡, c consumption and driftâ‚€ state, Ïƒ, r return dv, aÌ‡f 0.0, aÌ‡b 0.0, c, aÌ‡ end function optional to df optional, agrid, zgrid chain optional begin DataFrame transform a bycol collect agrid stack Not a transform i z parse Int, variable end transform variable variable 1 end 1 unstack variable, value transform z zgrid i z select Not i z rename s È§ end end â• â•â•¡ test let r 0.03 M EconPDEsFast m, r elapsed residual norm, optional, agrid, zgrid solve HJB econpdes M, r end â• â•â•¡ md\"\"\" Check results \"\"\" md\"\"\" KF equation \"\"\" md\"\"\" 0 \\frac d da s 1 a g 1 a \\lambda 1 g 1 a \\lambda 2 g 2 a 0 \\frac d da s 2 a g 2 a \\lambda 2 g 2 a \\lambda 1 g 1 a where s j a z j ra c j a 1 \\int \\bar a ^\\infty g 1 a da \\int \\bar a ^\\infty g 2 a da Algorithm A finite difference approximation of the KF equation results into the matrix equation A^T g 0 where A is the matrix from implicit algorithm for the HJB equation. \"\"\" using QuantEcon gth solve md\"\"\" ```math \\begin align \\dot g 1 m A g t m g t \\\\ g t \\Delta g t \\approx A g t \\Delta \\\\ g t \\Delta 1 m I \\Delta A g t m g 0 \\\\ g^ 1 m I \\Delta A g^ m g 0 \\\\ I 1 m I \\Delta A g^ m g 0 \\\\ I \\frac 1 m m \\Delta A g^ g 0 \\\\ \\end align ``` \"\"\" function solve KF moll A N size A, 1 AT copy transpose A b zeros N i fix 1 b i fix .1 AT i fix, . 0.0 AT i fix,i fix 1.0 g AT\\b g . sum g end function solve KF N a, Î”a , A N a an AT copy transpose A b zeros 2 N a, 1 i fix 1 b i fix .1 AT i fix, . vec hcat zeros 1, i fix 1 , 1., zeros 1,2 N a i fix try global g stacked AT\\b catch e if e isa SingularException warn \"SingularException â€“ added noise\" global g stacked AT I âˆšeps \\b else rethrow e end end g sum sum g stacked Î”a g stacked norm g stacked . g sum assert sum g stacked norm Î”a â‰ˆ 1 g reshape g stacked norm, N a, 2 end md\"\"\" Putting everything together \"\"\" using QuantEcon gth solve function stationary distribution A Î´ 0.0, Ïˆ InfinitesimalGenerators.Zeros size A, 1 Î´ 0 || throw ArgumentError \"Î´ needs to be positive\" if Î´ 0 g abs. Î´ I A' \\ Î´ Ïˆ else Î·, g InfinitesimalGenerators.principal eigenvalue A' abs Î· 1e 5 || warn \"Principal Eigenvalue does not seem to be zero\" end g . sum g end function solve KF death A N size A, 1 gâ‚€ fill 1 N, N stationary distribution A, Î´ 1e 14, Ïˆ gâ‚€ end function solve KF eigs A stationary distribution A end function solve KF iterate A, Î”, gâ‚€ fill 1 size A,1 , size A,1 g copy gâ‚€ B I Î” A' for i âˆˆ 1 50000 g new B g crit maximum abs, g new g i % 1000 0 && info crit if crit 1e 12 info \"converged after i iterations\" return g end g . g new end g end md\"\"\" Equilibrium interest rate \"\"\" md\"\"\" 0 \\int \\bar a ^\\infty ag 1 a da \\int \\bar a ^\\infty ag 2 a da S r \"\"\" initial bracket 0.01, 0.03 md\"\"\" Appendix \"\"\" md\"\"\" HJB equation explicit method \"\"\" md\"\"\" Basic dea Start with some initial guess v i,j ^0 and update v i,j ^n as follows \\frac v i,j ^ n 1 v i,j ^n \\Delta \\rho v i,j ^n u c i,j ^n v i,j ^n ' z j ra i c i,j ^n \\lambda i v i, j ^n v i,j ^n In contrast to the implicit method, we can rearrange for v i,j ^ n 1 in the equation above. The disadvantage of the explicit method is that it converges only if \\Delta is not too large. \"\"\" function solve HJB explicit m Moll, r maxit 100000, crit 1e 6 Ïƒ, Ï, z, Î», N a, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, Î”a m da Î”a construct asset grid a construct a m Î› generator m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 initial guess for value function vâ‚€ zeros N a, 2 for i, záµ¢ in enumerate z vâ‚€ ,i záµ¢ . r a .^ 1 Ïƒ 1 Ïƒ Ï end v vâ‚€ initialize vector that keeps track of convergence dist ones maxit step size for updating the value function Î” .9 da z 2 . r. aâ‚˜â‚â‚“ for it in range 1, maxit forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aâ‚˜â‚â‚“ .^ Ïƒ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aâ‚˜áµ¢â‚™ .^ Ïƒ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 Ïƒ aÌ‡f z . r . a cf consumption and savings with backward difference cb dvb .^ 1 Ïƒ aÌ‡b z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ Ïƒ If aÌ‡f . 0 positive drift forward difference Ib aÌ‡b . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 c dv upwind .^ 1 Ïƒ aÌ‡ z . r. a c u c.^ 1 Ïƒ 1 Ïƒ HJB equation v change u dv upwind . aÌ‡ v Î›' Ï v v switch zeros N a, 2 v switch ,2 v ,1 v switch ,1 v ,2 v change u dv upwind . aÌ‡ ones N a,1 Î». v switch v Ï v updating the value function v . v Î” v change dist it maximum abs. v change if dist it crit return v, c, aÌ‡, it last it, dist end end error \"Algorithm did not converge\" end t expl elapsed solve HJB explicit m, 0.03 crit 1e 6 md\"\"\" Implicit vs. explicit method \"\"\" md\"\"\" On my computer, it takes 0.4 seconds to reach convergence with the implicit method assuming a tolerance of 10^ 6 , while it takes approximately 6 seconds with the explicit method. \"\"\" md\"\"\" Implicit method \"\"\" md\"\"\" Explicit method \"\"\" md\"\"\" Helper functions \"\"\" function results to df m v, c, aÌ‡, g nothing N z 2 N a, z m a construct a m df DataFrame df.a a ones 1, N z | vec df.z ones N a, 1 z | vec df.c c | vec df.aÌ‡ aÌ‡ | vec df.v v | vec if isnothing g df.g g | vec end df end md\"\"\" Julification of the code \"\"\" function statespace m N a, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, z m a grid range aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, N a z grid z | vec a, z for a âˆˆ a grid, z âˆˆ z grid end function statespace inds m N a, z m N z length z i a, i z for i a âˆˆ 1 N a, i z âˆˆ 1 N z end vâ‚€ z, a , r, Ïƒ, Ï u z r a, Ïƒ Ï begin Base. kwdef struct EconPDEsFast income process parameters zgrid Vector Float64 0.5, 1.5 Î› Matrix Float64 0.2 0.2 0.2 0.2 utility parameters Ïƒ Float64 2.0 Ï Float64 0.04 r Float64 0.03 w Float64 1.0 aâ‚˜áµ¢â‚™ Float64 0.1 aâ‚˜â‚â‚“ Float64 1.0 an Int 500 end function EconPDEsFast m Moll, r Ïƒ m.Ïƒ, Ï m.Ï, aâ‚˜áµ¢â‚™ m.aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“ m.aâ‚˜â‚â‚“, an m.N a Î› generator m EconPDEsFast Ïƒ, Ï, r, w 1, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, an, zgrid vec m.z , Î› end function m EconPDEsFast state NamedTuple, value NamedTuple zgrid, Î›, Ï m zs zgrid nz length zgrid a state v1, v1a up, v1a down, v2, v2a up, v2a down value T eltype value vs v1, v2 dvf v1a up, v2a up dvb v1a down, v2a down states a, z zgrid 1 , a, z zgrid 2 cs Vector T undef, nz aÌ‡s Vector T undef, nz dvs Vector T undef, nz for i âˆˆ 1 2 c, aÌ‡, dv consumption and drift upwind states i , dvf i , dvb i , m cs i c aÌ‡s i aÌ‡ dvs i dv end vts Ï . vs . u. cs, Ref m . È§s . dvs . Î› vs return v1t vts 1 , v2t vts 2 , s1 aÌ‡s 1 , s2 aÌ‡s 2 , c1 cs 1 , c2 cs 2 end pkgtest0 let m EconPDEsFast agrid m.amin . range 0, m.amax m.amin ^0.8, length m.an .^ 1 0.8 agrid range m.aâ‚˜áµ¢â‚™, m.aâ‚˜â‚â‚“, length m.an stategrid OrderedDict a agrid yend OrderedDict Symbol v, i vâ‚€ z, a , m for a âˆˆ agrid for i, z âˆˆ enumerate m.zgrid m, stategrid, yend end end let m, stategrid, yend pkgtest0 pdesolve m, stategrid, yend t elapsed result pdesolve m, stategrid, yend info t assert result.residual norm 1e 5 end function solve HJB econpdes M, r crit âˆšeps , vâ‚€ vâ‚€ agrid M.aâ‚˜áµ¢â‚™ . range 0, M.aâ‚˜â‚â‚“ M.aâ‚˜áµ¢â‚™ ^0.8, length M.an .^ 1 0.8 agrid range M.aâ‚˜áµ¢â‚™, M.aâ‚˜â‚â‚“, M.an stategrid OrderedDict a agrid solend OrderedDict Symbol v, i vâ‚€ z, a , M for a âˆˆ agrid for i, z âˆˆ enumerate M.zgrid residual norm, optional pdesolve M, stategrid, solend maxdist crit residual norm, optional, agrid, M.zgrid end function solve HJB econpdes m, r crit âˆšeps , vâ‚€ vâ‚€ M EconPDEsFast m, r residual norm, optional, agrid, zgrid solve HJB econpdes M, r crit, vâ‚€ df optional to df optional, agrid, zgrid df.v, df.c, df.È§, df, dist residual norm end abstract type Scheme end Base. kwdef struct Implicit Scheme Î” 1000 maxit 100 end begin Base. kwdef struct Explicit Scheme Î” maxit end function Explicit Î”a, z, aâ‚˜â‚â‚“ maxit 100 000 r 0.02 Î” .9 Î”a maximum z r aâ‚˜â‚â‚“ Explicit Î”, maxit end end function consumption and drift upwind vec ss, dvf, dvb, par consumption and drift upwind. ss, dvf, dvb, Ref par | StructArray end begin Base. kwdef struct EconPDEsSlow Ïƒ Float64 2.0 Ï Float64 0.05 r Float64 0.03 w Float64 1.0 aâ‚˜áµ¢â‚™ Float64 0.1 aâ‚˜â‚â‚“ Float64 1.0 an Int 500 zgrid Vector Float64 0.1, 0.2 Î› Matrix Float64 0.02 0.02 0.03 0.03 end function EconPDEsSlow m Moll, r Ïƒ m.Ïƒ, Ï m.Ï, aâ‚˜áµ¢â‚™ m.aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“ m.aâ‚˜â‚â‚“, an m.N a Î› generator m EconPDEsSlow Ïƒ, Ï, r, w 1, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, an, zgrid vec m.z , Î› end function M EconPDEsSlow state NamedTuple, sol NamedTuple zgrid, r, Ï, Ïƒ, Î› M dvf, dvb, v dvs v sol a state dv, c, È§ consumption and drift upwind vec states. a, zgrid , dvf, dvb, M endo u. c, Ref M . dv . È§ vt Ï v endo Î› v nz length zgrid return NamedTuple Tuple Symbol. v, 1 nz, t vt , NamedTuple Tuple Symbol. c, 1 nz Symbol. s, 1 nz c È§ end pkgtest let m EconPDEsSlow agrid m.amin . range 0, m.amax m.amin ^0.8, length m.an .^ 1 0.8 agrid range m.aâ‚˜áµ¢â‚™, m.aâ‚˜â‚â‚“, length m.an stategrid OrderedDict a agrid yend OrderedDict Symbol v, i vâ‚€ z, a , m for a âˆˆ agrid for i, z âˆˆ enumerate m.zgrid m, stategrid, yend end end let m, stategrid, yend pkgtest pdesolve m, stategrid, yend t elapsed result pdesolve m, stategrid, yend info t assert result.residual norm 1e 5 end function inner function ss, v, aâ‚˜â‚â‚“, aâ‚˜áµ¢â‚™, r, Ïƒ, N a, Î”a, z initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 forward difference dvf 1 N a 1, . v 2 N a, v 1 N a 1, Î”a dvf N a, . vec z . r aâ‚˜â‚â‚“ .^ Ïƒ boundary condition a a max backward difference dvb 2 N a, . v 2 N a, v 1 N a 1, Î”a dvb 1, . vec z . r aâ‚˜áµ¢â‚™ .^ Ïƒ boundary condition a a min I concave dvb . dvf problems if value function not concave out consumption and drift upwind vec ss, dvf, dvb, Ïƒ, r, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“ u out.c .^ 1 Ïƒ 1 Ïƒ u, out.c, out.dv, out.aÌ‡, out.aÌ‡f, out.aÌ‡b end function update v ss, v, par, , Î›, Î” Explicit Ï par u, c, aÌ‡, aÌ‡f, aÌ‡b, dv inner function ss, v, par HJB equation v change u dv . aÌ‡ v Î›' Ï v v new v Î” v change v new, v change, u, c, aÌ‡, aÌ‡f, aÌ‡b end function construct A alt aÌ‡fs, aÌ‡bs, da, N a, N z T typeof I from 1, I to 1, Î» 0.0 list T car inds CartesianIndices N a, N z | collect .| Tuple lin inds LinearIndices N a, N z for I from, aÌ‡f, aÌ‡b in enumerate zip aÌ‡fs, aÌ‡bs i a, i z car inds I from if aÌ‡f 0 && i a N a I to lin inds i a 1, i z Î» aÌ‡f da push list, I from, I to, Î» end if aÌ‡b 0 && i a 1 I to lin inds i a 1, i z Î» aÌ‡b da push list, I from, I to, Î» end end sa StructArray list NN N a 2 Aâ‚€ sparse sa.I from, sa.I to, sa.Î», NN, NN for i âˆˆ 1 NN Aâ‚€ i, i sum Aâ‚€ i, end Aâ‚€ end function construct A aÌ‡s, da, N a, N z size ss N a, N z N N a N z car inds CartesianIndices size ss | collect .| Tuple lin inds LinearIndices size ss initialize list of entries A T typeof I from 1, I to 1, Î» 0.0 list T create list of entries of A for I from, aÌ‡ in enumerate aÌ‡s i a, i z car inds I from i a next nothing Î» nothing in which direction to move? if aÌ‡ 0 && i a N a i a next i a 1 Î» aÌ‡ da elseif aÌ‡ 0 && i a 1 i a next i a 1 Î» aÌ‡ da end if isnothing i a next I to lin inds i a next, i z push list, I from, I to, Î» end end construct sparse matrix from list of entries list sa StructArray list A sparse list sa.I from, list sa.I to, list sa.Î», N, N fill diagonal A diagind A . vec sum A, dims 2 A end function construct A diag aÌ‡f, aÌ‡b, da, N a X min. aÌ‡b,0 da Z max. aÌ‡f,0 da A11 spdiagm 1 X 2 N a,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 1 Z 1 N a 1,2 A cat A11, A22, dims 1,2 A diagind A . vec sum A, dims 2 A end function construct A moll aÌ‡f, aÌ‡b, da, N a X min. aÌ‡b,0 da Y max. aÌ‡f,0 da min. aÌ‡b,0 da Z max. aÌ‡f,0 da A11 spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 0 Y ,2 , 1 Z 1 N a 1,2 A cat A11, A22, dims 1,2 A end function solve HJB implicit m Moll, r maxit 100, crit âˆšeps , Î” 1000 Ïƒ, Ï, z, Î», N a, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, Î”a m da Î”a N z length z construct asset grid a range aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, N a initialize arrays for forward and backward difference dvf zeros N a, N z dvb zeros N a, N z precompute A switch matrix id sparse I, N a, N a A switch 1 hcat Î» 1 id, Î» 1 id A switch 2 hcat Î» 2 id, Î» 2 id A switch vcat A switch 1, A switch 2 initial guess for value function vâ‚€ zeros N a, N z for i, záµ¢ in enumerate z vâ‚€ ,i záµ¢ . r a .^ 1 Ïƒ 1 Ïƒ Ï end v vâ‚€ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit STEP 1 forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aâ‚˜â‚â‚“ .^ Ïƒ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aâ‚˜áµ¢â‚™ .^ Ïƒ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 Ïƒ aÌ‡f z . r . a cf consumption and savings with backward difference cb dvb .^ 1 Ïƒ aÌ‡b z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ Ïƒ If aÌ‡f . 0 positive drift forward difference Ib aÌ‡b . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 STEP 2 c dv upwind .^ 1 Ïƒ u c.^ 1 Ïƒ 1 Ïƒ STEP 3 A construct A moll aÌ‡f, aÌ‡b, Î”a, N a A switch B Ï 1 Î” I A b vec u vec v Î” v new stacked B \\ b v new reshape v new stacked, N a, N z STEP 4 v change v new v dist it maximum abs. v change v v new if dist it crit aÌ‡ z . r. a c ss tuple. a, z return v, c, aÌ‡, a first. ss , z last. ss , A, it last it, dist end end error \"Algorithm did not converge\" end function solve df m Moll, r maxit 100, crit 1e 6, Î” 1000 v, c, aÌ‡, A, it last, dist solve HJB implicit m, r crit, Î” scheme Implicit maxit, Î” v, c, È§, A, it last, dist solve HJB julian m, r, scheme crit g solve KF m, A df results to df m v, c, aÌ‡, g return df, it last, dist end df, it last, dist solve df m, 0.03 maxit 100 let df.g max min. df.g,df.g 2 chain df begin stack Not a, z, g data mapping a, value, layout variable, color z nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end end function excess demand m Moll, r maxit 100, crit 1e 6, Î” 1000 Î”a m df, it last, dist solve df m, r maxit, crit, Î” A dot df.a, df.g Î”a end r eq find zero r excess demand m, r , initial bracket, Brent solve HJB implicit m, 0.03 function update v ss, v, par, A switch, , Î” Implicit Ï, N a, Î”a par u, c, aÌ‡, aÌ‡f, aÌ‡b, dv inner function ss, v, par A construct A alt aÌ‡f, aÌ‡b, da, N a, 2 A switch A construct A diag aÌ‡f, aÌ‡b, da, N a A switch A construct A moll aÌ‡f, aÌ‡b, Î”a, N a A switch A construct A aÌ‡, da, N a, 2 A switch B Ï 1 Î” I A b vec u vec v Î” v new stacked B \\ b v new reshape v new stacked, N a, 2 v change v new v v new, v change, u, c, aÌ‡, aÌ‡f, aÌ‡b end function solve HJB julian m Moll, r, scheme Scheme vâ‚€ vâ‚€, crit 1e 6 maxit, Î” scheme Ïƒ, Ï, z, Î», N a, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“, Î”a m par Ïƒ, Ï, z, N a, aâ‚˜â‚â‚“, m.aâ‚˜áµ¢â‚™, Î”a, r Î› generator m construct asset grid ss statespace m precompute A switch matrix A switch construct A switch m initial guess for value function v vâ‚€. ss, Ref r, Ïƒ, Ï initialize vector that keeps track of convergence dists for it in range 1, maxit updating the value function v new, v change, c, aÌ‡, aÌ‡f, aÌ‡b update v ss, v, par, A switch, Î›, scheme dist maximum abs. v change v . v new push dists, dist if dist crit A construct A moll aÌ‡f, aÌ‡b, Î”a, N a construct A switch m return A, v, c, aÌ‡, it last it, dist dists end end error \"Algorithm did not converge\" end compare let r 0.02 crit 1e 11 maxit 100 000 scheme Implicit t1 elapsed HJB moll solve HJB implicit m, r crit info t1 t2 elapsed HJB explicit solve HJB explicit m, r crit info t2 t3 elapsed HJB julian solve HJB julian m, r, scheme crit info t3 t4 elapsed HJB econpdes solve HJB econpdes m, r crit info t4 test vec HJB moll.v â‰ˆ vec HJB julian.v â‰ˆ HJB econpdes.v test vec HJB moll.aÌ‡ â‰ˆ vec HJB julian.aÌ‡ â‰ˆ HJB econpdes.aÌ‡ test vec HJB moll.c â‰ˆ vec HJB julian.c â‰ˆ HJB econpdes.c info HJB moll.it last, HJB julian.it last HJB moll, HJB explicit, HJB julian, HJB econpdes end let HJB moll, HJB julian, HJB econpdes compare i z CartesianIndices HJB moll.aÌ‡ .| Tuple .| last | vec i a CartesianIndices HJB moll.È§ .| Tuple .| first | vec a df moll DataFrame aÌ‡ vec HJB moll.aÌ‡ , c vec HJB moll.c , v vec HJB moll.v , a vec HJB moll.a , z vec HJB moll.z , df gomez HJB econpdes.df df vcat df moll, df gomez, source method \"Moll\", \"Gomez\" chain df begin stack Not a, z, method data mapping a, value, layout variable, color z nonnumeric, linestyle method nonnumeric visual Lines draw , facet linkyaxes false, as svg end end let r 0.03 crit 1e 6 scheme Implicit maxit, Î” v, c, aÌ‡, A, it last, dist solve HJB julian m, r, scheme crit N size A, 1 gâ‚€ fill 1 N, N t0 elapsed g0 solve KF iterate A, 0.05 t1 elapsed g1 solve KF moll A t2 elapsed g2 solve KF death A t3 elapsed g3 solve KF eigs A t4 elapsed g4 gth solve Matrix A info t0, t1, t2, t3, t4 maximum abs, g0 g1 , maximum abs, g1 g2 , maximum abs, g2 g3 , maximum abs, g3 g4 , maximum abs, g4 g0 norm g1 g stacked norm g1 g1 . sum g1 m.Î”a fig Figure ax Axis fig 1,1 lines ax, g1 lines ax, g stacked fig end t impl elapsed solve HJB julian m, 0.03, Implicit let df dist DataFrame iteration range 1, it last , time range 0, t impl, it last , log10 dist log10. dist 1 it last figure resolution 500, 250 chain df dist begin data mapping time, log10 dist visual Lines draw figure as svg end end function solve explicit df m Moll, r maxit 100000, crit âˆšeps scheme Explicit m maxit v, c, aÌ‡, it last, dist solve HJB julian m, r, scheme crit df results to df m v, c, aÌ‡ return df, it last, dist end df2, it last2, dist2 solve explicit df m, 0.03 crit âˆšeps let df dist DataFrame iteration range 1, it last2 , time range 0, t expl, it last2 , log10 dist log10. dist2 1 it last2 figure resolution 500, 250 chain df dist begin data mapping time, log10 dist visual Lines draw figure as svg end end md\"\"\" Differentiate \"\"\" begin Î”y up y, i, Î”x y i 1 y i Î”x Î”y down y, i, Î”x y i y i 1 Î”x Î”y central y, i, Î”x y i 1 y i 1 Î”x function Î”grid grid, i last length grid inbounds down grid max i, 2 grid max i 1, 1 inbounds up grid min i 1, last grid min i, last 1 central up down avg central 2 up, down, avg, central end function Î”y y, bc, i, Î”x, fun name, state name up i length y ? Î”y up y, i, Î”x.up bc i down i 1 ? Î”y down y, i, Î”x.down bc i second up down Î”x.avg NamedTuple deriv names fun name, state name up, down, second end deriv names fun name, state name Symbol fun name, state name, \" \", up , Symbol fun name, state name, \" \", down , Symbol fun name, state name, state name end md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"continuous-time/continuous-time-processes/","title":"Continuous time processes","tags":["continuous-time"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 6 section 1 order 1 title \"Continuous time processes\" layout \"layout.jlhtml\" tags \"continuous time\" description \"\" using Markdown using InteractiveUtils using InfinitesimalGenerators using LinearAlgebra I using Chain, DataFrameMacros using DataFrames using PlutoUI using AlgebraOfGraphics, CairoMakie md\"\"\" `continuous time processes.jl` | Version 1.1 | last updated June 9, 2022 \"\"\" md\"\"\" In this notebook we want to get some intuition for Continuous Time Markov processes Diffusion processes. \"\"\" md\"\"\" Continuous Time Markov Chains What Ben Moll calls finite state Poisson processes Background material QuantEcon lecture notes https continuous time mcs.quantecon.org intro.html Wikipedia https en.wikipedia.org wiki Continuous time Markov chain \"\"\" jumps 0 5 4 0 0 5 0 5 4 0 5 9 0 9 5 0 4 5 0 5 0 0 4 5 0 md\"\"\" The intensity matrix ``Q`` ``Q`` satisfies that ``Q i,j \\geq 0`` for ``i \\ne j`` and ``Q ii \\sum j \\ne i Q ij ``. For a small time interval ``\\Delta t`` and ``i \\ne j`` the intensity ``Q ij `` determines the probability of jumping from ``i`` to ``j`` within that interval ``\\Pr \\Delta t j | i â‰ˆ \\Delta t \\cdot Q i,j ``. \"\"\" begin Q copy jumps for i âˆˆ 1 size Q, 1 Q i,i sum Q i, end Q end let i 2 j 3 Î”t 0.01 Î”t Q i,j end md\"\"\" Naively Simulating the CTMC \"\"\" ts let T 10 Î”t 0.01 ts 0 Î”t T end function simulate Q, ts, sâ‚€ states 1 size Q, 1 Î”t diff ts s sâ‚€ out t 0.0, it 1, s for it âˆˆ 2 length ts t ts it x rand otherstates filter s , states probs Q s, otherstates . Î”t it 1 cumprobs cumsum probs for i, s next âˆˆ enumerate otherstates if x cumprobs i s s next break end end push out, t, it, s end out end df ctmc let N 10000 sâ‚€ 3 initial state dfs map 1 N do i simulate Q, ts, sâ‚€ | DataFrame end vcat dfs..., source i 1 N end let N 10 T 1 title L\"Plotting % N sample paths on t âˆˆ 0, % T \" chain df ctmc begin subset i â‰¤ N subset t â‰¤ T data mapping t, s, color i nonnumeric visual Lines draw axis title end end let N length unique df ctmc.i title \"Plotting frequencies over time\" chain df ctmc begin groupby t, s combine frequency length s N unstack s, frequency, fill 0.0 stack Not t , variable name state, value name frequency data mapping t, frequency, color state visual Lines draw axis title end end md\"\"\" Using the Kolmogorov Forward Equation Let ``\\pi t`` be the probability mass function that describes the cross sectional distribution of the CTMC at time ``t``. Then the evolution of the distribution over time is given by the Kolmogorov Forward equation. ```math \\begin align \\dot g t & Q' g t \\\\ \\implies \\frac g t \\Delta t g t \\Delta t &\\approx Q' g t \\\\ \\implies g t \\Delta t &\\approx g t \\Delta t Q' g t I \\Delta t Q' g t \\end align ``` \"\"\" let n size Q, 2 Ï€ zeros n Ï€ 1 1.0 Î”ts diff ts df DataFrame t ts 1 , Ï€, i 1 n dfs df for tm1, Î”t âˆˆ enumerate Î”ts t tm1 1 Ï€ I Î”t Q' Ï€ df DataFrame t, Ï€, i 1 n push dfs, df end data vcat dfs... mapping t, Ï€, color i nonnumeric visual Lines | draw end md\"\"\" Diffusion processes Diffusion processes are continuous time Markov processes with continuous sample paths no jumps . ```math d X t \\underbrace \\mu X t \\text drift dt \\underbrace \\sigma X t \\text volatility d W t, \\qquad X 0 \\text given ``` where ``W t`` is a Wiener process or Brownian motion . Example Ornstein Uhlenbeck process https en.wikipedia.org wiki Ornstein%E2%80%93Uhlenbeck process ```math d X t \\theta \\mu X t dt \\sigma d W t, \\qquad X 0 \\text given ``` \"\"\" Base. kwdef struct OUProcess Î¼ 0.1 Ïƒ 0.1 Î¸ 0.9 end drift x, Î¼, Ïƒ, Î¸ OUProcess Î¸ Î¼ x volatility x, Î¼, Ïƒ, Î¸ OUProcess Ïƒ dW Î” Î” randn oup OUProcess md\"\"\" Naive simulations \"\"\" md\"\"\" Using the Kolmogorov Forward Equation Diffusion processes can be represented by their infinitesimal generator https en.wikipedia.org wiki Infinitesimal generator stochastic processes . The discretized version of such a infinitesimal generator looks just like a transition matrix of a CTMC. It turns out that we can use it to simulate and solve the Kolmogorov forward equation. \"\"\" xs, dp let xs range 0.5, 0.5, 50 dp DiffusionProcess xs, drift. xs, Ref oup , volatility. xs, Ref oup xs, dp end df dp let TT typeof it 1, t 1.0, i 1, X 1.0 out TT for i, xâ‚€ âˆˆ enumerate xs use each gridpoint as initial value once X xâ‚€ push out, it 1, t ts 1 , i, X for itm1, Î”t âˆˆ enumerate diff ts it itm1 1 X X drift X, oup Î”t volatility X, oup dW Î”t push out, it, t ts itm1 , i, X end end DataFrame out end chain df dp begin subset i % 10 0 data mapping t, X, color i, group i nonnumeric visual Lines draw end chain df dp begin subset it 1 || it % 100 0 data mapping X, group t nonnumeric, color t nonnumeric AlgebraOfGraphics.density draw end generator dp let n length xs Ï€ fill 1 n, length xs initial distribution Q generator dp Ï€s Ï€ Î”t 0.01 fig Figure ax Axis fig 1,1 for i âˆˆ 1 1000 if iâˆˆ 1,5,10 || i % 20 0 lines ax, xs, Ï€ end Ï€ I Î”t Q' Ï€ push Ï€s, Ï€ end fig end lines xs, stationary distribution dp md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"continuous-time/indebted-demand-huggett/","title":"Huggett meets Mian-Sufi-Straub","tags":["continuous-time"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 6 section 2 order 2 title \"Huggett meets Mian Sufi Straub\" layout \"layout.jlhtml\" tags \"continuous time\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using Roots find zero, Brent using PlutoUI using Chain chain using DataFrames, DataFrameMacros using CairoMakie using AlgebraOfGraphics using EconPDEs using LinearAlgebra using LinearAlgebra I using StructArrays using SparseArrays md\"\"\" `indebted demand huggett.jl` | Version 2.0 | last updated June 16, 2023 \"\"\" md\"\"\" Huggett model with two income states \"\"\" md\"\"\" Specifying the model \"\"\" u prime inv x, Ïƒ x^ 1 Ïƒ function consumption and drift a, z , dv, r, Ïƒ dv max dv, eps 0.0 c u prime inv dv, Ïƒ aÌ‡ z r a c c, aÌ‡, dv end u prime c, Ïƒ c^ Ïƒ function consumption and driftâ‚€ a, z , r, Ïƒ aÌ‡ zero a c z r a dv u prime c, Ïƒ c, aÌ‡, dv end function consumption and drift upwind state, dvf, dvb, Ïƒ, r, aâ‚˜áµ¢â‚™, aâ‚˜â‚â‚“ consumption and savings with forward difference dv, aÌ‡, c consumption and drift state, dvf, Ïƒ, r if aÌ‡ 0 && state.a aâ‚˜â‚â‚“ return dv, aÌ‡f aÌ‡, aÌ‡b 0.0, c, aÌ‡ end consumption and savings with backward difference dv, aÌ‡, c consumption and drift state, dvb, Ïƒ, r if aÌ‡ 0 && state.a aâ‚˜áµ¢â‚™ return dv, aÌ‡f 0.0, aÌ‡b aÌ‡, c, aÌ‡ end consumption and derivate of value function at steady state dv, aÌ‡, c consumption and driftâ‚€ state, Ïƒ, r return dv, aÌ‡f 0.0, aÌ‡b 0.0, c, aÌ‡ end u c, a, Ïƒ, Î³ c 0 ? Ïƒ 1 ? log c Î³ a c^ 1 Ïƒ 1 Ïƒ Î³ a 10.0 c 100.0 vâ‚€ z, a , r, Ïƒ, Ï, Î³ u z r a, a, Ïƒ, Î³ Ï function generator Î» Î»â‚â‚‚, Î»â‚‚â‚ Î» Î› Î»â‚â‚‚ Î»â‚â‚‚ Î»â‚‚â‚ Î»â‚‚â‚ end md\"\"\" Solving the households' problem Helpers \"\"\" function optional to df optional, agrid, zgrid chain optional begin DataFrame transform a bycol collect agrid stack Not a transform i z parse Int, variable end transform variable variable 1 end 1 unstack variable, value transform z zgrid i z select Not i z rename s È§ end end function solve HJB econpdes M crit âˆšeps , vâ‚€ vâ‚€ agrid M.aâ‚˜áµ¢â‚™ . range 0, M.aâ‚˜â‚â‚“ M.aâ‚˜áµ¢â‚™ ^0.8, length M.an .^ 1 0.8 agrid range M.aâ‚˜áµ¢â‚™, M.aâ‚˜â‚â‚“, M.an stategrid OrderedDict a agrid solend OrderedDict Symbol v, i vâ‚€ z, a , M for a âˆˆ agrid for i, z âˆˆ enumerate M.zgrid residual norm, optional pdesolve M, stategrid, solend maxdist crit residual norm, optional, agrid, M.zgrid end function solve HJB econpdes M crit âˆšeps , vâ‚€ vâ‚€ residual norm, optional, agrid, zgrid solve HJB econpdes M crit, vâ‚€ df optional to df optional, agrid, zgrid df.v, df.c, df.È§, df, dist residual norm end md\"\"\" Solving the households' problem \"\"\" md\"\"\" Finding the stationary distribution \"\"\" function solve KF an, Î”a , A N a an AT copy transpose A b zeros 2 N a, 1 i fix 1 b i fix .1 AT i fix, . vec hcat zeros 1, i fix 1 , 1., zeros 1,2 N a i fix try global g stacked AT\\b catch e if e isa SingularException warn \"SingularException â€“ added noise\" global g stacked AT I âˆšeps \\b else rethrow e end end g sum sum g stacked Î”a g stacked norm g stacked . g sum assert sum g stacked norm Î”a â‰ˆ 1 g reshape g stacked norm, N a, 2 end function construct A aÌ‡s, da, N a, N z size ss N a, N z N N a N z car inds CartesianIndices size ss | collect .| Tuple lin inds LinearIndices size ss initialize list of entries A T typeof I from 1, I to 1, Î» 0.0 list T create list of entries of A for I from, aÌ‡ in enumerate aÌ‡s i a, i z car inds I from i a next nothing Î» nothing in which direction to move? if aÌ‡ 0 && i a N a i a next i a 1 Î» aÌ‡ da elseif aÌ‡ 0 && i a 1 i a next i a 1 Î» aÌ‡ da end if isnothing i a next I to lin inds i a next, i z push list, I from, I to, Î» end end construct sparse matrix from list of entries list sa StructArray list A sparse list sa.I from, list sa.I to, list sa.Î», N, N fill diagonal A diagind A . vec sum A, dims 2 A end function construct A switch Î», an id sparse I an Î»â‚â‚‚, Î»â‚‚â‚ Î» Î»â‚â‚‚ id Î»â‚â‚‚ id Î»â‚‚â‚ id Î»â‚‚â‚ id end md\"\"\" Solving the equilibrium \"\"\" r grid range 0.001, 0.03, 10 md\"\"\" Assignment Mian Straub Sufi Meet Huggett in Continuous Time In this assignment we will check if the results from Mian, Straub & Sufi 2020 survive in a Huggett setup. \"\"\" md\"\"\" Task 1 Huggett in Continuous Time 5 points In this part of the exercise, we consider homothetic preferences u c log c , i.e. the case \\gamma 0 . \"\"\" md\"\"\" ğŸ‘‰ 1.1 | 1 point Solve for the equilibrium interest rate. Hint You can use the function ```compute A D``` defined above. \"\"\" Your code goes here md\"\"\" ğŸ‘‰ 1.2 | 1 point Compute the aggregate debt to income ratio in this economy. \"\"\" Your code goes here md\"\"\" ğŸ‘‰ 1.3 | 1 points Consider the following income process z 1 0.14 \\frac 2 3 \\xi z 2 0.14 \\xi \\lambda 1 0.02 \\lambda 2 0.03 where \\xi is a measure of income inequality. Prove that changes in \\xi do not affect aggregate income. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" ğŸ‘‰ 1.4 | 1 points What happens to debt and the interest rate if you increase income inequality \\xi ? \"\"\" bind ineq PlutoUI.Slider 0.06 0.005 0.07, default 0.06, show value true begin Base. kwdef struct HuggettCTMC income process parameters zgrid Vector Float64 0.14 ineq 2 3, 0.14 ineq Î» 0.02, 0.03 Î› Matrix Float64 generator Î» utility parameters Ïƒ Float64 2.0 Ï Float64 0.05 r Float64 0.03 w Float64 1.0 Î³ Float64 0.0 determines the degree of non homotheticity aâ‚˜áµ¢â‚™ Float64 0.1 aâ‚˜â‚â‚“ Float64 1.5 an Int 500 Î”a Float64 aâ‚˜â‚â‚“ aâ‚˜áµ¢â‚™ an 1 end function m HuggettCTMC state NamedTuple, value NamedTuple zgrid, Î›, Ï m nz length zgrid a state v1, v1a up, v1a down, v2, v2a up, v2a down value T eltype value vs v1, v2 dvf v1a up, v2a up dvb v1a down, v2a down states a, z zgrid 1 , a, z zgrid 2 cs Vector T undef, nz aÌ‡s Vector T undef, nz dvs Vector T undef, nz for i âˆˆ 1 2 c, aÌ‡, dv consumption and drift upwind states i , dvf i , dvb i , m cs i c aÌ‡s i aÌ‡ dvs i dv end vts Ï . vs . u. cs, a, Ref m . È§s . dvs . Î› vs return v1t vts 1 , v2t vts 2 , s1 aÌ‡s 1 , s2 aÌ‡s 2 , c1 cs 1 , c2 cs 2 end end output, m let r 0.03 crit 1e 11 m HuggettCTMC r output solve HJB econpdes m crit output, m end let df output chain df begin stack Not a, z data mapping a, value, layout variable, color z nonnumeric, linestyle method nonnumeric visual Lines draw , facet linkyaxes false, end end df Ï€ let A switch construct A switch m an, Î”a m aÌ‡ output.df A construct A aÌ‡, Î”a, an, 2 A switch chain output.df begin transform Ï€ bycol vec solve KF m, A end end output.df chain df Ï€ begin subset a m.aâ‚˜áµ¢â‚™ stack Not a, z data mapping a, value, layout variable, color z nonnumeric, linestyle method nonnumeric visual Lines draw , facet linkyaxes false, end function compute A D r Î³ 0.0 crit 1e 11 m HuggettCTMC r, Î³ output solve HJB econpdes m crit A switch construct A switch m an, Î”a m aÌ‡ output.df A construct A aÌ‡, Î”a, an, 2 A switch df Ï€ chain output.df begin transform Ï€ bycol vec solve KF m, A end excess savings demand A dot df Ï€.Ï€, df Ï€.a Î”a aggreage debt D dot df Ï€.Ï€, df Ï€.a . df Ï€.a . 0 Î”a return A, D end excess savings map r grid do r A, D compute A D r Î³ 0. r, A, D end | DataFrame let fig Figure ax Axis fig 1,1 , xlabel \"interest rate\", ylabel \"asset supply and demand\" lines ax, r grid, excess savings.A, label \"demand excess savings \" lines ax, r grid, excess savings.D, label \"debt\" hlines ax, 0.0 , label \"zero net supply\", color \"gray\", linestyle dash axislegend ax fig end md\"\"\" Your answer goes here ... \"\"\" md\"\"\" ğŸ‘‰ 1.5 | 1 points Find an explanation for the effect of income inequality on the interest rate. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Task 2 Non homothetic preferences 5 points Now we consider nonhomothetic preferences u c, a log c \\gamma a with \\gamma 0.1 . The term \\gamma a has the interpretation that agents get utility from the higher status associated with wealth. ğŸ‘‰ 2.1 | 2 points How does the model in this notebook differ from the model in the Mian Straub Sufi paper? Name two key differences. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" ğŸ‘‰ 2.2 | 1 point Compute the interest rate and debt with the non homothetic preferences. Explain why the equilibrium interest rate is smaller than in the homothetic \\gamma 0 case. \"\"\" Your code goes here Your code goes here md\"\"\" Your answer goes here ... \"\"\" md\"\"\" ğŸ‘‰ 2.3| 1 point What happens to debt and the interest rate if you increase income inequality? \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" ğŸ‘‰ 2.4| 1 point Do your results agree qualitatively with the results in the Mian Straub Sufi paper? Discuss. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Before you submit ... ğŸ‘‰ Make sure you do not mention your name in the assignment. The assignments are graded anonymously. ğŸ‘‰ Make sure that that all group members proofread your submission. ğŸ‘‰ Make sure all the code is well documented . ğŸ‘‰ Make sure that you are within the word limit . Short and concise answers are appreciated. Answers longer than the word limit will lead to deductions. ğŸ‘‰ Go to the very top of the notebook and click on the symbol in the very top right corner. Export a static html file of this notebook for submission. The source code is embedded in the html file. \"\"\" md\"\"\" Appendix \"\"\" TableOfContents function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay â¤\", md\"Great ğŸ‰\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end "},{"url":"housing/housing/","title":"Simple Housing","tags":["housing"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 4 section 1 order 1 title \"Simple Housing\" layout \"layout.jlhtml\" tags \"housing\" description \"\" using Markdown using InteractiveUtils using Optim using QuantEcon using DataFrames, Chain, DataFrameMacros using CairoMakie, AlgebraOfGraphics using AlgebraOfGraphics draw using StatsBase weights using PlutoUI md\"\"\" danger \"Under construction \" This notebook is not ready for public consumption. Use at your own risk. \"\"\" md\"\"\" `housing.jl` | Version 0.1 | last updated Mar 28 2022 \"\"\" md\"\"\" ```math \\begin align &\\max \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t u c t, h t \\Bigr \\\\ &\\begin aligned \\text subject to &u c, h h^\\xi c^ 1 \\xi \\\\ &c t p h t a t p h t 1 1 \\delta a t 1 1 r y t \\cdot w \\\\ &\\log y t \\sim \\text some Markov Chain \\\\ &y 0, k 1 , h 1 \\text given \\end aligned \\end align ``` What needs to be specified parameter ``\\delta``, ``\\xi`` prices ``r``, ``w`` idiosynchratic productivity process initial state `` y 0, k 1 `` \"\"\" md\"\"\" Setting up the recursive problem Naive way two endogenous states ```math \\begin align \\tilde s t & a t 1 , h t 1 , y t \\\\ \\tilde a t & a t , h t \\\\ c \\tilde s, \\tilde a & y t \\cdot w \\underbrace a t 1 1 r p h t 1 1 \\delta \\omega t p h t a t \\\\ r \\tilde s, a, h & u c \\tilde s, \\tilde a , h \\\\ q \\underbrace \\cdot, \\cdot, y t \\tilde s t , \\underbrace \\hat a t, \\hat h t \\tilde a t , \\underbrace a t, h t, y t 1 \\tilde s t 1 & \\begin cases \\Pr y t | y t 1 &\\text if \\hat a t a t \\text and \\hat h t h t\\\\ 0 & \\text otherwise \\end cases \\end align ``` \"\"\" md\"\"\" Sophisticated way one endogenous state, two actions Only possible if housing perfectly liquid i.e. no adjustment frictions ```math \\begin align \\tilde s t & \\omega t, y t \\\\ \\tilde a t & a t , h t \\\\ c \\tilde s, \\tilde a & y t \\cdot w \\omega t a t p h t \\\\ r \\tilde s, a, h & u c \\tilde s, \\tilde a , h \\\\ q \\underbrace \\cdot, y t \\tilde s t , \\underbrace a t, h t \\tilde a t , \\underbrace \\omega t 1 , y t 1 \\tilde s t 1 & \\begin cases \\Pr y t | y t 1 &\\text if \\omega t 1 a t 1 r 1 \\delta ph t\\\\ 0 & \\text otherwise \\end cases \\end align ``` \"\"\" md\"\"\" Sophisticated way one endogenous state, one action Only possible if housing perfectly liquid i.e. no adjustment frictions preferences are simple enough ```math \\begin align \\tilde s t & \\omega t, y t \\\\ \\tilde a t & \\omega t 1 \\\\ c \\tilde s, \\tilde a & y t \\cdot w \\omega t a t p h t \\\\ r \\tilde s, \\omega t 1 & u c \\tilde s, \\tilde a , h \\tilde s, \\tilde a \\\\ q \\underbrace \\cdot, y t \\tilde s t , \\underbrace a t, h t \\tilde a t , \\underbrace \\omega t 1 , y t 1 \\tilde s t 1 & \\begin cases \\Pr y t | y t 1 &\\text if \\omega t 1 a t 1 r 1 \\delta ph t\\\\ 0 & \\text otherwise \\end cases \\end align ``` \"\"\" Î¾ 0.3 md\"\"\" Setting up the `DDP` \"\"\" md\"\"\" Reward `R` \"\"\" function consumption Ï‰, z , Ï‰ next , h next, r, w, p , Î´ Ï‰ Ï‰ next 1 r z w p h next 1 1 Î´ 1 r end a next Ï‰ next , h next, p, r , Î´ Ï‰ next p 1 Î´ h next 1 r function consumption2 Ï‰, z , policy, h next, prices, params a next a next policy, h next, prices, params w, p prices z w Ï‰ a next p h next end h max Ï‰ next , p, r , Ï•, Î´ max Ï‰ next 1 Î´ 1 r Ï• , eps function reward etc state, policy, h next, prices, params u a n a next policy, h next, prices, params c consumption state, policy, h next, prices, params c2 consumption2 state, policy, h next, prices, params a next a n assert c â‰ˆ c2 reward u c, h next , c, h next, a next a n, policy... end function setup R etc R, etc, states, policies, prices, params u for i state, state âˆˆ enumerate states for i policy, policy âˆˆ enumerate policies hÌ„ h max policy, prices, params res maximize h next reward etc state, policy, h next, prices, params u .reward, eps , hÌ„ h opt Optim.maximizer res out reward etc state, policy, h opt, prices, params u R i state, i policy out.reward etc i state, i policy out..., hÌ„ end end end md\"\"\" Transitions `Q` \"\"\" function setup Q Q, states indices, policies indices, z chain for i next state, next âˆˆ enumerate states indices for i policy, Ï‰ next i âˆˆ enumerate policies indices for i state, z i âˆˆ enumerate states indices if next.Ï‰ i Ï‰ next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end md\"\"\" Solve `DDP` \"\"\" Îµ 0.25 z chain MarkovChain 1 Îµ Îµ 2 Îµ 2 Îµ 2 1 Îµ Îµ 2 Îµ 2 Îµ 2 1 Îµ , 1.25, 1.0, 0.75 function statespace Ï‰ vals range 1e 10, 20.0, length 200 , z chain states Ï‰, z for Ï‰ âˆˆ Ï‰ vals, z âˆˆ z chain.state values | vec states indices Ï‰ i, z i for Ï‰ i âˆˆ 1 length Ï‰ vals , z i âˆˆ 1 length z chain.state values | vec policies Ï‰ next for Ï‰ next âˆˆ Ï‰ vals | vec policies indices Ï‰ next i for Ï‰ next i âˆˆ 1 length Ï‰ vals | vec states, states indices, policies, policies indices, z chain end function make u Î¾, Ïƒ function u c, h if c 0 && h 0 C c^ 1 Î¾ h^Î¾ Ïƒ 1 ? log C C^ 1 Ïƒ 1 Ïƒ else h 0 Inf h^Î¾ 100 c 100 end end end function Household Ïƒ 2.0, Î¾ 0.3, Î² 0.96, u make u Î¾, Ïƒ Î², u end household Household Î” 0.01 make u Î¾ 0.5, Ïƒ 2.0 2 Î”, 0.01 Î” 1.0 params Î´ 0.02, Ï• 0.8 function setup R etc states, policies, prices, parms u proto reward etc first states , first policies , 0.01, prices, params u T typeof proto..., hÌ„ 0.1 etc Array T undef, length states , length policies R zeros length states , length policies setup R etc R, etc, states, policies, prices, params u R, etc end function setup DDP household, statespace, prices, params Î², u household states, policies, states indices, policies indices, z chain statespace Rewards and policies R, etc setup R etc states, policies, prices, params u Transition function Q setup Q states indices, policies indices, z chain ddp DiscreteDP R, Q, Î² ddp, R, etc end md\"\"\" Analyze results \"\"\" function solve details0 ddp, statespace, other policies solver PFI results QuantEcon.solve ddp, solver states, policies statespace opp DataFrame other policies i, s for i, s âˆˆ enumerate results.sigma df hcat DataFrame states , DataFrame policies results.sigma , opp, makeunique true df.value results.v df.state states df.policy policies results.sigma df.additional policies other policies results.sigma df.Ï€ only stationary distributions results.mc df, results end function solve details ddp, statespace, additional policies solver PFI df solve details0 ddp, statespace, additional policies solver chain df begin transform consumption consumption state, policy, prices transform saving Ï‰ next Ï‰ select Not state, policy, additional policies end end md\"\"\" Equilibrium \"\"\" prices p 2.0, r 0.05, w 1.0 reward etc Ï‰ 2, z 1 , Ï‰ next 2.8 , 1.0, prices, params u make u Î¾ 0.5, Ïƒ 2 Ï‰ grid range 0.1, 10, length 200 ss statespace Ï‰ vals Ï‰ grid, z chain R, ddp, etc setup DDP household, ss, prices, params policies df mapreduce vcat, enumerate eachrow etc do i, row df DataFrame row df.state . i df end chain policies df begin subset state % 10 0 subset reward Inf stack c, h next, a next, reward data mapping Ï‰ next, value, layout variable, color state nonnumeric visual Lines draw facet linkyaxes false, end results df solve details ddp, ss, etc let fg chain results df begin stack Not Ï‰, z, Ï€ a next, consumption, saving data mapping Ï‰ L\"current assets \\omega \", value \"policy\", layout variable, color z nonnumeric, visual Lines draw facet linkyaxes false, , legend position top, titleposition left end ax content fg.figure 2,1 abline ax, 0, 1, color gray, linestyle dash, loose fg end chain results df begin data mapping Ï‰, Ï€, color z nonnumeric visual Lines draw end chain results df begin stack a next, h next, Ï‰ next , Ï€ data mapping value, weights Ï€, layout variable AlgebraOfGraphics.density draw facet linkyaxes false, linkxaxes false end H 1 function aggregates results chain results begin stack Not Ï€ groupby variable combine aggregate sum value, weights Ï€ zip .variable, .aggregate Dict end end agg aggregates results df h agg \"h next\" , a agg \"a next\" md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"julia-basics/basic-julia/","title":"Basic Julia","tags":["julia-basics"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 1 section 1 order 1 title \"Basic Julia\" layout \"layout.jlhtml\" tags \"julia basics\" description \"\" using Markdown using InteractiveUtils using PlutoUI md\"\"\" `basic julia.jl` | Version 1.2 | last updated Feb 3 2022 \"\"\" md\" A first glance at the Julia language This notebook briefly summarizes some of the basic Julia syntax that we will need for the problem sets. \" Markdown.MD Markdown.Admonition \"warning\", \"This notebook is taken from\", md\"\"\" Computational Thinking , a live online Julia Pluto textbook. computationalthinking.mit.edu https computationalthinking.mit.edu , original notebook https github.com mitmath 18S191 blob Fall20 lecture notebooks Basic%20Julia%20syntax.jl \"\"\" md\" Variables We can define a variable using ` ` assignment . Then we can use its value in other expressions \" x 3 y 2x md\"By default Julia displays the output of the last operation. You can suppress the output by adding ` ` a semicolon at the end. \" md\"We can ask what type a variable has using `typeof` \" typeof y md\" Functions\" md\"We can use a short form, one line function definition for simple functions \" f x 2 x md\"Typing the function's name gives information about the function. To call it we must use parentheses \" f f 10 md\"For longer functions we use the following syntax with the `function` keyword and `end` \" function g x, y z x y return z^2 end g 1, 2 md\" For loops\" md\"Use `for` to loop through a pre determined set of values \" let s 0 for i in 1 10 s s i end s end md\"Here, `1 10` is a range representing the numbers from 1 to 10 \" typeof 1 10 md\"Above we used a `let` block to define a new local variable `s`. But blocks of code like this are usually better inside functions, so that they can be reused. For example, we could rewrite the above as follows \" function mysum n s 0 for i in 1 n s s 1 end return s end mysum 100 md\" Conditionals `if`\" md\"We can evaluate whether a condition is true or not by simply writing the condition \" a 3 a 5 md\"We see that conditions have a Boolean `true` or `false` value. We can then use `if` to control what we do based on that value \" if a 5 \"small\" else \"big\" end md\"\"\"Note that the `if` also returns the last value that was evaluated, in this case the string `\"small\"` or `\"big\"`, Since Pluto is reactive, changing the definition of `a` above will automatically cause this to be reevaluated \"\"\" md\" Arrays\" md\" 1D arrays `Vector`s \" md\"We can make a `Vector` 1 dimensional, or 1D array using square brackets \" v 1, 2, 3 typeof v md\"The `1` in the type shows that this is a 1D array. We access elements also using square brackets \" v 2 v 2 10 md\"Note that Pluto does not automatically update cells when you modify elements of an array, but the value does change.\" md\"A nice way to create `Vector`s following a certain pattern is to use an array comprehension \" v2 i^2 for i in 1 10 md\" 2D arrays matrices \" md\"We can make small matrices 2D arrays with square brackets too \" M 1 2 3 4 typeof M md\"The `2` in the type confirms that this is a 2D array.\" md\"This won't work for larger matrices, though. For that we can use e.g.\" zeros 5, 5 md\"Note that `zeros` gives `Float64`s by default. We can also specify a type for the elements \" zeros Int, 4, 5 md\"We can then fill in the values we want by manipulating the elements, e.g. with a `for` loop.\" md\"A nice alternative syntax to create matrices following a certain pattern is an array comprehension with a double `for` loop \" i j for i in 1 5, j in 1 6 md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"julia-basics/more-julia/","title":"More Julia","tags":["julia-basics"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 1 section 2 order 1 title \"More Julia\" layout \"layout.jlhtml\" tags \"julia basics\" description \"\" using Markdown using InteractiveUtils using DataFrames using DataFrameMacros using Chain chain using PlutoUI md\"\"\" `more julia.jl` | Version 1.1 | last updated May 10 2022 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" More Julia \"\"\" md\"\"\" The purpose of this notebook is to make you familiar with Julia syntax that is frequently used in the course material. It also points out the peculiarities of Pluto notebooks. \"\"\" md\"\"\" Named tuples and keyword arguments Named tuples Like many other programming languages, Julia allows you to create tuples. The elements of tuples can be accessed by using the corresponding index \"\"\" standard tuple 1, 2 standard tuple 1 md\"\"\" Julia also has named tuples. Just like standard tuples, named tuples allow you to access an element using its index, but alternatively you can also access an element by its name. \"\"\" named tuple a 1, b 2 named tuple.a md\"\"\" This is convenient because it means that you do not need to remember if some parameter is the first element in a tuple or the second one. Below you can see an alternative way of creating named tuples that is frequently used in the course material \"\"\" let a 1 named tuple2 a, b 2 a is equivalent to a a end md\"\"\" Keyword arguments A similar syntax with a semicolon is used for keyword arguments that are identified by name and not by their position as normal function arguments \"\"\" function some function a, b 1 return a b end some function a 3, b 5 let a 3 some function a, b 5 a is equivalent to a a end md\"\"\" Vectorization with dot syntax You can apply a function to all elements of a vector by using the dot syntax \"\"\" 1,2,3 .^ 2 log. 1,2,3 md\"\"\" Note how Julia usually does things in a way that's mathematically consistent. Look at the following code. \"\"\" A ones 3, 3 exp A exp. A A^2 A .^ 2 md\"\"\" What would Python, R or Matlab do? \"\"\" md\"\"\" The pipe operator The pipe operator | makes it possible to write down nested function calls in a more readable way. For example, the two expressions below do the same thing \"\"\" round log named tuple.b named tuple.b | log | round md\"\"\" In case you use R The | operator in Julia is similar to the % % operator in R. \"\"\" md\"\"\" Unicode characters You can use Greek letters and other Unicode characters in your Julia code. For example, type \"\\alpha\" in the cell below without the quotation marks and press Tab on your keyboard. This should create an \\alpha symbol. \"\"\" md\"\"\" See the Julia documention https docs.julialang.org en v1 manual unicode input for a list of supported Unicode characters. For Greek letters, the abbreviations are the same as in LaTeX. \"\"\" md\"\"\" The \\in symbol An elegant way of writing loops is to use the \\in symbol instead of writing \"in\". The \\in symbol can be created by typing \"\\in\" and pressing Tab. \"\"\" i^2 for i âˆˆ 1 5 md\"\"\" Working with data Here are a few simple examples of working with DataFrames in Julia. If you are familiar with pandas, dplyr or Stata, have a look at this cheatsheet https dataframes.juliadata.org stable man comparisons . Also, have a look at the documentation of DataFrameMacros.jl https jkrumbiegel.github.io DataFrameMacros.jl stable which makes working with DataFrames much more convenient. \"\"\" md\"\"\" Creating a `DataFrame` \"\"\" df1 DataFrame x 1 10 md\"\"\" Transforming mutating a column \"\"\" transform df1, x ByRow x sqrt x transform df1, sqrt x uses transform from DataFrameMacros.jl md\"\"\" The ``` chain``` macro \"\"\" md\"\"\" The ``` chain``` macro works similar to the pipe operator. In the code for this course, the ``` chain``` macro is often applied to data frames together with macros from the ```DataFrameMacros``` package. \"\"\" df2 DataFrame A 1,2,2,1 , B randn 4 md\"\"\" Consider the data frame above. Let's say you would like to add up the values in the B column separately for each value of A take the absolute value of the resulting sums of B values. Using the ``` chain``` macro, we can perform this task with relatively concise code \"\"\" chain df2 begin groupby A combine sum B , automatically named C sum B specify name transform abs C end md\"\"\" Without the ``` chain``` macro, the code would look like this \"\"\" begin df groups groupby df2, A df sum combine df groups, sum B , C sum B transform df sum, abs C end md\"\"\" Pluto notebooks General advice Press F1 to see shortcuts for Pluto notebooks. Ctrl Click on an underlined variable or function to jump to its definition. Use the Live docs in the bottom right corner to get more information about any Julia function or object. Check the Github wiki https github.com fonsp Pluto.jl wiki for more information on Pluto notebooks. Automated updating of cells When changing a function or variable, Pluto automatically updates all affected cells. For example, change the value of d to some other number and see how the following cell updates automatically \"\"\" d 5 d 10 md\"\"\" This is different from jupyter notebooks in which you have to update related cells manually. The automated updating the advantage that you do not have to keep in mind the order in which to evaluate cells. However, it can also be annoying if some of the affected cells take a long time to run. At the time of writing, there is no way to turn off the automated updating but you can always manually disable cells with long run times by clicking on the three dots in the top right corner of a cell. \"\"\" md\"\"\" Only one expression per cell Pluto notebooks only allow one expression per cell. If you nevertheless want to place several expressions into the same cell, you have to use a begin ... end block \"\"\" begin e 10 f e 5 end md\"\"\" Cannot reuse variable names \"\"\" md\"\"\" Use `let` blocks to specify variable names locally. \"\"\" let g 3 end g md\"\"\" Deactivate cells \"\"\" â• â•â•¡ sleep 5 â• â•â•¡ md\"\"\" Imported Packages \"\"\" TableOfContents g 1 g 2 "},{"url":"long-run/indebted-demand/","title":"Indebted demand","tags":["long-run"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 5 section 2 order 2 title \"Indebted demand\" layout \"layout.jlhtml\" tags \"long run\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using LinearAlgebra using ForwardDiff using Roots using Chain, DataFrames, DataFrameMacros using AlgebraOfGraphics, CairoMakie using PlutoUI using PlutoUI Slider md\"\"\" `indebted demand.jl` | Version 1.1 | last updated May 31 2023 \"\"\" md\"\"\" Indebted demand This lecture is based on the paper Indebted Demand Mian, Straub & Sufi 2021 QJE . Motivation We have seen rising inequality, rising debt and falling interest rates. See the notebook `macroeconomic trends.jl`. This paper make the point that wealth inequality is driving down interest rates and driving up household debt if preferences are non homothetic . \"\"\" md\"\"\" Parameters and functional forms \"\"\" Base. kwdef struct IndebtedDemandModel Î¼Ë¢ 0.01 population share of the rich Ï‰Ë¢ 0.06 wealth share of the rich Ï 0.1 discount factor â„“ 0.0248 pledgeability of real assets Î´ 0.025 mortality rate Î·Ìƒ 0.87 bequest parameter 1 calibrated aÌƒ 0.38 bequest parameter 2 calibrated â€“ match MPC out of wealth of 0.01 Î» 1 end Î· a, Î·Ìƒ, aÌƒ 1 1 Î·Ìƒ aÌƒ log 1 exp Î·Ìƒ a aÌƒ md\"\"\" Computing the equilibrium \"\"\" d r, â„“ â„“ r function r rhs r, d, params Ï, Î´, Ï‰Ë¢ params Ï 1 Î´ Ï 1 Î´ Ï Î· Ï‰Ë¢ r d, params end f r, d, params r r rhs r, d, params function savings supply d, params, bracket 0.0001, 1.0 try return find zero r f r, d, params , bracket catch info f d, bracket 1 , params , f d, bracket 2 , params return missing end end function equilibrium df params chain begin DataFrame d range 4, 4, 200 transform r supply savings supply d, params transform r demand params.â„“ d stack r\"^r \", value name r transform variable replace variable, \"r \" \"\" subset ismissing r subset 0.0 r 0.13 end end function f equilibrium r, params f r, d r, params , params end md\"\"\" Comparative statics Inequality drives interest rates and household debt \"\"\" params default IndebtedDemandModel Ï‰Ë¢ 0.02 let params params default r eq find zero r f equilibrium r, params , 0.001, 0.1 d eq d r eq, params r eq, d eq end md\"\"\" ``\\omega^S`` bind Ï‰Ë¢ Slider 0.01 0.005 0.07, show value true, default 0.02 wealth share of the rich ``\\ell`` bind â„“ Slider 0.01 0.005 0.1, show value true, default 0.0248 pledgability of real assets \"\"\" params slider IndebtedDemandModel Ï‰Ë¢, â„“ df default equilibrium df params default let df slider equilibrium df params slider df vcat df default, df slider, source parameters default, slider chain df begin data mapping d \"debt level\", r \"interest rate\", color variable \"\", linestyle parameters \" \" visual Lines draw legend position top, titleposition left end end md\"\"\" Calibration In the paper, they pick ``r`` and ``\\rho`` and choose the parameters `` \\tilde \\eta, aÌƒ `` from the ``\\eta`` function. \"\"\" md\"\"\" ``\\tilde \\eta`` bind Î·Ìƒ Slider 0.5 0.01 1.3, default 0.87, show value true ``aÌƒ`` bind aÌƒ Slider 0.1 0.01 0.9, default 0.38, show value true \"\"\" let params IndebtedDemandModel Ï‰Ë¢ 0.06 r eq find zero r f equilibrium r, params , 0.001, 0.1 d eq d r eq, params r eq, d eq end let params IndebtedDemandModel Ï‰Ë¢ 0.06 r eq find zero r f equilibrium r, params , 0.001, 0.1 d eq d r eq, params r eq, d eq end let Ï, Î´, â„“, Ï‰Ë¢ params default r analytic Ï Î´ Î´ Ï Ï‰Ë¢ â„“ d analytic â„“ Ï Î´ Î´ Ï Ï‰Ë¢ â„“ end Î· prime a, params ForwardDiff.derivative a Î· a, params , a Î· prime 1.0, params default Îµ Î· a, params Î· prime a, params a Î· a, params Îµ Î· 3.0, params default function MPC a, r, params Ï, Î´, â„“, Ï‰Ë¢ params r Ï Î´ 1 âˆš 1 4 1 r Ï Î´ r Ï Î´ Îµ Î· a, params end function f cali Î·Ìƒ, aÌƒ params IndebtedDemandModel Î·Ìƒ, aÌƒ r 0.055 dd d r, params Î”r f r, dd, params a params.Ï‰Ë¢ r dd mpc MPC a, r, params Î”mpc mpc 0.01 info dd, Î”r, Î”mpc, mpc norm Î”r, Î”mpc end f cali Î·Ìƒ, aÌƒ md\"\"\" Appendix \"\"\" TableOfContents function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay â¤\", md\"Great ğŸ‰\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end "},{"url":"long-run/redistributive-growth/","title":"Redistributive growth","tags":["long-run"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 5 section 3 order 3 title \"Redistributive growth\" layout \"layout.jlhtml\" tags \"long run\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoUI using PlutoUI Slider using DataFrames using CairoMakie using ForwardDiff using Optim using LaTeXStrings md\"\"\" `redistributive growth.jl` | Version 1.2 | last updated on May 10, 2023 \"\"\" md\"\"\" Redistributive Growth This lecture is based on the paper Redistributive Growth DÃ¶ttling and Perotti 2019 . This paper tries to explain various macroeconomic trends with a technological shift to intangible capital. \"\"\" md\"\"\" Parameterization \"\"\" md\"\"\" We use a slight variation of the parameterization in the September 2019 version of the paper. The utility from housing is v L \\log L . \"\"\" Base. kwdef struct RedistributiveGrowthModel LÌ„ 1 supply of land Ï• 0.2 fraction with high human capital hÌƒ 8 0.2 inelastic supply of high skilled labor lÌƒ 10 1 0.2 inelastic supply of low skilled labor Î± 0.33 capital share Î· 0.45 relative productivity of intangible capital & high skilled labor Ï‰ 0.9 fraction of intangibles that can be \"stolen\" by innovators Ïˆ 1. cost for producing intangibles A 1. productivity end mod RedistributiveGrowthModel md\"\"\" Representative firm \"\"\" md\"\"\" We consider the special case \\rho \\rightarrow 0 in which the production function has a Cobb Douglas form Y F K, H, l, h A H^\\alpha h^ 1 \\alpha ^\\eta K^\\alpha l^ 1 \\alpha ^ 1 \\eta \"\"\" function F K, H, l, h, A, Î·, Î± A H^Î± h^ 1 Î± ^Î· K^Î± l^ 1 Î± ^ 1 Î· end md\"\"\" 1. Productivity of intangible capital \\eta bind Î· sl Slider range 0, 1, length 101 , default 0.5, show value true 2. Capital share \\alpha bind Î± sl Slider range 0, 1, length 101 , default 0.5, show value true 3. Common productivity factor A bind A sl Slider 1 100, default 1, show value true \"\"\" md\"\"\" Labor is supplied inelastically in this model so that l 1 \\phi \\tilde l and h \\phi \\tilde h . Therefore, we can write down the production function as a function of only K and H \"\"\" function F K, H, A, Î·, Î±, Ï•, lÌƒ, hÌƒ l 1 Ï• lÌƒ h Ï• hÌƒ F K, H, l, h, A, Î·, Î± end md\"\"\" We can compute the first derivatives of the production function numerically which correspond to the factor prices price of physical capital 1 r price of intangible capital R H wage for manual workers w wage for high skill workers q \"\"\" F xx, par F xx..., par let Hs Ks range 0.01, 1, length 101 title latexstring \"Contour plot of \\ Y K, H, l 1, h 1 \\ \" fig Figure ax, plt contourf fig 1,1 , Hs, Ks, x, y F x, y, 1., 1., A A sl, Î· Î· sl, Î± Î± sl , axis title, xlabel L\"K\", ylabel L\"H\" Colorbar fig 1,2 , plt fig end function get prices K, H, mod Ï•, lÌƒ, hÌƒ mod l 1 Ï• lÌƒ h Ï• hÌƒ xx K, H, l, h oneplusr, R H, w, q ForwardDiff.gradient x F x, mod , xx Y F xx, mod check Y w l q h oneplusr K R H H check, oneplusr, R H, w, q, Y end get prices 0.5, 1., mod md\"\"\" Steady state equilibrium \"\"\" md\"\"\" The equations that describe the steady state values of \\ K, H, Y, r, R H, f, p\\ together with the production function are given in the appendix of the paper 1 r \\alpha 1 \\eta \\frac Y K R H \\alpha \\eta \\frac Y H H \\frac \\omega \\psi R H f \\frac 1 \\omega R H H r p \\frac v' \\bar L r \\frac 1 \\bar L r 1 \\alpha Y p \\bar L f K \"\"\" md\"\"\" Exercise 1 3 points ğŸ‘‰ Provide brief derivations for equation 1 1 point and equation 4 2 points above. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Solving for the steady state \"\"\" md\"\"\" We use numerical methods to solve for the steady state. First, we reformulate the system of equations by substituting out the five variables \\ Y, r, R H, f, p\\ , so that we end up with a system of just two equations as a function of K and H \"\"\" function model equations 1 K, H, mod Î±, Î·, Ï‰, LÌ„, Ï•, lÌƒ, A mod Y F K, H, mod production function r Î± 1 Î· Y K 1 eq. 1 rearranged R H Î± Î· Y H eq. 2 f 1 Ï‰ R H H r eq. 4 p 1 LÌ„ r eq. 5 return Y, r, R H, f, p end function model equations 2 K, H, mod Y, r, R H, f, p model equations 1 K, H, mod Î±, Ï‰, LÌ„, Ïˆ mod eq 1 H Ï‰ Ïˆ R H eq. 3 rearranged eq 2 1 Î± Y p LÌ„ f K eq. 6 rearranged return eq 1, eq 2 end md\"\"\" ```eq 1``` and ```eq 2``` in the function above should be zero at the steady state values of K and H . Consequently, the sum of the squares ```eq 1```Â² ```eq 2```Â² should also be zero in this case. This means that we can find the steady state values of K and H by applying a minimization algorithm to ```eq 1```Â² ```eq 2```Â². To make sure that the algorithm does not accidentally use negative values for K or H , we write down the objective function in terms of \\log K and \\log H . After running the minimization algorithm, we always need to check if the sum of squares is indeed zero or at least extremely close to zero . Other solution algorithms are possible and probably better than this approach. See this notebook https greimel.github.io distributional macroeconomics notebooks redistributive growth fabian with alternative solution methods for the redistributive growth model. \"\"\" function objective function log K log H, mod K exp log K log H 1 H exp log K log H 2 eq 1, eq 2 model equations 2 K, H, mod return eq 1^2 eq 2^2 end md\"\"\" We need to initialize the minimization algorithm at values for K and H that are associated with a positive interest rate r . Otherwise, the algorithm may converge to another minimum with a negative interest rate that is not economically meaningful. Below you can see that the interest rate associated with our starting values is indeed positive. \"\"\" begin K init 0.4 H init 1. model equations 1 K init, H init, mod end md\"\"\" Now we apply the minimization algorithm. The objective function is very close to 0 at the minimum that the algorithm found. \"\"\" res optimize x objective function x, mod , log K init , log H init md\"\"\" Since the arguments of the objective function are \\log K and \\log H , we need to exponentiate the minimizer to get the steady state values of K and H \"\"\" K, H exp. Optim.minimizer res md\"\"\" To find the steady state values of \\ Y, r, R H, f, p\\ , we put the steady state values of K and H into the equations that we have used to substitute out these five variables \"\"\" model equations 1 K, H, mod md\"\"\" Moreover, we can get steady state wages w and q by computing the numerical gradient of the production function \"\"\" get prices K, H, mod md\"\"\" Exercise 2 1 point The steady state interest rate r round model equations 1 K, H, mod .r 100,digits 1 % seems quite big at a first glance. ğŸ‘‰ Is steady state interest rate in the model roughly consistent with interest rates in the real world? Provide a brief explanation. max. 100 words \"\"\" answer 2 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Secular trends \"\"\" md\"\"\" The paper claims that a shift towards intangible capital \\eta \\uparrow in the model can explain the following macroeconomic trends declining interest rates r \\downarrow increasing share of intangible capital H H K \\uparrow declining physical investment scaled by GDP K Y \\downarrow increasing mortgage borrowing m Y \\uparrow increasing house prices p Y \\uparrow increasing stock prices f Y \\uparrow increasing wage inequality q w \\uparrow \"\"\" md\"\"\" To confirm that an increase in \\eta indeed generates the secular trends listed above for the given parameterization, we compute the steady state for a slightly higher value of \\eta such as \\eta round mod.Î· 0.1, digits 2 and compare the variables of interest in the two steady states. \"\"\" mod Î· RedistributiveGrowthModel Î· mod.Î· 0.1 model equations 1 K init, H init, mod Î· res Î· optimize x objective function x, mod Î· , log K init , log H init K Î·, H Î· exp. Optim.minimizer res Î· md\"\"\" The first row describes the steady state for the baseline value for \\eta , the second row for \\eta round mod Î·.Î·, digits 3 \"\"\" md\"\"\" Below you can find two helper functions to compute the macroeconomic variables of interest for given steady state values K , H , and to compare macroeconomic variables across steady states \"\"\" function compute trends variables K, H, mod Y, r, R H, f, p model equations 1 K, H, mod Ï•, LÌ„, lÌƒ mod w, q get prices K, H, mod m max 0, 1 Ï• p LÌ„ f w lÌƒ H HK H H K K Y K Y m Y m Y p Y p Y f Y f Y q w q w r, H HK, K Y, m Y, p Y, f Y, q w end begin trends vars compute trends variables K, H, mod trends vars Î· compute trends variables K Î·, H Î·, mod Î· DataFrame trends vars, trends vars Î· end function trends trends vars 1, trends vars 0 for key in keys trends vars 0 if trends vars 1 key trends vars 0 key 1e 6 sgn \"â†‘\" elseif trends vars 1 key trends vars 0 key 1e 6 sgn \"â†“\" else sgn \"â†’\" end println key, \" \" , sgn end end trends trends vars Î·, trends vars md\"\"\" Alternative growth drivers \"\"\" md\"\"\" In the previous section, we found out that a technological shift to intangible capital \\eta \\uparrow can explain the secular trends at least qualitatively . But is it the only possible explanation of these trends? In order to exclude other possible explanations, we need to consider alternative growth drivers and check which of the secular trends they can replicate and which not. The following alternative growth drivers are already implemented in the model greater ease of innovation \\psi \\downarrow rising share of educated workers \\phi \\uparrow rising productivity of capital relative to labor \\alpha \\uparrow increased bargaining power for innovators over established firms \\omega \\uparrow \"\"\" md\"\"\" Exercise 3 2.5 points ğŸ‘‰ Pick one of the four alternative growth drivers listed above and conduct a comparison of steady states similar to the \\eta \\uparrow case. Which of the secular trends can this growth driver explain and which not? Provide a brief explanation for the changes in \\ r, H H K , K Y, m Y, p Y, f Y, w q\\ that are generated by the parameter change that you consider. max. 200 words \"\"\" Your code goes here ... answer 3 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Exercise 4 3.5 points An alternative growth driver are capital inflows from emerging countries into the developed world \"global savings glut\" . These capital inflows can be incorporated into the model by adding an exogenous increase in savings x to the steady state equations 1 \\alpha x Y p \\bar L f K ğŸ‘‰ Add the exogenous increase in savings to the model and repeat exercise 3 for this alternative growth driver. max. 200 words \"\"\" Your code goes here ... answer 4 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Before you submit ... ğŸ‘‰ Make sure you do not mention your name in the assignment. The assignments are graded anonymously. ğŸ‘‰ Make sure that that all group members proofread your submission. ğŸ‘‰ Make sure all the code is well documented . ğŸ‘‰ Make sure that you are within the word limit . Short and concise answers are appreciated. Answers longer than the word limit will lead to deductions. ğŸ‘‰ Go to the very top of the notebook and click on the symbol in the very top right corner. Export a static html file of this notebook for submission. The source code is embedded in the html file. \"\"\" md\"\"\" Appendix \"\"\" md\"\"\" Acknowledgments The visualization of the production function was contributed by Andrea Titton https github.com NoFishLikeIan . \"\"\" md\"\"\" Word limit functions \"\"\" function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay â¤\", md\"Great ğŸ‰\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end show words limit answer 2, 100 show words limit answer 3, 200 show words limit answer 4, 200 md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"preliminaries/aiyagari/","title":"Aiyagari","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 2 section 3 order 3 title \"Aiyagari\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoUI Button, Slider, TableOfContents, NumberField using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using DataFrames stack using StatsBase weights using Statistics mean using LinearAlgebra using Roots find zero, Brent using QuantEcon md\"\"\" `aiyagari.jl` | Version 1.1 | last updated May 16, 2022 \"\"\" md\"\"\" Bewley Huggett Aiyagari \"\"\" md\"\"\" Households' problem \"\"\" md\"\"\" ```math \\begin align &\\max \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t u c t \\Bigr \\\\ &\\begin aligned \\text subject to &u c \\log c \\\\ &c t k t k t 1 1 r \\delta y t \\cdot w \\\\ &\\log y t \\sim \\text some Markov Chain \\\\ &y 0, k 1 \\text given \\end aligned \\end align ``` What needs to be specified parameter ``\\delta`` prices ``r``, ``w`` idiosynchratic productivity process initial state `` y 0, k 1 `` \"\"\" md\"\"\" Let ``s k, y `` be the state and ``a k' `` be the action. We can then write ```math c s,a \\cdots y \\cdot w k\\cdot 1 r \\delta k' ``` Let us also define the reward function ```math r s, a \\cdots u c s,a \\cdots ``` Rewrite this recursively, ```math \\begin align v s \\max a \\in A r s, a \\operatorname E v s' |s, a \\end align ``` \"\"\" md\"\"\" Setup \"\"\" md\"\"\" To find a solution to the households' problem, we will use the Quantecon toolbox. The toolbox requires us to specify an n \\times m array R that contains the value of the reward function for each state and action R ij r s i, a j an n \\times m \\times n array Q that gives the probability to end up in state s' in the next period for a given state s and action a in this period Q ijk \\text Prob s' s k|s s i, a a j a discount factor \\beta . For more information on this way of formulating Discrete State Dynamic Programming problems, please have a look at the QuantEcon lecture notes https julia.quantecon.org dynamic programming discrete dp.html on this topic. \"\"\" md\"\"\" As a first step, we represent household preferences by a named tuple that contains the discount factor \\beta and the utility function u \\cdot \"\"\" function Household Ïƒ 1.0, Î² 0.96, u Ïƒ 1 ? log x x^ 1 Ïƒ 1 1 Ïƒ Î², u end md\"\"\" Moreover, the function below constructs the state space for a given grid of asset values ```k vals``` and a given Markov process ```z chain```. The resulting vector of possible states has length n and the vector of possible policies has length m . \"\"\" function statespace k vals range 1e 10, 20.0, length 200 , z chain states k, z for k âˆˆ k vals, z âˆˆ z chain.state values | vec states indices k i, z i for k i âˆˆ 1 length k vals , z i âˆˆ 1 length z chain.state values | vec policies k next for k next âˆˆ k vals | vec policies indices k next i for k next i âˆˆ 1 length k vals | vec states, states indices, policies, policies indices, z chain end md\"\"\" Now we can compute the array of transition probabilities Q If the chosen amount of assets coincides with the amount of assets in the state next period, the transition probability is equal to the transition probability for the productivity process \\text Prob z'|z . In all other cases, the transition probability is zero. \"\"\" function setup Q Q, states indices, policies indices, z chain for i next state, next âˆˆ enumerate states indices for i policy, k next i âˆˆ enumerate policies indices for i state, z i âˆˆ enumerate states indices if next.k i k next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end md\"\"\" Before we can compute the reward array R , we first need a function that can compute consumption for a given state and action. The function below allows for a higher interest rate r \\text borrow r \\Delta r for households with negative assets. \"\"\" function consumption z, k , k next , q, w, Î”r if k next 0 && Î”r 0 r 1 q 1 k next 0 Î”r q 1 1 r end c w z k q k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, policies, prices, u for k i, policy âˆˆ enumerate policies for s i, state âˆˆ enumerate states R s i, k i reward state, policy, prices, u end end return R end function setup R states, policies, prices, u R zeros length states , length policies setup R R, states, policies, prices, u end md\"\"\" Finally, we define a function that creates an instance of the ```DiscreteDP``` i.e. Discrete Dynamic Program class for given household preferences, a given state space and given prices. \"\"\" md\"\"\" Model parameters \"\"\" md\"\"\" First, let us define the interest rate, the wage, and the interest wedge for borrowers. We also define functions that turn the interest rate into the price of a bond q . \"\"\" r 0.02 q r 1 1 r prices q q r , w 1.0, Î”r r 2 md\"\"\" Next, we define choose the parameters that govern household preferences. \"\"\" hh Household Ïƒ 2.0, Î² 0.96 md\"\"\" We also need to define the Markov chain for the productivity process \"\"\" z chain MarkovChain 0.75 0.25 0.25 0.75 , 1.25, 0.75 function setup DDP household, statespace, prices Î², u household states, policies, states indices, policies indices statespace R setup R states, policies, prices, u Q setup Q states indices, policies indices, z chain DiscreteDP R, Q, Î² end md\"\"\" We combine this Markov chain with a grid for assets ```k vals``` to construct the state space. The smallest asset value on the grid defines the maximum amount that a household can borrow. The largest asset value on the grid needs to be large enough so that it does not distort the model solution. \"\"\" ss statespace k vals range 1., 5., length 200 , z chain md\"\"\" As the final step, we create an instance of the ```DiscreteDP``` class for the previously defined parameter values. \"\"\" ddp setup DDP hh, ss, prices md\"\"\" Solve households' problem \"\"\" md\"\"\" We solve the households' problem using the policy function iteration PFI algorithm from the QuantEcon toolbox. In the data frame below, each row corresponds to point in the state space. \\pi denotes the stationary distribution. \"\"\" function solve details0 ddp, states, policies solver PFI results QuantEcon.solve ddp, solver df DataFrame states DataFrame policies results.sigma df.state states df.policy policies results.sigma df.Ï€ stationary distributions results.mc , 1 1 df end function solve details ddp, states, policies solver PFI df solve details0 ddp, states, policies solver chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end end results solve details ddp, ss.states, ss.policies solver PFI md\"\"\" Policy functions The figure below show how much a household should consume and how much it should save given its current amount of assets and productivity state. \"\"\" let fg chain results begin stack Not k, z, Ï€ data mapping k L\"current assets k \", value \"policy\", layout variable, color z nonnumeric, visual Lines draw facet linkyaxes false, , legend position top, titleposition left end ax content fg.figure 2,1 fg end k first chain results begin subset k next k groupby z combine first k end md\"\"\" Below, we compute the lowest asset value at which we observe dissaving by the household. Households in the low productivity state dissave even when they are very close to the borrowing constraint, while households in the high productivity state only start dissaving above an asset level of round k first 1, \"k first\" , digits 3 . \"\"\" md\"\"\" Stationary distribution The figure below depicts the probability density over assets for separately for the two productivity levels. \"\"\" chain results begin data mapping k, Ï€, color z nonnumeric visual Lines draw end md\"\"\" More on the stationary distribution In the first lecture you have learned that the Aiyagari model is a Markov chain with respect to the n \\times n transition matrix Q^ that is implicitly defined by the stochastic income process and the optimal savings rule. Note that Q^ is different from the n \\times m \\times n matrix Q which did not impose the optimal savings rule. In the cell below, we compute Q^ by combining the optimal savings rule with the Q matrix. We also check if the rows of Q^ sum to 1 \"\"\" begin res QuantEcon.solve ddp, PFI Q setup Q ss.states indices, ss.policies indices, ss.z chain Q star 1 zeros length ss.states , length ss.states for i state, state âˆˆ enumerate ss.states indices Q star 1 i state, Q i state,res.sigma i state , end sum Q star 1 dims 2 ' end md\"\"\" Within the QuantEcon framework, the Q^ matrix is saved as ```res.mc.p``` where ```res``` is some results object that is returned by the ```QuantEcon.solve``` function. Below, we check if the Q^ matrix computed by us is the same as the Q^ matrix computed by the ```QuantEcon project``` \"\"\" begin Q star 2 res.mc.p isapprox Q star 1, Q star 2 end md\"\"\" If the Markov chain is ergodic, we can obtain the stationary distribution by starting with an arbitray distribution \\pi 1 over the state space and applying the transition matrix to it until the distribution converges to the stationary distribution \\pi \\infty . You can do this using the buttons below Restart Initialize \\pi 1 such that all agents are in the high income state with zero assets Update \\pi i 1 ' \\pi i' \\cdot Q^ Feel free to choose another initialization. Note that Pluto automatically applies one update step after you press \"Restart\". \"\"\" md\"\"\" bind restart dens Button \"Restart\" bind update dens Button \"Update\" \"\"\" begin restart dens j 1 I need to use array here because otherwise Pluto complains that there are multiple definitions of j dist zeros size ss.states dist 1 1. df DataFrame ss.states df.Ï€ dist end begin update dens j 1 j 1 1 df.Ï€ df.Ï€' Q star 1 ' print j 1 , \" iterations\" chain df begin data mapping k, Ï€, color z nonnumeric visual Lines draw end end md\"\"\" Aggregate outcomes \"\"\" md\"\"\" The function below computes aggregate consumption, aggregate assets etc. Since we assume that there is a probability mass 1 of households, computing the aggregate variables means computing the average over the state space weighted by the stationary distribution of households. \"\"\" function aggregates results chain results begin stack Not Ï€ groupby variable combine aggregate sum value, weights Ï€ zip .variable, .aggregate Dict end end agg aggregates results md\"\"\" Interactive results \"\"\" md\"\"\" Risk aversion coefficient \\sigma \"\"\" bind Ïƒ slider Slider 1. 0.25 3., show value true, default 2. md\"\"\" Discount factor \\beta \"\"\" bind Î² slider Slider 0.95 0.005 0.97, show value true, default 0.96 begin hh slider Household Ïƒ Ïƒ slider, Î² Î² slider ddp slider setup DDP hh slider, ss, prices results slider solve details ddp slider, ss.states, ss.policies solver PFI end md\"\"\" Aggregate savings round mean results slider.k, weights results slider.Ï€ , digits 3 \"\"\" begin fg chain results slider begin stack Not k, z data mapping k \"current assets k\", value, layout variable, color z nonnumeric, visual Lines draw facet linkyaxes false, , legend position top, titleposition left end ax content fg.figure 2,2 ablines ax, 0, 1, color gray, linestyle dash, loose fg end md\"\"\" Huggett equilibrium \"\"\" md\"\"\" Setup To compute the Huggett equilibrium, we need a function that computes the amount of excess savings in the economy for a given interest rate r . \"\"\" function excess savings hh, statespace, r w, Î”r ddp setup DDP hh, statespace, w, q q r , Î”r Î”r results solve details ddp, statespace.states, statespace.policies, solver PFI return Î¶ mean results.k, weights results.Ï€ end Î¶ r excess savings hh, ss, r, w prices.w, Î”r prices.Î”r md\"\"\" Finding the equilibrium In the Huggett equilribium, the equilibrium interest rate is the interest rate at which the excess savings \\zeta r are zero. To find this interest rate, we use the so called bisection algorithm. \"\"\" md\"\"\" Initial interval for interest rate As a first step, we need to find an interval so that excess savings are positive at one endpoint and negative at the other endpoint. Left endpoint r l bind left NumberField 0.00 0.01 0.04, 0.01 Right endpoint r r bind right NumberField 0.01 0.01 0.04, 0.03 \"\"\" md\"\"\" Excess savings at left endpoint ``\\zeta r l `` round excess savings hh, ss, left prices.w, prices.Î”r , digits 4 right endpoint ``\\zeta r r `` round excess savings hh, ss, right prices.w, prices.Î”r , digits 4 \"\"\" md\"\"\" If you have found such an interval, you can be sure that the excess savings function \\zeta r crosses zero at least once in this interval. This means that we can start the bisection algorithm now. Bisection algorithm One step of the bisection algorithm works as follows compute the midpoint r m 1 2 r l r d if the sign of \\zeta r m is different from the sign of \\zeta r l use the midpoint r m as the right endpoint of the new interval and leave the left endpoint unchanged if the sign of \\zeta r m is different from the sign of \\zeta r r use the midpoint r m as the left endpoint of the new interval and leave the right endpoint unchanged bind start Button \"Restart bisection\" bind go Button \"Bisect the interval\" \"\"\" begin start left vec left right vec right Î¶ left vec Î¶ left Î¶ right vec Î¶ right if Î¶ left vec end Î¶ right vec end 0. throw DomainError left, right , \"Function has the same sign at the left endpoint and at the right endpoint\" end end begin go mid left vec end right vec end 2 Î¶ mid Î¶ mid if Î¶ left vec end Î¶ mid 0. push left vec, left vec end push Î¶ left vec, Î¶ left vec end push right vec, mid push Î¶ right vec, Î¶ mid elseif Î¶ right vec end Î¶ mid 0. push left vec, mid push Î¶ left vec, Î¶ mid push right vec, right vec end push Î¶ right vec, Î¶ right vec end else throw DomainError left, right , \"Function has the same sign at the left endpoint and at the right endpoint\" end info left vec end , right vec end f Figure ax1 Axis f 1, 1 , xlabel \"interest rate r\", ylabel \"excess savings Î¶\" scatter ax1, left vec, Î¶ left vec scatter ax1, right vec, Î¶ right vec vspan ax1, left vec end , right vec end , ymin 1., y max 1., color grey, 0.2 r vec vcat left vec, reverse right vec Î¶ vec vcat Î¶ left vec, reverse Î¶ right vec lines ax1, r vec, Î¶ vec, color \"black\" xlabel ax1, \"excess savings Î¶\" ylabel ax1, \"interest rate r\" current figure end md\"\"\" Aiyagari equilibrium \"\"\" md\"\"\" Setup \"\"\" md\"\"\" The production function is F K, N A K^\\alpha N^ 1 \\alpha where K is the capital stock and N is labor. \"\"\" function production f, K return f.A K ^ f.Î± f.N ^ 1 f.Î± end md\"\"\" The function below creates a named tuple with all parameters that describe the technology of the firm. \"\"\" function Firm A 1, N 1, Î± 0.33, Î´ 0.05 A, N, Î±, Î´ end md\"\"\" From the first order conditions we can derive three functions that will be useful later on the capital demand function and its inverse ```K to r``` a function that computes the wage that is associated with the given interest rate \"\"\" function capital demand f, r K f.Î± f.A r f.Î´ ^ 1 1 f.Î± f.N return K end function K to r f, K Compute the interest rate that is associated with the given demand for capital return f.A f.Î± f.N K ^ 1 f.Î± f.Î´ end function r to w f, r Compute the wage that is associated with the given interest rate return f.A 1 f.Î± f.A f.Î± r f.Î´ ^ f.Î± 1 f.Î± end md\"\"\" Model parameters \"\"\" firm Firm md\"\"\" For the household problem, we choose other model parameters than in the Huggett model. Moreover, we use less grid points for assets to make sure that the calibration of \\beta does not take too much time. \"\"\" hh2 Household Î² 0.96, u log ss2 statespace k vals range 1e 10, 20.0, length 100 , z chain MarkovChain 0.9 0.1 0.1 0.9 , 0.1 1.0 md\"\"\" Finding the equilibrium \"\"\" md\"\"\" First, we have a look at the capital demand and supply curves \"\"\" function capital supply hh, f, statespace, r w r to w f, r ddp setup DDP hh, statespace, w, q q r , Î”r 0.0 results solve details ddp, statespace.states, statespace.policies, solver PFI return K mean results.k, weights results.Ï€ end begin r vals supply range 0.001, 0.04, length 20 k vals capital supply. Ref hh2 , Ref firm , Ref ss2 , r vals supply r vals demand K to r. Ref firm , k vals end let fig Figure ax fig 1, 1 Axis fig, xlabel \"capital\", ylabel \"interest rate\" lines k vals, r vals demand, label \"demand\" lines k vals, r vals supply, label \"supply\" axislegend fig end function excess demand hh, f, statespace, r supply capital supply hh, f, statespace, r demand capital demand f, r return demand supply end begin initial bracket 0.005, 0.055 r eq find zero r excess demand hh2, firm, ss2, r , initial bracket, Brent k eq capital demand firm, r eq r eq, k eq end md\"\"\" To determine the exact equilibrium interest rate, we apply a root finding algorithm to a function that computes excess demand for capital for a given interest rate. We could of course use the bisection algorithm that we have used to compute the Huggett equilibrium above. But to make sure that the code is fast enough, we take the Brent algorithm https en.wikipedia.org wiki Brent%27s method which is implemented in the ```Roots.jl``` package. Since the household's decision problem needs to be solved for a different value of the interest rate at each step of the algorithm, finding the equilibrium can be time consuming, especially in more complicated models. The resulting equilibrium interest rate is round r eq, digits 4 and the associated capital stock is round k eq, digits 3 . \"\"\" wto target 3.63 md\" Calibrating the discount factor \\beta Now, let's choose the discount factor \\beta such that the wealth to output ratio K F K,N matches the US value of round wto target, digits 3 Auclert and Rognlie, 'Inequality and Aggregate Demand', Appendix B . We can achieve this by minimizing the objective function O \\beta \\left \\frac K \\beta F K \\beta ,N 3.63\\right ^2 where K \\beta denotes the equilibrium capital stock in the Aiyagari model that is associated with a given discount factor \\beta . \" function wealth to output ratio Î², u, firm, statespace, initial bracket hh Î² Household Î² Î², u u r eq find zero r excess demand hh Î², firm, statespace, r , initial bracket, Brent , atol 1e 5, rtol 1e 5, xatol 1e 5, xrtol 1e 5 k eq capital demand firm, r eq return k eq production firm, k eq end wealth to output ratio 0.96, hh2.u, firm, ss2, initial bracket begin Î² vals 0.945 0.005 0.965 wto vals wealth to output ratio Î², hh2.u, firm, ss2, initial bracket for Î² in Î² vals obj vals wto vals . wto target .^ 2 end lines Î² vals, obj vals, axis xlabel L\"discount factor Î² \", ylabel \"value of the objective function\" Î² cal find zero Î² wealth to output ratio Î², hh2.u, firm, ss2, initial bracket wto target, 0.945, 0.965 , Brent , atol 1e 5, rtol 1e 5, xatol 1e 5, xrtol 1e 5 md\"\"\" Appendix \"\"\" TableOfContents md\"\"\" Acknowledgements This notebook has been dramatically improved by Daniel Schmidt https github.com danieljschmidt . \"\"\" "},{"url":"preliminaries/lifecycle/","title":"Lifecycle models","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 2 section 4 order 4 title \"Lifecycle models\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils using QuantEcon using Chain, DataFrameMacros, DataFrames using CairoMakie using AlgebraOfGraphics draw using StatsBase using StatsBase weights using AlgebraOfGraphics using AlgebraOfGraphics density using AoGExtensions using LinearAlgebra using LightGraphs using PlutoUI TableOfContents md\"\"\" danger \"Under construction \" This notebook is not ready for public consumption. Use at your own risk. \"\"\" md\"\"\" `lifecycle.jl` | Version 0.1 | last updated Apr 13 2022 \"\"\" md\"\"\" Lifecycle models The setup should be basically identical to the one in `aiyagari.jl`, except that demographic structure is changed. We'll cover the case of finite lifetime and perpetual youth. \"\"\" md\"\"\" Setup \"\"\" function statespace a vals range 1e 10, 20.0, length 200 , z chain states a, z for a âˆˆ a vals, z âˆˆ z chain.state values | vec states indices a i, z i for a i âˆˆ 1 length a vals , z i âˆˆ 1 length z chain.state values | vec policies a next for a next âˆˆ a vals | vec policies indices a next i for a next i âˆˆ 1 length a vals | vec states, states indices, policies, policies indices, z chain end function Household Ïƒ 1.0, Î² 0.96, m 0.0, u Ïƒ 1 ? log x x^ 1 Ïƒ 1 1 Ïƒ Î², u, m end function setup Q Q, states indices, policies indices, z chain for i next state, next âˆˆ enumerate states indices for i policy, a next i âˆˆ enumerate policies indices for i state, z i âˆˆ enumerate states indices if next.a i a next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end function consumption z, a , a next , q, w, Î”r if a next 0 && Î”r 0 r 1 q 1 a next 0 Î”r q 1 1 r end c w z a q a next c, a next end function reward etc state, policy, prices, u c, a next consumption state, policy, prices if c 0 reward u c else reward 100 000 100 c end reward, c end function setup R etc R, etc, states, policies, prices, u for i policy, policy âˆˆ enumerate policies for i state, state âˆˆ enumerate states out reward etc state, policy, prices, u R i state, i policy out.reward etc i state, i policy out... end end return nothing end function setup R etc states, policies, prices, u proto reward etc first states , first policies , prices, u T typeof proto etc Array T undef, length states , length policies R zeros length states , length policies setup R etc R, etc, states, policies, prices, u R, etc end md\"\"\" State space \"\"\" r guess hh, scale 0.9 1 hh.Î² 1 hh.m scale q r 1 1 r r from q q 1 q 1 md\"\"\" Solve Households' problem \"\"\" md\"\"\" Infinite lifetime vs finite lifetime vs perpetual youth \"\"\" md\"\"\" Finite lifetime \"\"\" J 40 Create an instance of Household hh Household m 1 J r r guess hh, 0.8 prices q q r , w 1.0, Î”r r 2 function simulate J ddp, J, v term, states, policies , other policies, Ï€â‚€ vs, sigmas backward induction ddp, J, v term initial distribution Ï€ copy Ï€â‚€ initialize DataFrame to store the results dfs DataFrame for j âˆˆ 1 J Ïƒ sigmas , j R Ïƒ, Q Ïƒ RQ sigma ddp, Ïƒ op DataFrame other policies i, s for i, s âˆˆ enumerate Ïƒ df DataFrame states DataFrame policies Ïƒ op df.j . j df.Ï€ vec Ï€ Ï€ Ï€ Q Ïƒ Q initial distribution push dfs, df end vcat dfs... end md\"\"\" Perpetual youth \"\"\" function simulate ddp, J, states, policies , other policies, Ï€â‚€, solver PFI results QuantEcon.solve ddp, solver Ïƒ results.sigma R Ïƒ, Q Ïƒ RQ sigma ddp, Ïƒ op DataFrame other policies i, s for i, s âˆˆ enumerate Ïƒ df0 DataFrame states DataFrame policies Ïƒ op initial distribution Ï€ copy Ï€â‚€ initialize DataFrame to store the results dfs DataFrame for j âˆˆ 1 J df copy df0 df.j . j df.Ï€ vec Ï€ Ï€ Ï€ Q Ïƒ Q initial distribution push dfs, df end vcat dfs... end md\"\"\" Evolution of assets over age \"\"\" â• â•â•¡ chain df big begin data mapping j, a, weights Ï€ visual Violin draw end â• â•â•¡ Îµ 0.1 z chain MarkovChain 1 Îµ Îµ Îµ 1 Îµ , 1.25, 0.75 function setup DDP household, statespace, prices Î², m, u household states, policies, states indices, policies indices statespace Rewards and policies R, etc setup R etc states, policies, prices, u Transition function Q setup Q states indices, policies indices, z chain ddp DiscreteDP R, Q, Î² 1 m ddp, R, etc end ss statespace a vals range 2, 2.0, length 200 , z chain Use the instance to build a discrete dynamic program am ddp, etc let ddp, etc setup DDP hh, ss, prices am ddp ddp, etc end v term map ss.states do a, z a â‰¥ 0 ? 0 100 000 a end initial distribution let i 0 findfirst DataFrame ss.states .a . 0 Ï€â‚€ map ss.states indices do a i a i i 0 ? 1.0 0.0 end Ï€â‚€ sum Ï€â‚€ end df big simulate J am ddp, J, v term, ss, etc, initial distribution' chain df big begin stack a, a next, c , j, Ï€ groupby j, variable combine value mean value, weights Ï€ data mapping j, value, layout variable visual ScatterLines draw facet linkyaxes false, end chain df big begin data mapping a, weights Ï€ density histogram draw end chain df big begin stack a, a next, c , j, Ï€, z groupby j, variable data mapping j, value, weights Ï€, color z nonnumeric, layout variable quantileband draw facet linkyaxes false, end df big2 simulate am ddp, J, ss, etc, initial distribution' chain df big2 begin stack a, a next, c , j, Ï€ groupby j, variable combine value mean value, weights Ï€ data mapping j, value, layout variable visual ScatterLines draw facet linkyaxes false, end chain df big2 begin stack a, a next, c , j, Ï€, z groupby j, variable data mapping j, value, weights Ï€, color z nonnumeric, layout variable quantileband draw facet linkyaxes false, end chain df big begin combine a mean a, weights Ï€ , a next mean a next, weights Ï€ , end chain df big2 begin combine a mean a, weights Ï€ , a next mean a next, weights Ï€ , end md\"\"\" Perpetual youth \"\"\" md\"\"\" constant death probability ``m`` \"\"\" m 1 45 hh perp youth Household m md\"\"\" Appendix \"\"\" md\"\"\" Stationary distribution \"\"\" begin abstract type StatDistSolver end struct Eigen StatDistSolver end struct GTH StatDistSolver end struct Iterate StatDistSolver end end function stationary distribution mc MarkovChain, solver StatDistSolver GTH kwargs... stationary distribution mc.p, solver kwargs... end function stationary distribution Q AbstractMatrix, m, solver kwargs... QÌƒ 1 m Q m I stationary distribution QÌƒ, solver kwargs... end function stationary distribution Q AbstractMatrix, m, Ï€â‚€, Ï€ m Ï€â‚€ I 1 m Q Ï€' end function stationary distribution Q AbstractMatrix, m, Ï€â‚€, Iterate maxit 400, Ï€ guess Ï€â‚€, rtol âˆšeps Ï€ copy Ï€ guess for i in 1 maxit Ï€ new 1 m Ï€ Q m Ï€â‚€ if isapprox Ï€ new, Ï€ rtol info \"Converged after i iterations\" return Ï€ new' end if i maxit warn \"Didn't converge after i iterations\" return Ï€ new' end Ï€ . Ï€ new end nothing end function stationary distribution Q AbstractMatrix, GTH this essentially copies the implementation of QuantEcon.jl n size Q, 1 Ï€ zeros n ids only attracting components DiGraph Q Ï€ ids . gth solve Q ids,ids Ï€ end function stationary distribution Q AbstractMatrix, Iterate rtol âˆšeps , maxit 400 Qn copy Q for i in 1 maxit Qn new Qn Q if isapprox Qn new, Qn rtol info \"Converged after i iterations\" break end if i maxit warn \"Didn't converge after i iterations\" end Qn . Qn new end Qn 1, end function real if real x assert isreal x real x end function stationary distribution Q AbstractMatrix, Eigen values, vectors eigen Q' find unit eigenvalue i only findall values .â‰ˆ 1.0 get corresponding eigenvector Ï€ vectors , i make sure it isn't complex, normalize sum to 1 Ï€ real if real Ï€ Ï€ . Ï€ sum Ï€ end function solve details0 ddp, states, policies , other policies m, Ï€â‚€, solver PFI results QuantEcon.solve ddp, solver op DataFrame other policies i, s for i, s âˆˆ enumerate results.sigma df hcat DataFrame states , DataFrame policies results.sigma , op, makeunique true df.value results.v df.state states df.policy policies results.sigma df.additional policies other policies results.sigma df.Ï€ stationary distribution results.mc.p, m, Ï€â‚€, GTH df, results df end function solve details ddp, statespaces, etc m, Ï€â‚€, solver PFI df solve details0 ddp, statespaces, etc m, Ï€â‚€, solver chain df begin select Not state, policy, additional policies end end Solve using policy function iteration results df solve details am ddp, ss, etc hh.m, Ï€â‚€ initial distribution', solver PFI chain results df begin combine a mean a, weights Ï€ , a next mean a next, weights Ï€ , end chain results df begin groupby a combine Ï€ sum Ï€ data mapping a, Ï€ visual Lines draw end let ddp setup DDP hh perp youth, ss, prices assert ddp.beta hh perp youth.Î² 1 hh perp youth.m m hh perp youth results QuantEcon.solve ddp, PFI Ïƒ results.sigma R Ïƒ, Q Ïƒ RQ sigma ddp, Ïƒ QÌƒ 1 m Q Ïƒ m I mc aux MarkovChain copy QÌƒ Ï€ only stationary distributions mc aux assert Ï€ â‰ˆ stationary distribution QÌƒ, Eigen assert Ï€ â‰ˆ stationary distribution QÌƒ, GTH assert Ï€ â‰ˆ stationary distribution QÌƒ, Iterate , rtol eps ^ 3 4 assert Ï€ â‰ˆ stationary distribution Q Ïƒ, m, Eigen assert Ï€ â‰ˆ stationary distribution Q Ïƒ, m, Ï€', GTH assert Ï€ â‰ˆ stationary distribution Q Ïƒ, m, Ï€', Iterate Ï€ guess fill 1 400, 1, 400 , rtol eps ^ 3 4 end md\"\"\" Misc \"\"\" TableOfContents "},{"url":"preliminaries/rbc-to-imrohoroglu/","title":"RBC & Imrohoroglu (1989) as Markov Chains","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 2 section 2 order 2 title \"RBC & Imrohoroglu 1989 as Markov Chains\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using SparseArrays using QuantEcon using Chain, DataFrameMacros using CairoMakie using AlgebraOfGraphics using AlgebraOfGraphics draw using StatsBase using PlutoUI using PlutoUI Slider using DataFrames using LaTeXStrings md\"\"\" `rbc to imrohoroglu.jl` | Version 0.1 | last updated May 2 2023 \"\"\" md\"\"\" Introduction \"\"\" md\"\"\" 1. Recap Finite State Markov Chains \"\"\" â• â•â•¡ mc MarkovChain 0.5 0.1 0.4 0.1 0.4 0.5 0.3 0.3 0.4 , \"unemployed\", \"employed\", \"other\" â• â•â•¡ mc tauchen 20, 0.9, 1.0 simulate mc, 10 N length mc.state values I 1000 T 10 sim df mapreduce vcat, 1 I do i DataFrame i, t 1 T, state simulate mc, T end md\"\"\" Tracking individuals \"\"\" chain sim df begin subset i 4 subset i % 50 0 data mapping t L\"time t \", state \"state e.g. income \", color i nonnumeric visual ScatterLines mapping t naive visual VLines draw axis title \"Sample paths of selected agents\", end blue Makie.wong colors 1 md\"\"\" Tracking the whole distribution \"\"\" md\"\"\" ... in a naive way \"\"\" bind t naive Slider 1 10, default 1, show value true chain sim df begin aside begin bins sort unique .state end subset t t naive data mapping state visual Hist bins, color blue, normalization probability draw end let fig Figure chain sim df begin subset t % 10 1 aside begin xtick labels string. sort unique .t xticks collect 1 length xtick labels , xtick labels xlabel L\"time t \" ylabel \"cross sectional distribution\" axis xticks, xlabel, ylabel bins sort unique sim df.state end data mapping state, color t t naive , nonnumeric, offset t nonnumeric visual Hist bins, direction x, normalization probability, scale to 0.6 draw fig 1,1 , axis end fig end md\"\"\" ... in a more sophisticated way assuming a continuum of agents \"\"\" Ï€â‚€ fill 1 N, N initial distribution bind t soph Slider 0 100, default 0, show value true barplot mc.state values, vec Ï€â‚€' mc.p^ t soph , axis title latexstring \"Cross sectional distribution at \\ t t soph \\ \" let fig Figure ax Axis fig 1,1 , xlabel L\"time t \", ylabel \"cross sectional distribution\" for t âˆˆ 0 10 barplot ax, mc.state values, vec Ï€â‚€' mc.p^t . 4, direction x, offset t, color t t soph ? Makie.wong colors 1 gray40 end fig end md\"\"\" 2. The RBC Model A Sample Path of a Markov Chain \"\"\" md\"\"\" Set up the Dynamic Program \"\"\" z chain MarkovChain 0.75 0.25 0.25 0.75 , 1.25, 0.75 r 0.02 q r 1 1 r prices q q r , w 1.0, Î”r r 2 md\"\"\" Solution is a Markov Chain \"\"\" md\"\"\" 3. Bewley Huggett Aiyagari Tracking the Distribution of a Markov Chain warning \"Note\" We are not solving for the equilibrium interest rate ``r`` here. So we are in Partial Equilibrium setting of Imrohoroglu 1989 . \"\"\" md\"\"\" Specify initial distribution \"\"\" bind t soph ddp Slider 0 100, default 0, show value true md\"\"\" Appendix \"\"\" function Household Ïƒ 1.0, Î² 0.96, u Ïƒ 1 ? log x x^ 1 Ïƒ 1 1 Ïƒ Î², u end hh Household Ïƒ 2.0, Î² 0.96 function statespace k vals range 1e 10, 20.0, length 200 , z chain states k, z for k âˆˆ k vals, z âˆˆ z chain.state values | vec states indices k i, z i for k i âˆˆ 1 length k vals , z i âˆˆ 1 length z chain.state values | vec policies k next for k next âˆˆ k vals | vec policies indices k next i for k next i âˆˆ 1 length k vals | vec states, states indices, policies, policies indices, z chain end ss statespace k vals range 1., 5., length 200 , z chain states DataFrame ss.states policies DataFrame ss.policies N ddp length ss.states Ï€â‚€ ddp fill 1 N ddp, N ddp function setup Q Q, states indices, policies indices, z chain for i next state, next âˆˆ enumerate states indices for i policy, k next i âˆˆ enumerate policies indices for i state, z i âˆˆ enumerate states indices if next.k i k next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end function consumption z, k , k next , q, w, Î”r if k next 0 && Î”r 0 r 1 q 1 k next 0 Î”r q 1 1 r end c w z k q k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, policies, prices, u for k i, policy âˆˆ enumerate policies for s i, state âˆˆ enumerate states R s i, k i reward state, policy, prices, u end end return R end function setup R states, policies, prices, u R zeros length states , length policies setup R R, states, policies, prices, u end function setup DDP household, statespace, prices Î², u household states, policies, states indices, policies indices statespace R setup R states, policies, prices, u Q setup Q states indices, policies indices, z chain DiscreteDP R, Q, Î² end ddp setup DDP hh, ss, prices results QuantEcon.solve ddp, PFI mc ddp results.mc mc ddp.p | sparse path0 simulate mc ddp, 100 let fig Figure resolution 800, 400 path DataFrame ss.states path0 lines fig 1,1 , path.k, axis title \"evolution of capital\", xlabel \"time\" lines fig 1,2 , path.z, axis title \"evolution of productivity\", xlabel \"time\" fig end barplot mc.state values, vec Ï€â‚€ ddp' mc ddp.p^ t soph ddp , axis title latexstring \"Cross sectional distribution at \\ t t soph ddp \\ \" let fig Figure ax Axis fig 1,1 , xlabel L\"time t \", ylabel \"cross sectional distribution\" for t âˆˆ 0 10 barplot ax, mc.state values, vec Ï€â‚€ ddp' mc ddp.p^t . 70, direction x, offset t, color t t soph ddp ? Makie.wong colors 1 gray40 end fig end function solve details0 ddp, states, policies solver PFI results QuantEcon.solve ddp, solver df DataFrame states DataFrame policies results.sigma df.state states df.policy policies results.sigma df.Ï€ stationary distributions results.mc , 1 1 df end function solve details ddp, states, policies solver PFI df solve details0 ddp, states, policies solver chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end end md\"\"\" Packages \"\"\" TableOfContents "}]