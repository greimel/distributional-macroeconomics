[{"url":"cheatsheets/","title":"Cheatsheets","tags":["welcome"],"text":"Cheatsheets Getting Started with Julia - live . Fastrack to Julia  cheatsheet. MATLAB-Julia-Python comparative cheatsheet  by  QuantEcon group Plots.jl cheatsheet"},{"url":".","title":"Welcome","tags":["homepage"],"text":"Topics in Distributional Macroeconomics This website hosts some of the material for the PhD-level course  Topics in Distributional Macroeconomics  at the Tinbergen Institute Amsterdam. The corresponding Github repository is  here . The first edition of the course was in Spring 2022. Nevertheless, much of the material is unfinished. Acknowledgement \nThe design of this website is based on  Computational Thinking , a live online Julia/Pluto textbook. (computationalthinking.mit.edu) Build your own course website using https://github.com/greimel/pluto-course-template"},{"url":"installation/","title":"Software installation","tags":["welcome"],"text":"First-time setup: Install Julia & Pluto Video version: Text and pictures version: Step 1: Install Julia  1.8.2 Go to  https://julialang.org/downloads  and download the current stable release, Julia  1.8.2 , using the correct version for your operating system (Linux x86, Mac, Windows, etc). Step 2: Run Julia After installing,  make sure that you can run Julia . On some systems, this means searching for the “Julia  1.8.2 ” program installed on your computer; in others, it means running the command  julia  in a terminal. Make sure that you can execute  1 + 1 : Make sure that you are able to launch Julia and calculate  1+1  before proceeding! Step 3: Install  Pluto Next we will install the  Pluto , the notebook environment that we will be using during the course. Pluto is a Julia  programming environment  designed for interactivity and quick experiments. Open the  Julia REPL . This is the command-line interface to Julia, similar to the previous screenshot. Here you type  Julia commands , and when you press ENTER, it runs, and you see the result. To install Pluto, we want to run a  package manager command . To switch from  Julia  mode to  Pkg  mode, type  ]  (closing square bracket) at the  julia>  prompt: \njulia> ]\n\n(@v 1.8 ) pkg>\n The line turns blue and the prompt changes to  pkg> , telling you that you are now in  package manager mode . This mode allows you to do operations on  packages  (also called libraries). To install Pluto, run the following (case sensitive) command to  add  (install) the package to your system by downloading it from the internet.\nYou should only need to do this  once  for each installation of Julia: \n(@v 1.8 ) pkg> add Pluto\n This might take a couple of minutes, so you can go get yourself a cup of tea! You can now close the terminal. Step 4: Use a modern browser: Mozilla Firefox or Google Chrome We need a modern browser to view Pluto notebooks with. Firefox and Chrome work best. Second time:  Running Pluto & opening a notebook Repeat the following steps whenever you want to work on a project or homework assignment. Step 1: Start Pluto Start the Julia REPL, like you did during the setup. In the REPL, type: julia> using Pluto\n\njulia> Pluto.run()\n The terminal tells us to go to  http://localhost:1234/  (or a similar URL). Let’s open Firefox or Chrome and type that into the address bar. If you’re curious about what a  Pluto notebook  looks like, have a look at the  Featured Notebooks . These notebooks are useful for learning some basics of Julia programming. If you want to hear the story behind Pluto, have a look a the  JuliaCon presentation . If nothing happens in the browser the first time, close Julia and try again. And please let us know! Step 2a: Opening a notebook from the web This is the main menu - here you can create new notebooks, or open existing ones. Our homework assignments will always be based on a  template notebook , available in this GitHub repository. To start from a template notebook on the web, you can  paste the URL into the blue box  and press ENTER. For example, homework 0 is available  here . Go to this page, and on the top right, click on the button that says “Edit or run this notebook”. From these instructions, copy the notebook link, and paste it into the box. Press ENTER, and select OK in the confirmation box. The first thing we will want to do is to save the notebook somewhere on our own computer; see below. Step 2b: Opening an existing notebook file When you launch Pluto for the second time, your recent notebooks will appear in the main menu. You can click on them to continue where you left off. If you want to run a local notebook file that you have not opened before, then you need to enter its  full path  into the blue box in the main menu. More on finding full paths in step 3. Step 3: Saving a notebook We first need a folder to save our homework in. Open your file explorer and create one. Next, we need to know the  absolute path  of that folder. Here’s how you do that in  Windows ,  MacOS  and  Ubuntu . For example, you might have: C:\\Users\\fons\\Documents\\18S191_assignments\\  on Windows /Users/fons/Documents/18S191_assignments/  on MacOS /home/fons/Documents/18S191_assignments/  on Ubuntu Now that we know the absolute path, go back to your Pluto notebook, and at the top of the page, click on  “Save notebook…” . This is where you type the  new path+filename for your notebook : Click  Choose . Step 4: Sharing a notebook After working on your notebook (your code is autosaved when you run it), you will find your notebook file in the folder we created in step 3. This the file that you can share with others, or submit as your homework assignment to Canvas. \nconst run = f => f();\nrun(async () => {\nconst versions = await (await fetch(`https://julialang-s3.julialang.org/bin/versions.json`)).json()\nconst version_names = Object.keys(versions).sort().reverse()\nconst stable = version_names.find(v => versions[v].stable)\nconsole.log({stable})\nconst pkg_stable = /\\d+\\.\\d+/.exec(stable)[0]\ndocument.querySelectorAll(\"auto-julia-version\").forEach(el => {\n    console.log(el)\n    el.innerText = el.getAttribute(\"short\") == null ? stable : pkg_stable\n})\n});"},{"url":"search/","title":"Search results","tags":[],"text":"window.init_search(); Search Results \nLoading..."},{"url":"sidebar data/","title":"sidebar data","tags":[],"text":"Dict main \"welcome\" collections \"welcome\" .pages, \"Julia basics\" collections \"julia basics\" .pages, \"Preliminaries\" collections \"preliminaries\" .pages, \"Housing\" collections \"housing\" .pages, \"Long run\" collections \"long run\" .pages, \"Continuous time\" collections \"continuous time\" .pages, \"Assignments and Tutorials\" collections \"assignments\" .pages, \"Unfinished notebooks\" collections \"unfinished\" .pages, , about Dict authors name \"Fabian Greimel\", url \"https www.greimel.eu\" , name \"Enrico Perotti\", url \"https www.enricoperotti.eu\" , title \"Topics in Distributional Macroeconomics\", subtitle \"PhD level Elective Course\", term \"Spring 2024\", institution \"Tinbergen Institute\", institution url \"http www.tinbergen.nl\", institution logo \"tinbergen institute logo.svg\", institution logo darkmode \"tinbergen logo white.svg\" "},{"url":"syllabus/","title":"Syllabus","tags":["welcome"],"text":"Syllabus Course Links official Canvas course page Class schedule Lecture Title Date Lecturer Notebooks Reading 1A Network Basics 1 Feb  7, 2022 Cees basic Julia ,  first networks Jackson Ch. 1 & 2 1B Network Basics 2 Feb 10, 2022 Cees coauthor network ,  power law ,  exercises Jackson Ch. 3 1C Random Networks Feb 11, 2022 Cees notebook Jackson Ch. 4–6 & 11 2A Tutorial 1: Twitter Feb 14, 2022 Cees notebook 2B Learning on Networks Feb 17, 2022 Cees notebook Jackson Ch. 8 2C Disease Transmission Feb 18, 2022 Cees notebook 3A no lecture Feb 21, 2022 3B Financial networks 1 Feb 24, 2022 Fabian notebook Allen & Gale (2000) 3C Financial networks 2 Feb 25, 2022 Fabian notebook Acemoglu et al. (2015) 4A Tutorial 2: SIR Feb 28, 2022 Cees notebook 4B Social Connectedness Mar  3, 2022 Fabian notebook Bailey et al. (2018) 4C Network Games Mar  4, 2022 Fabian Jackson Ch. 9 5A Tutorial 3: Financial stability Mar  7, 2022 Fabian notebook 5B Production networks 1 Mar 10, 2022 Fabian notebook Carvalho (2014) ,  Long & Plosser (1982) 5C Production networks 2 Mar 11, 2022 Fabian notebook Carvalho (2014) ,  Acemoglu et al. (2012) 6A Econometrics Mar 14, 2022 Cees 6B Tutorial 4: SCI Mar 17, 2022 Fabian 6C Tutorial 5: Covid Crisis Mar 18, 2022 Fabian"},{"url":"continuous-time/continuous-time-comparison/","title":"Comparing different solution methods","tags":["continuous-time"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 6 section 3 order 3 title \"Comparing different solution methods\" layout \"layout.jlhtml\" tags \"continuous time\" description \"\" using Markdown using InteractiveUtils using EconPDEs using PlutoTest using DataFrameMacros using InfinitesimalGenerators using QuantEcon gth solve using Arpack using StructArrays using PlutoUI using AlgebraOfGraphics, CairoMakie using LinearAlgebra using SparseArrays using DataFrames using Chain chain using Roots find zero, Brent using MarkdownLiteral markdown using HypertextLiteral md\"\"\" `continuous time comparison.jl` | Version 1.0 | last updated May 31, 2023 | \"\"\" markdown \"\"\" Huggett model in continuous time In this notebook, we consider a Huggett economy in continuous time. Income is a htl \" s Poisson process s \" continuous time Markov Chain with two states. We compare the implementation of Achdou et al 2021 algorithm described in their online appendix https benjaminmoll.com wp content uploads 2020 02 HACT Numerical Appendix.pdf , code follows the Matlab code snippets on Ben Moll's website https benjaminmoll.com codes EconPDEs.jl by Mattieu Gomez code adapted from package tests \"\"\" md\"\"\" Model \"\"\" kwdef struct Moll σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference z Matrix Float64 0.1 0.2 income state row vector λ Matrix Float64 0.02 0.03 intensities row vector asset grid parameters N a Int64 500 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1.0 Δa Float64 aₘₐₓ aₘᵢₙ N a 1 end function generator λ λ₁₂, λ₂₁ λ Λ λ₁₂ λ₁₂ λ₂₁ λ₂₁ end function construct A switch λ, N a id I N a λ₁₂, λ₂₁ λ A switch 1 hcat λ₁₂ id, λ₁₂ id A switch 2 hcat λ₂₁ id, λ₂₁ id λ₁₂ id λ₁₂ id λ₂₁ id λ₂₁ id A switch vcat A switch 1, A switch 2 end md\"\"\" We work with an equi spaced asset grid with N a grid points. The difference between two grid points is denoted by \\Delta a . Section 7 in the online appendix explains how to deal with non uniform grids. \"\"\" function construct a m N a, aₘᵢₙ, aₘₐₓ m range aₘᵢₙ, aₘₐₓ, N a asset grid column vector end m Moll md\"\"\" HJB equation implicit method \"\"\" md\"\"\" \\rho v 1 a \\max c u c v 1' a z 1 ra c \\lambda 1 v 2 a v 1 a \\rho v 2 a \\max c u c v 2' a z 2 ra c \\lambda 2 v 1 a v 2 a ```math \\rho \\pmatrix v 1 a \\\\ v 2 a \\pmatrix u c^ 1 a \\\\ u c^ 2 a \\pmatrix v' 1 a z 1 ra c 1^ a \\\\ v' 1 a z 1 ra c 2^ a \\pmatrix \\lambda 1 & \\lambda 1 \\\\ \\lambda 2 & \\lambda 2 \\pmatrix v 1 a \\\\ v 2 a ``` \"\"\" md\"\"\" Algorithm Notation v i,j is short hand notation for v j a i . Start with an initial guess for the value function v i,j ^0 . A natural choice is v i,j ^0 \\frac u z j ra i \\rho . For i 1, ... maxit 1 Approximate v i,j ^n ' , j 1,2 using a finite difference method Notation Superscript n is omitted. forward difference v i,j,F ' \\frac v i 1,j v i,j \\Delta a backward diffrence v i,j,B ' \\frac v i,j v i 1,j \\Delta a The state constraint a \\ge a \\text min needs to be enforced by setting v' 1,j,B u' z j ra \\text min . savings according to forward difference s i,j,F z j ra i u' ^ 1 v' i,j,F savings according to backward difference s i,j,B z j ra i u' ^ 1 v' i,j,B The finite difference approximation of v i,j ^n ' is v' i,j v' i,j,F 1 s i,j,F 0 v' i,j,B 1 s i,j,B 0 \\bar v i,j 1 s i,j,F \\le 0 \\le s i,j,B where \\bar v i,j u' s j r a i . We assume concavity of the value function here so that the case s i,j,F 0 and s i,j,B 0 cannot occur. 2 Compute the consumption policy implied by the value function c i,j ^n u' ^ 1 v i,j ^n ' 3 Find updated value function v^ n 1 ```math \\begin align &\\frac v i,j ^ n 1 v i,j ^ n \\Delta \\rho v i,j ^ n 1 \\\\ &u c i,j ^n v i,j,F ^ n 1 ' z j ra i c i,j,F ^n ^ v i,j,B ^ n 1 ' z j ra i c i,j,B ^n ^ \\lambda j v i, j ^ n 1 v i,j ^ n 1 \\end align ``` where \\Delta is the step size. This is a system of 2N a linear equations. Since v^ n 1 is implicitly defined by the equations above, this approach is referred to as the implicit method. The system of equations can be written in matrix notation as \\frac 1 \\Delta v^ n 1 v^n \\rho v^ n 1 u^n A^n v^ n 1 The 2N a \\times 2N a matrix A^n can be written as a sum of two matrices \\bar A ^n and A \\text switch A^n \\bar A ^n A \\text switch \\begin pmatrix \\bar A 11 ^n & 0 \\\\ 0 & \\bar A 22 ^n \\end pmatrix \\begin pmatrix \\lambda 1 I & \\lambda 1 I \\\\ \\lambda 2 I & \\lambda 2 I \\end pmatrix where I is a N a \\times N a identity matrix. Since A \\text switch stays unchanged, it can be pre computed outside the for loop. The N a \\times N a submatrices \\bar A 11 ^n and \\bar A 22 ^n are tri diagonal The 1 diagonal is filled with x i,j \\frac s^n i,j,B ^ \\Delta a , i 2, \\dots N a The main diagonal is filled with y i,j \\frac s^n i,j,F ^ \\Delta a \\frac s^n i,j,B ^ \\Delta a , i 1, \\dots N a The 1 diagonal is filled with z i,j \\frac s^n i,j,F ^ \\Delta a , i 1, \\dots N a 1 Since A^n is a sparse matrix, computers can solve the system of linear equations quickly even for large N a . 4 Stop if v^ n 1 is close enough to v^n . \"\"\" md\"\"\" Solving HJB with `EconPDEs.jl` \"\"\" md\"\"\" Test from EconPDEs \"\"\" states a, z a, z function dvs v v1, v1a up, v1a down, v2, v2a up, v2a down dvf v1a up, v2a up dvb v1a down, v2a down v v1, v2 dvf, dvb, v end u prime inv x, σ x^ 1 σ u prime c, σ c^ σ u c, σ c 0 ? σ 1 ? log c c^ 1 σ 1 σ 10.0 c 100.0 ╠═╡ function clean variables nt, solname, statename, n map 1 n do i sol key Symbol solname, i up key Symbol sol key, statename, \" up\" Symbol solname, statename, \" up\" down key Symbol sol key, statename, \" down\" Symbol solname, statename, \" down\" solname nt sol key , up key 2 nt up key 1 , down key 2 nt down key 1 end | DataFrame end ╠═╡ function consumption and drift a, z , dv, r, σ dv max dv, eps 0.0 c u prime inv dv, σ ȧ z r a c c, ȧ, dv end function consumption and drift₀ a, z , r, σ ȧ zero a c z r a dv u prime c, σ c, ȧ, dv end function consumption and drift upwind state, dvf, dvb, σ, r, aₘᵢₙ, aₘₐₓ consumption and savings with forward difference dv, ȧ, c consumption and drift state, dvf, σ, r if ȧ 0 && state.a aₘₐₓ return dv, ȧf ȧ, ȧb 0.0, c, ȧ end consumption and savings with backward difference dv, ȧ, c consumption and drift state, dvb, σ, r if ȧ 0 && state.a aₘᵢₙ return dv, ȧf 0.0, ȧb ȧ, c, ȧ end consumption and derivate of value function at steady state dv, ȧ, c consumption and drift₀ state, σ, r return dv, ȧf 0.0, ȧb 0.0, c, ȧ end function optional to df optional, agrid, zgrid chain optional begin DataFrame transform a bycol collect agrid stack Not a transform i z parse Int, variable end transform variable variable 1 end 1 unstack variable, value transform z zgrid i z select Not i z rename s ȧ end end ╠═╡ test let r 0.03 M EconPDEsFast m, r elapsed residual norm, optional, agrid, zgrid solve HJB econpdes M, r end ╠═╡ md\"\"\" Check results \"\"\" md\"\"\" KF equation \"\"\" md\"\"\" 0 \\frac d da s 1 a g 1 a \\lambda 1 g 1 a \\lambda 2 g 2 a 0 \\frac d da s 2 a g 2 a \\lambda 2 g 2 a \\lambda 1 g 1 a where s j a z j ra c j a 1 \\int \\bar a ^\\infty g 1 a da \\int \\bar a ^\\infty g 2 a da Algorithm A finite difference approximation of the KF equation results into the matrix equation A^T g 0 where A is the matrix from implicit algorithm for the HJB equation. \"\"\" using QuantEcon gth solve md\"\"\" ```math \\begin align \\dot g 1 m A g t m g t \\\\ g t \\Delta g t \\approx A g t \\Delta \\\\ g t \\Delta 1 m I \\Delta A g t m g 0 \\\\ g^ 1 m I \\Delta A g^ m g 0 \\\\ I 1 m I \\Delta A g^ m g 0 \\\\ I \\frac 1 m m \\Delta A g^ g 0 \\\\ \\end align ``` \"\"\" function solve KF moll A N size A, 1 AT copy transpose A b zeros N i fix 1 b i fix .1 AT i fix, . 0.0 AT i fix,i fix 1.0 g AT\\b g . sum g end function solve KF N a, Δa , A N a an AT copy transpose A b zeros 2 N a, 1 i fix 1 b i fix .1 AT i fix, . vec hcat zeros 1, i fix 1 , 1., zeros 1,2 N a i fix try global g stacked AT\\b catch e if e isa SingularException warn \"SingularException – added noise\" global g stacked AT I √eps \\b else rethrow e end end g sum sum g stacked Δa g stacked norm g stacked . g sum assert sum g stacked norm Δa ≈ 1 g reshape g stacked norm, N a, 2 end md\"\"\" Putting everything together \"\"\" using QuantEcon gth solve function stationary distribution A δ 0.0, ψ InfinitesimalGenerators.Zeros size A, 1 δ 0 || throw ArgumentError \"δ needs to be positive\" if δ 0 g abs. δ I A' \\ δ ψ else η, g InfinitesimalGenerators.principal eigenvalue A' abs η 1e 5 || warn \"Principal Eigenvalue does not seem to be zero\" end g . sum g end function solve KF death A N size A, 1 g₀ fill 1 N, N stationary distribution A, δ 1e 14, ψ g₀ end function solve KF eigs A stationary distribution A end function solve KF iterate A, Δ, g₀ fill 1 size A,1 , size A,1 g copy g₀ B I Δ A' for i ∈ 1 50000 g new B g crit maximum abs, g new g i % 1000 0 && info crit if crit 1e 12 info \"converged after i iterations\" return g end g . g new end g end md\"\"\" Equilibrium interest rate \"\"\" md\"\"\" 0 \\int \\bar a ^\\infty ag 1 a da \\int \\bar a ^\\infty ag 2 a da S r \"\"\" initial bracket 0.01, 0.03 md\"\"\" Appendix \"\"\" md\"\"\" HJB equation explicit method \"\"\" md\"\"\" Basic dea Start with some initial guess v i,j ^0 and update v i,j ^n as follows \\frac v i,j ^ n 1 v i,j ^n \\Delta \\rho v i,j ^n u c i,j ^n v i,j ^n ' z j ra i c i,j ^n \\lambda i v i, j ^n v i,j ^n In contrast to the implicit method, we can rearrange for v i,j ^ n 1 in the equation above. The disadvantage of the explicit method is that it converges only if \\Delta is not too large. \"\"\" function solve HJB explicit m Moll, r maxit 100000, crit 1e 6 σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, Δa m da Δa construct asset grid a construct a m Λ generator m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 initial guess for value function v₀ zeros N a, 2 for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit step size for updating the value function Δ .9 da z 2 . r. aₘₐₓ for it in range 1, maxit forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 c dv upwind .^ 1 σ ȧ z . r. a c u c.^ 1 σ 1 σ HJB equation v change u dv upwind . ȧ v Λ' ρ v v switch zeros N a, 2 v switch ,2 v ,1 v switch ,1 v ,2 v change u dv upwind . ȧ ones N a,1 λ. v switch v ρ v updating the value function v . v Δ v change dist it maximum abs. v change if dist it crit return v, c, ȧ, it last it, dist end end error \"Algorithm did not converge\" end t expl elapsed solve HJB explicit m, 0.03 crit 1e 6 md\"\"\" Implicit vs. explicit method \"\"\" md\"\"\" On my computer, it takes 0.4 seconds to reach convergence with the implicit method assuming a tolerance of 10^ 6 , while it takes approximately 6 seconds with the explicit method. \"\"\" md\"\"\" Implicit method \"\"\" md\"\"\" Explicit method \"\"\" md\"\"\" Helper functions \"\"\" function results to df m v, c, ȧ, g nothing N z 2 N a, z m a construct a m df DataFrame df.a a ones 1, N z | vec df.z ones N a, 1 z | vec df.c c | vec df.ȧ ȧ | vec df.v v | vec if isnothing g df.g g | vec end df end md\"\"\" Julification of the code \"\"\" function statespace m N a, aₘᵢₙ, aₘₐₓ, z m a grid range aₘᵢₙ, aₘₐₓ, N a z grid z | vec a, z for a ∈ a grid, z ∈ z grid end function statespace inds m N a, z m N z length z i a, i z for i a ∈ 1 N a, i z ∈ 1 N z end v₀ z, a , r, σ, ρ u z r a, σ ρ begin Base. kwdef struct EconPDEsFast income process parameters zgrid Vector Float64 0.5, 1.5 Λ Matrix Float64 0.2 0.2 0.2 0.2 utility parameters σ Float64 2.0 ρ Float64 0.04 r Float64 0.03 w Float64 1.0 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1.0 an Int 500 end function EconPDEsFast m Moll, r σ m.σ, ρ m.ρ, aₘᵢₙ m.aₘᵢₙ, aₘₐₓ m.aₘₐₓ, an m.N a Λ generator m EconPDEsFast σ, ρ, r, w 1, aₘᵢₙ, aₘₐₓ, an, zgrid vec m.z , Λ end function m EconPDEsFast state NamedTuple, value NamedTuple zgrid, Λ, ρ m zs zgrid nz length zgrid a state v1, v1a up, v1a down, v2, v2a up, v2a down value T eltype value vs v1, v2 dvf v1a up, v2a up dvb v1a down, v2a down states a, z zgrid 1 , a, z zgrid 2 cs Vector T undef, nz ȧs Vector T undef, nz dvs Vector T undef, nz for i ∈ 1 2 c, ȧ, dv consumption and drift upwind states i , dvf i , dvb i , m cs i c ȧs i ȧ dvs i dv end vts ρ . vs . u. cs, Ref m . ȧs . dvs . Λ vs return v1t vts 1 , v2t vts 2 , s1 ȧs 1 , s2 ȧs 2 , c1 cs 1 , c2 cs 2 end pkgtest0 let m EconPDEsFast agrid m.amin . range 0, m.amax m.amin ^0.8, length m.an .^ 1 0.8 agrid range m.aₘᵢₙ, m.aₘₐₓ, length m.an stategrid OrderedDict a agrid yend OrderedDict Symbol v, i v₀ z, a , m for a ∈ agrid for i, z ∈ enumerate m.zgrid m, stategrid, yend end end let m, stategrid, yend pkgtest0 pdesolve m, stategrid, yend t elapsed result pdesolve m, stategrid, yend info t assert result.residual norm 1e 5 end function solve HJB econpdes M, r crit √eps , v₀ v₀ agrid M.aₘᵢₙ . range 0, M.aₘₐₓ M.aₘᵢₙ ^0.8, length M.an .^ 1 0.8 agrid range M.aₘᵢₙ, M.aₘₐₓ, M.an stategrid OrderedDict a agrid solend OrderedDict Symbol v, i v₀ z, a , M for a ∈ agrid for i, z ∈ enumerate M.zgrid residual norm, optional pdesolve M, stategrid, solend maxdist crit residual norm, optional, agrid, M.zgrid end function solve HJB econpdes m, r crit √eps , v₀ v₀ M EconPDEsFast m, r residual norm, optional, agrid, zgrid solve HJB econpdes M, r crit, v₀ df optional to df optional, agrid, zgrid df.v, df.c, df.ȧ, df, dist residual norm end abstract type Scheme end Base. kwdef struct Implicit Scheme Δ 1000 maxit 100 end begin Base. kwdef struct Explicit Scheme Δ maxit end function Explicit Δa, z, aₘₐₓ maxit 100 000 r 0.02 Δ .9 Δa maximum z r aₘₐₓ Explicit Δ, maxit end end function consumption and drift upwind vec ss, dvf, dvb, par consumption and drift upwind. ss, dvf, dvb, Ref par | StructArray end begin Base. kwdef struct EconPDEsSlow σ Float64 2.0 ρ Float64 0.05 r Float64 0.03 w Float64 1.0 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1.0 an Int 500 zgrid Vector Float64 0.1, 0.2 Λ Matrix Float64 0.02 0.02 0.03 0.03 end function EconPDEsSlow m Moll, r σ m.σ, ρ m.ρ, aₘᵢₙ m.aₘᵢₙ, aₘₐₓ m.aₘₐₓ, an m.N a Λ generator m EconPDEsSlow σ, ρ, r, w 1, aₘᵢₙ, aₘₐₓ, an, zgrid vec m.z , Λ end function M EconPDEsSlow state NamedTuple, sol NamedTuple zgrid, r, ρ, σ, Λ M dvf, dvb, v dvs v sol a state dv, c, ȧ consumption and drift upwind vec states. a, zgrid , dvf, dvb, M endo u. c, Ref M . dv . ȧ vt ρ v endo Λ v nz length zgrid return NamedTuple Tuple Symbol. v, 1 nz, t vt , NamedTuple Tuple Symbol. c, 1 nz Symbol. s, 1 nz c ȧ end pkgtest let m EconPDEsSlow agrid m.amin . range 0, m.amax m.amin ^0.8, length m.an .^ 1 0.8 agrid range m.aₘᵢₙ, m.aₘₐₓ, length m.an stategrid OrderedDict a agrid yend OrderedDict Symbol v, i v₀ z, a , m for a ∈ agrid for i, z ∈ enumerate m.zgrid m, stategrid, yend end end let m, stategrid, yend pkgtest pdesolve m, stategrid, yend t elapsed result pdesolve m, stategrid, yend info t assert result.residual norm 1e 5 end function inner function ss, v, aₘₐₓ, aₘᵢₙ, r, σ, N a, Δa, z initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 forward difference dvf 1 N a 1, . v 2 N a, v 1 N a 1, Δa dvf N a, . vec z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, . v 2 N a, v 1 N a 1, Δa dvb 1, . vec z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave out consumption and drift upwind vec ss, dvf, dvb, σ, r, aₘᵢₙ, aₘₐₓ u out.c .^ 1 σ 1 σ u, out.c, out.dv, out.ȧ, out.ȧf, out.ȧb end function update v ss, v, par, , Λ, Δ Explicit ρ par u, c, ȧ, ȧf, ȧb, dv inner function ss, v, par HJB equation v change u dv . ȧ v Λ' ρ v v new v Δ v change v new, v change, u, c, ȧ, ȧf, ȧb end function construct A alt ȧfs, ȧbs, da, N a, N z T typeof I from 1, I to 1, λ 0.0 list T car inds CartesianIndices N a, N z | collect .| Tuple lin inds LinearIndices N a, N z for I from, ȧf, ȧb in enumerate zip ȧfs, ȧbs i a, i z car inds I from if ȧf 0 && i a N a I to lin inds i a 1, i z λ ȧf da push list, I from, I to, λ end if ȧb 0 && i a 1 I to lin inds i a 1, i z λ ȧb da push list, I from, I to, λ end end sa StructArray list NN N a 2 A₀ sparse sa.I from, sa.I to, sa.λ, NN, NN for i ∈ 1 NN A₀ i, i sum A₀ i, end A₀ end function construct A ȧs, da, N a, N z size ss N a, N z N N a N z car inds CartesianIndices size ss | collect .| Tuple lin inds LinearIndices size ss initialize list of entries A T typeof I from 1, I to 1, λ 0.0 list T create list of entries of A for I from, ȧ in enumerate ȧs i a, i z car inds I from i a next nothing λ nothing in which direction to move? if ȧ 0 && i a N a i a next i a 1 λ ȧ da elseif ȧ 0 && i a 1 i a next i a 1 λ ȧ da end if isnothing i a next I to lin inds i a next, i z push list, I from, I to, λ end end construct sparse matrix from list of entries list sa StructArray list A sparse list sa.I from, list sa.I to, list sa.λ, N, N fill diagonal A diagind A . vec sum A, dims 2 A end function construct A diag ȧf, ȧb, da, N a X min. ȧb,0 da Z max. ȧf,0 da A11 spdiagm 1 X 2 N a,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 1 Z 1 N a 1,2 A cat A11, A22, dims 1,2 A diagind A . vec sum A, dims 2 A end function construct A moll ȧf, ȧb, da, N a X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da A11 spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 0 Y ,2 , 1 Z 1 N a 1,2 A cat A11, A22, dims 1,2 A end function solve HJB implicit m Moll, r maxit 100, crit √eps , Δ 1000 σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, Δa m da Δa N z length z construct asset grid a range aₘᵢₙ, aₘₐₓ, N a initialize arrays for forward and backward difference dvf zeros N a, N z dvb zeros N a, N z precompute A switch matrix id sparse I, N a, N a A switch 1 hcat λ 1 id, λ 1 id A switch 2 hcat λ 2 id, λ 2 id A switch vcat A switch 1, A switch 2 initial guess for value function v₀ zeros N a, N z for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit STEP 1 forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 STEP 2 c dv upwind .^ 1 σ u c.^ 1 σ 1 σ STEP 3 A construct A moll ȧf, ȧb, Δa, N a A switch B ρ 1 Δ I A b vec u vec v Δ v new stacked B \\ b v new reshape v new stacked, N a, N z STEP 4 v change v new v dist it maximum abs. v change v v new if dist it crit ȧ z . r. a c ss tuple. a, z return v, c, ȧ, a first. ss , z last. ss , A, it last it, dist end end error \"Algorithm did not converge\" end function solve df m Moll, r maxit 100, crit 1e 6, Δ 1000 v, c, ȧ, A, it last, dist solve HJB implicit m, r crit, Δ scheme Implicit maxit, Δ v, c, ȧ, A, it last, dist solve HJB julian m, r, scheme crit g solve KF m, A df results to df m v, c, ȧ, g return df, it last, dist end df, it last, dist solve df m, 0.03 maxit 100 let df.g max min. df.g,df.g 2 chain df begin stack Not a, z, g data mapping a, value, layout variable, color z nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end end function excess demand m Moll, r maxit 100, crit 1e 6, Δ 1000 Δa m df, it last, dist solve df m, r maxit, crit, Δ A dot df.a, df.g Δa end r eq find zero r excess demand m, r , initial bracket, Brent solve HJB implicit m, 0.03 function update v ss, v, par, A switch, , Δ Implicit ρ, N a, Δa par u, c, ȧ, ȧf, ȧb, dv inner function ss, v, par A construct A alt ȧf, ȧb, da, N a, 2 A switch A construct A diag ȧf, ȧb, da, N a A switch A construct A moll ȧf, ȧb, Δa, N a A switch A construct A ȧ, da, N a, 2 A switch B ρ 1 Δ I A b vec u vec v Δ v new stacked B \\ b v new reshape v new stacked, N a, 2 v change v new v v new, v change, u, c, ȧ, ȧf, ȧb end function solve HJB julian m Moll, r, scheme Scheme v₀ v₀, crit 1e 6 maxit, Δ scheme σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, Δa m par σ, ρ, z, N a, aₘₐₓ, m.aₘᵢₙ, Δa, r Λ generator m construct asset grid ss statespace m precompute A switch matrix A switch construct A switch m initial guess for value function v v₀. ss, Ref r, σ, ρ initialize vector that keeps track of convergence dists for it in range 1, maxit updating the value function v new, v change, c, ȧ, ȧf, ȧb update v ss, v, par, A switch, Λ, scheme dist maximum abs. v change v . v new push dists, dist if dist crit A construct A moll ȧf, ȧb, Δa, N a construct A switch m return A, v, c, ȧ, it last it, dist dists end end error \"Algorithm did not converge\" end compare let r 0.02 crit 1e 11 maxit 100 000 scheme Implicit t1 elapsed HJB moll solve HJB implicit m, r crit info t1 t2 elapsed HJB explicit solve HJB explicit m, r crit info t2 t3 elapsed HJB julian solve HJB julian m, r, scheme crit info t3 t4 elapsed HJB econpdes solve HJB econpdes m, r crit info t4 test vec HJB moll.v ≈ vec HJB julian.v ≈ HJB econpdes.v test vec HJB moll.ȧ ≈ vec HJB julian.ȧ ≈ HJB econpdes.ȧ test vec HJB moll.c ≈ vec HJB julian.c ≈ HJB econpdes.c info HJB moll.it last, HJB julian.it last HJB moll, HJB explicit, HJB julian, HJB econpdes end let HJB moll, HJB julian, HJB econpdes compare i z CartesianIndices HJB moll.ȧ .| Tuple .| last | vec i a CartesianIndices HJB moll.ȧ .| Tuple .| first | vec a df moll DataFrame ȧ vec HJB moll.ȧ , c vec HJB moll.c , v vec HJB moll.v , a vec HJB moll.a , z vec HJB moll.z , df gomez HJB econpdes.df df vcat df moll, df gomez, source method \"Moll\", \"Gomez\" chain df begin stack Not a, z, method data mapping a, value, layout variable, color z nonnumeric, linestyle method nonnumeric visual Lines draw , facet linkyaxes false, as svg end end let r 0.03 crit 1e 6 scheme Implicit maxit, Δ v, c, ȧ, A, it last, dist solve HJB julian m, r, scheme crit N size A, 1 g₀ fill 1 N, N t0 elapsed g0 solve KF iterate A, 0.05 t1 elapsed g1 solve KF moll A t2 elapsed g2 solve KF death A t3 elapsed g3 solve KF eigs A t4 elapsed g4 gth solve Matrix A info t0, t1, t2, t3, t4 maximum abs, g0 g1 , maximum abs, g1 g2 , maximum abs, g2 g3 , maximum abs, g3 g4 , maximum abs, g4 g0 norm g1 g stacked norm g1 g1 . sum g1 m.Δa fig Figure ax Axis fig 1,1 lines ax, g1 lines ax, g stacked fig end t impl elapsed solve HJB julian m, 0.03, Implicit let df dist DataFrame iteration range 1, it last , time range 0, t impl, it last , log10 dist log10. dist 1 it last figure resolution 500, 250 chain df dist begin data mapping time, log10 dist visual Lines draw figure as svg end end function solve explicit df m Moll, r maxit 100000, crit √eps scheme Explicit m maxit v, c, ȧ, it last, dist solve HJB julian m, r, scheme crit df results to df m v, c, ȧ return df, it last, dist end df2, it last2, dist2 solve explicit df m, 0.03 crit √eps let df dist DataFrame iteration range 1, it last2 , time range 0, t expl, it last2 , log10 dist log10. dist2 1 it last2 figure resolution 500, 250 chain df dist begin data mapping time, log10 dist visual Lines draw figure as svg end end md\"\"\" Differentiate \"\"\" begin Δy up y, i, Δx y i 1 y i Δx Δy down y, i, Δx y i y i 1 Δx Δy central y, i, Δx y i 1 y i 1 Δx function Δgrid grid, i last length grid inbounds down grid max i, 2 grid max i 1, 1 inbounds up grid min i 1, last grid min i, last 1 central up down avg central 2 up, down, avg, central end function Δy y, bc, i, Δx, fun name, state name up i length y ? Δy up y, i, Δx.up bc i down i 1 ? Δy down y, i, Δx.down bc i second up down Δx.avg NamedTuple deriv names fun name, state name up, down, second end deriv names fun name, state name Symbol fun name, state name, \" \", up , Symbol fun name, state name, \" \", down , Symbol fun name, state name, state name end md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"continuous-time/continuous-time-processes/","title":"Continuous time processes","tags":["continuous-time"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 6 section 1 order 1 title \"Continuous time processes\" layout \"layout.jlhtml\" tags \"continuous time\" description \"\" using Markdown using InteractiveUtils using InfinitesimalGenerators using LinearAlgebra I using Chain, DataFrameMacros using DataFrames using PlutoUI using AlgebraOfGraphics, CairoMakie md\"\"\" `continuous time processes.jl` | Version 1.1 | last updated June 9, 2022 \"\"\" md\"\"\" In this notebook we want to get some intuition for Continuous Time Markov processes Diffusion processes. \"\"\" md\"\"\" Continuous Time Markov Chains What Ben Moll calls finite state Poisson processes Background material QuantEcon lecture notes https continuous time mcs.quantecon.org intro.html Wikipedia https en.wikipedia.org wiki Continuous time Markov chain \"\"\" jumps 0 5 4 0 0 5 0 5 4 0 5 9 0 9 5 0 4 5 0 5 0 0 4 5 0 md\"\"\" The intensity matrix ``Q`` ``Q`` satisfies that ``Q i,j \\geq 0`` for ``i \\ne j`` and ``Q ii \\sum j \\ne i Q ij ``. For a small time interval ``\\Delta t`` and ``i \\ne j`` the intensity ``Q ij `` determines the probability of jumping from ``i`` to ``j`` within that interval ``\\Pr \\Delta t j | i ≈ \\Delta t \\cdot Q i,j ``. \"\"\" begin Q copy jumps for i ∈ 1 size Q, 1 Q i,i sum Q i, end Q end let i 2 j 3 Δt 0.01 Δt Q i,j end md\"\"\" Naively Simulating the CTMC \"\"\" ts let T 10 Δt 0.01 ts 0 Δt T end function simulate Q, ts, s₀ states 1 size Q, 1 Δt diff ts s s₀ out t 0.0, it 1, s for it ∈ 2 length ts t ts it x rand otherstates filter s , states probs Q s, otherstates . Δt it 1 cumprobs cumsum probs for i, s next ∈ enumerate otherstates if x cumprobs i s s next break end end push out, t, it, s end out end df ctmc let N 10000 s₀ 3 initial state dfs map 1 N do i simulate Q, ts, s₀ | DataFrame end vcat dfs..., source i 1 N end let N 10 T 1 title L\"Plotting % N sample paths on t ∈ 0, % T \" chain df ctmc begin subset i ≤ N subset t ≤ T data mapping t, s, color i nonnumeric visual Lines draw axis title end end let N length unique df ctmc.i title \"Plotting frequencies over time\" chain df ctmc begin groupby t, s combine frequency length s N unstack s, frequency, fill 0.0 stack Not t , variable name state, value name frequency data mapping t, frequency, color state visual Lines draw axis title end end md\"\"\" Using the Kolmogorov Forward Equation Let ``\\pi t`` be the probability mass function that describes the cross sectional distribution of the CTMC at time ``t``. Then the evolution of the distribution over time is given by the Kolmogorov Forward equation. ```math \\begin align \\dot g t & Q' g t \\\\ \\implies \\frac g t \\Delta t g t \\Delta t &\\approx Q' g t \\\\ \\implies g t \\Delta t &\\approx g t \\Delta t Q' g t I \\Delta t Q' g t \\end align ``` \"\"\" let n size Q, 2 π zeros n π 1 1.0 Δts diff ts df DataFrame t ts 1 , π, i 1 n dfs df for tm1, Δt ∈ enumerate Δts t tm1 1 π I Δt Q' π df DataFrame t, π, i 1 n push dfs, df end data vcat dfs... mapping t, π, color i nonnumeric visual Lines | draw end md\"\"\" Diffusion processes Diffusion processes are continuous time Markov processes with continuous sample paths no jumps . ```math d X t \\underbrace \\mu X t \\text drift dt \\underbrace \\sigma X t \\text volatility d W t, \\qquad X 0 \\text given ``` where ``W t`` is a Wiener process or Brownian motion . Example Ornstein Uhlenbeck process https en.wikipedia.org wiki Ornstein%E2%80%93Uhlenbeck process ```math d X t \\theta \\mu X t dt \\sigma d W t, \\qquad X 0 \\text given ``` \"\"\" Base. kwdef struct OUProcess μ 0.1 σ 0.1 θ 0.9 end drift x, μ, σ, θ OUProcess θ μ x volatility x, μ, σ, θ OUProcess σ dW Δ Δ randn oup OUProcess md\"\"\" Naive simulations \"\"\" md\"\"\" Using the Kolmogorov Forward Equation Diffusion processes can be represented by their infinitesimal generator https en.wikipedia.org wiki Infinitesimal generator stochastic processes . The discretized version of such a infinitesimal generator looks just like a transition matrix of a CTMC. It turns out that we can use it to simulate and solve the Kolmogorov forward equation. \"\"\" xs, dp let xs range 0.5, 0.5, 50 dp DiffusionProcess xs, drift. xs, Ref oup , volatility. xs, Ref oup xs, dp end df dp let TT typeof it 1, t 1.0, i 1, X 1.0 out TT for i, x₀ ∈ enumerate xs use each gridpoint as initial value once X x₀ push out, it 1, t ts 1 , i, X for itm1, Δt ∈ enumerate diff ts it itm1 1 X X drift X, oup Δt volatility X, oup dW Δt push out, it, t ts itm1 , i, X end end DataFrame out end chain df dp begin subset i % 10 0 data mapping t, X, color i, group i nonnumeric visual Lines draw end chain df dp begin subset it 1 || it % 100 0 data mapping X, group t nonnumeric, color t nonnumeric AlgebraOfGraphics.density draw end generator dp let n length xs π fill 1 n, length xs initial distribution Q generator dp πs π Δt 0.01 fig Figure ax Axis fig 1,1 for i ∈ 1 1000 if i∈ 1,5,10 || i % 20 0 lines ax, xs, π end π I Δt Q' π push πs, π end fig end lines xs, stationary distribution dp md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"continuous-time/indebted-demand-huggett/","title":"Huggett meets Mian-Sufi-Straub","tags":["continuous-time"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 6 section 2 order 2 title \"Huggett meets Mian Sufi Straub\" layout \"layout.jlhtml\" tags \"continuous time\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using Roots find zero, Brent using PlutoUI using Chain chain using DataFrames, DataFrameMacros using CairoMakie using AlgebraOfGraphics using EconPDEs using LinearAlgebra using LinearAlgebra I using StructArrays using SparseArrays md\"\"\" `indebted demand huggett.jl` | Version 2.0 | last updated June 16, 2023 \"\"\" md\"\"\" Huggett model with two income states \"\"\" md\"\"\" Specifying the model \"\"\" u prime inv x, σ x^ 1 σ function consumption and drift a, z , dv, r, σ dv max dv, eps 0.0 c u prime inv dv, σ ȧ z r a c c, ȧ, dv end u prime c, σ c^ σ function consumption and drift₀ a, z , r, σ ȧ zero a c z r a dv u prime c, σ c, ȧ, dv end function consumption and drift upwind state, dvf, dvb, σ, r, aₘᵢₙ, aₘₐₓ consumption and savings with forward difference dv, ȧ, c consumption and drift state, dvf, σ, r if ȧ 0 && state.a aₘₐₓ return dv, ȧf ȧ, ȧb 0.0, c, ȧ end consumption and savings with backward difference dv, ȧ, c consumption and drift state, dvb, σ, r if ȧ 0 && state.a aₘᵢₙ return dv, ȧf 0.0, ȧb ȧ, c, ȧ end consumption and derivate of value function at steady state dv, ȧ, c consumption and drift₀ state, σ, r return dv, ȧf 0.0, ȧb 0.0, c, ȧ end u c, a, σ, γ c 0 ? σ 1 ? log c γ a c^ 1 σ 1 σ γ a 10.0 c 100.0 v₀ z, a , r, σ, ρ, γ u z r a, a, σ, γ ρ function generator λ λ₁₂, λ₂₁ λ Λ λ₁₂ λ₁₂ λ₂₁ λ₂₁ end md\"\"\" Solving the households' problem Helpers \"\"\" function optional to df optional, agrid, zgrid chain optional begin DataFrame transform a bycol collect agrid stack Not a transform i z parse Int, variable end transform variable variable 1 end 1 unstack variable, value transform z zgrid i z select Not i z rename s ȧ end end function solve HJB econpdes M crit √eps , v₀ v₀ agrid M.aₘᵢₙ . range 0, M.aₘₐₓ M.aₘᵢₙ ^0.8, length M.an .^ 1 0.8 agrid range M.aₘᵢₙ, M.aₘₐₓ, M.an stategrid OrderedDict a agrid solend OrderedDict Symbol v, i v₀ z, a , M for a ∈ agrid for i, z ∈ enumerate M.zgrid residual norm, optional pdesolve M, stategrid, solend maxdist crit residual norm, optional, agrid, M.zgrid end function solve HJB econpdes M crit √eps , v₀ v₀ residual norm, optional, agrid, zgrid solve HJB econpdes M crit, v₀ df optional to df optional, agrid, zgrid df.v, df.c, df.ȧ, df, dist residual norm end md\"\"\" Solving the households' problem \"\"\" md\"\"\" Finding the stationary distribution \"\"\" function solve KF an, Δa , A N a an AT copy transpose A b zeros 2 N a, 1 i fix 1 b i fix .1 AT i fix, . vec hcat zeros 1, i fix 1 , 1., zeros 1,2 N a i fix try global g stacked AT\\b catch e if e isa SingularException warn \"SingularException – added noise\" global g stacked AT I √eps \\b else rethrow e end end g sum sum g stacked Δa g stacked norm g stacked . g sum assert sum g stacked norm Δa ≈ 1 g reshape g stacked norm, N a, 2 end function construct A ȧs, da, N a, N z size ss N a, N z N N a N z car inds CartesianIndices size ss | collect .| Tuple lin inds LinearIndices size ss initialize list of entries A T typeof I from 1, I to 1, λ 0.0 list T create list of entries of A for I from, ȧ in enumerate ȧs i a, i z car inds I from i a next nothing λ nothing in which direction to move? if ȧ 0 && i a N a i a next i a 1 λ ȧ da elseif ȧ 0 && i a 1 i a next i a 1 λ ȧ da end if isnothing i a next I to lin inds i a next, i z push list, I from, I to, λ end end construct sparse matrix from list of entries list sa StructArray list A sparse list sa.I from, list sa.I to, list sa.λ, N, N fill diagonal A diagind A . vec sum A, dims 2 A end function construct A switch λ, an id sparse I an λ₁₂, λ₂₁ λ λ₁₂ id λ₁₂ id λ₂₁ id λ₂₁ id end md\"\"\" Solving the equilibrium \"\"\" r grid range 0.001, 0.03, 10 md\"\"\" Assignment Mian Straub Sufi Meet Huggett in Continuous Time In this assignment we will check if the results from Mian, Straub & Sufi 2020 survive in a Huggett setup. \"\"\" md\"\"\" Task 1 Huggett in Continuous Time 5 points In this part of the exercise, we consider homothetic preferences u c log c , i.e. the case \\gamma 0 . \"\"\" md\"\"\" 👉 1.1 | 1 point Solve for the equilibrium interest rate. Hint You can use the function ```compute A D``` defined above. \"\"\" Your code goes here md\"\"\" 👉 1.2 | 1 point Compute the aggregate debt to income ratio in this economy. \"\"\" Your code goes here md\"\"\" 👉 1.3 | 1 points Consider the following income process z 1 0.14 \\frac 2 3 \\xi z 2 0.14 \\xi \\lambda 1 0.02 \\lambda 2 0.03 where \\xi is a measure of income inequality. Prove that changes in \\xi do not affect aggregate income. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 1.4 | 1 points What happens to debt and the interest rate if you increase income inequality \\xi ? \"\"\" bind ineq PlutoUI.Slider 0.06 0.005 0.07, default 0.06, show value true begin Base. kwdef struct HuggettCTMC income process parameters zgrid Vector Float64 0.14 ineq 2 3, 0.14 ineq λ 0.02, 0.03 Λ Matrix Float64 generator λ utility parameters σ Float64 2.0 ρ Float64 0.05 r Float64 0.03 w Float64 1.0 γ Float64 0.0 determines the degree of non homotheticity aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1.5 an Int 500 Δa Float64 aₘₐₓ aₘᵢₙ an 1 end function m HuggettCTMC state NamedTuple, value NamedTuple zgrid, Λ, ρ m nz length zgrid a state v1, v1a up, v1a down, v2, v2a up, v2a down value T eltype value vs v1, v2 dvf v1a up, v2a up dvb v1a down, v2a down states a, z zgrid 1 , a, z zgrid 2 cs Vector T undef, nz ȧs Vector T undef, nz dvs Vector T undef, nz for i ∈ 1 2 c, ȧ, dv consumption and drift upwind states i , dvf i , dvb i , m cs i c ȧs i ȧ dvs i dv end vts ρ . vs . u. cs, a, Ref m . ȧs . dvs . Λ vs return v1t vts 1 , v2t vts 2 , s1 ȧs 1 , s2 ȧs 2 , c1 cs 1 , c2 cs 2 end end output, m let r 0.03 crit 1e 11 m HuggettCTMC r output solve HJB econpdes m crit output, m end let df output chain df begin stack Not a, z data mapping a, value, layout variable, color z nonnumeric, linestyle method nonnumeric visual Lines draw , facet linkyaxes false, end end df π let A switch construct A switch m an, Δa m ȧ output.df A construct A ȧ, Δa, an, 2 A switch chain output.df begin transform π bycol vec solve KF m, A end end output.df chain df π begin subset a m.aₘᵢₙ stack Not a, z data mapping a, value, layout variable, color z nonnumeric, linestyle method nonnumeric visual Lines draw , facet linkyaxes false, end function compute A D r γ 0.0 crit 1e 11 m HuggettCTMC r, γ output solve HJB econpdes m crit A switch construct A switch m an, Δa m ȧ output.df A construct A ȧ, Δa, an, 2 A switch df π chain output.df begin transform π bycol vec solve KF m, A end excess savings demand A dot df π.π, df π.a Δa aggreage debt D dot df π.π, df π.a . df π.a . 0 Δa return A, D end excess savings map r grid do r A, D compute A D r γ 0. r, A, D end | DataFrame let fig Figure ax Axis fig 1,1 , xlabel \"interest rate\", ylabel \"asset supply and demand\" lines ax, r grid, excess savings.A, label \"demand excess savings \" lines ax, r grid, excess savings.D, label \"debt\" hlines ax, 0.0 , label \"zero net supply\", color \"gray\", linestyle dash axislegend ax fig end md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 1.5 | 1 points Find an explanation for the effect of income inequality on the interest rate. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Task 2 Non homothetic preferences 5 points Now we consider nonhomothetic preferences u c, a log c \\gamma a with \\gamma 0.1 . The term \\gamma a has the interpretation that agents get utility from the higher status associated with wealth. 👉 2.1 | 2 points How does the model in this notebook differ from the model in the Mian Straub Sufi paper? Name two key differences. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 2.2 | 1 point Compute the interest rate and debt with the non homothetic preferences. Explain why the equilibrium interest rate is smaller than in the homothetic \\gamma 0 case. \"\"\" Your code goes here Your code goes here md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 2.3| 1 point What happens to debt and the interest rate if you increase income inequality? \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 2.4| 1 point Do your results agree qualitatively with the results in the Mian Straub Sufi paper? Discuss. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Before you submit ... 👉 Make sure you do not mention your name in the assignment. The assignments are graded anonymously. 👉 Make sure that that all group members proofread your submission. 👉 Make sure all the code is well documented . 👉 Make sure that you are within the word limit . Short and concise answers are appreciated. Answers longer than the word limit will lead to deductions. 👉 Go to the very top of the notebook and click on the symbol in the very top right corner. Export a static html file of this notebook for submission. The source code is embedded in the html file. \"\"\" md\"\"\" Appendix \"\"\" TableOfContents function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end "},{"url":"housing/housing-wealth-effects/","title":"Housing Wealth Effects","tags":["housing"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 4 section 3 order 3 title \"Housing Wealth Effects\" layout \"layout.jlhtml\" tags \"housing\" description \"\" using Markdown using InteractiveUtils using QuantEcon using DataFrames using AoGExtensions using StatsBase weights using Statistics mean using PlutoUI using SparseArrays using StructArrays using AlgebraOfGraphics, CairoMakie using DataFrameMacros using Chain md\"\"\" danger \"Under construction \" This notebook is not ready for public consumption. Use at your own risk. \"\"\" md\"\"\" `housing wealth effects.jl` | Version 0.1 | last updated May 3 2022 \"\"\" md\"\"\" Housing Wealth Effects How does consumer spending react to changes in house prices? Similar to the other model House prices follow a Markov Chain Incomes follow a Markov Chain \"\"\" md\"\"\" Parameters \"\"\" function make u ξ, σ function u c, h if c 0 && h 0 C c^ 1 ξ h^ξ σ 1 ? log C C^ 1 σ 1 σ else h 0 Inf h^ξ 100 c 100 end end end function Household σ 2.0, ξ 0.3, β 0.96, u make u ξ, σ β, u end household Household ξ 0.6 params θ 0.01, δ 0.02, γ 2.0 prices r 0.035, w 1.0 md\"\"\" State space \"\"\" ε 0.25 p chain let ε 0.01 MarkovChain 1 ε ε ε 1 ε , 4.5 . 0.75, 1.0 end z chain let ε 0.3 MarkovChain 1 ε ε ε 1 ε , 0.7, 1.3 end function statespace p chain, z chain, h grid, a grid z grid z chain.state values p grid p chain.state values policies a next, a next i, h next, h next i for h next i, h next ∈ enumerate h grid , a next i, a next ∈ enumerate a grid | vec states a i, a, h i, h, p i, p, z i, z for a i, a ∈ enumerate a grid , h i, h ∈ enumerate h grid , p i, p ∈ enumerate p grid , z i, z ∈ enumerate z grid | vec states, policies end md\"\"\" Setting up the `DDP` \"\"\" md\"\"\" Rewards and policies \"\"\" function voluntary equity p , a next, h next , r , θ, δ, γ a next 1 θ 1 δ 1 r p h next end function equity p, a, h , r , θ, δ, γ 1 r a p h 1 δ end function consumption state, a next, h next , prices, params w prices p, z state ω z w equity state, prices, params wealth c ω p h next a next end function reward etc state, policy, prices, params u c consumption state, policy, prices, params eq equity state, prices, params q voluntary equity state, policy, prices, params reward u c, policy.h next reward, eq, c, q, policy... end function a min p , h next , r , θ, δ 1 θ 1 δ 1 r p h next end begin n 25 p grid p chain.state values h grid range 1.5, 5.0, n aₘᵢₙ a min p minimum p grid , h next maximum h grid , prices, params a grid range aₘᵢₙ, 17.0, n end ss statespace p chain, z chain, h grid, a grid is feasible state, policy, prices, params policy.a next a min state, policy, prices, params function setup Q R etc household, statespace, prices, params u household states, policies statespace proto reward etc states 1 , policies 1 , prices, params u T1 sa ind 1, s next ind 1, prob 0.1 | typeof T2 s ind 1, a ind 1, sa ind 1, proto... | typeof out transitions T1 out reward T2 sa ind 0 for i state, state ∈ enumerate states for i policy, policy ∈ enumerate policies a next i, h next i policy if is feasible state, policy, prices, params sa ind 1 s ind i state a ind i policy out reward etc state, policy, prices, params u push out reward, s ind, a ind, sa ind, out... for i state next, next ∈ enumerate states if a next i next.a i && h next i next.h i s next ind i state next π p chain.p state.p i, next.p i z chain.p state.z i, next.z i push out transitions, sa ind, s next ind, prob π end end end end end out transitions StructArray out transitions out reward StructArray out reward Q sparse out transitions.sa ind, out transitions.s next ind, out transitions.prob Q, R out reward.reward, etc out reward, s indices out reward.s ind, a indices out reward.a ind end function setup DDPsa household, statespace, prices, params β, u household Transition function, rewards and policies R, Q, etc, s indices, a indices setup Q R etc household, statespace, prices, params ddp DiscreteDP R, Q, β, s indices, a indices ddp, R, etc end md\"\"\" Alternative Standard formulation slower \"\"\" ╠═╡ R0 let states, policies ss reward out reward etc. states, permutedims policies , Ref prices , Ref params household.u R StructArray reward out .reward end ╠═╡ ╠═╡ Q0 let states, policies ss if length states 1000 throw ArgumentError \"Don't do this it will take too long\" end Q zeros length states , length policies , length states for i state, this ∈ enumerate states for i policy, a next i, h next i ∈ enumerate policies for i state next, next ∈ enumerate states if a next i next.a i && h next i next.h i Q i state, i policy, i state next p chain.p this.p i, next.p i z chain.p this.z i, next.z i end end end end info \"Q takes sizeof Q ÷ 1024^2 MB of memory\" Q end ╠═╡ ╠═╡ Q star sas solve DiscreteDP R0, Q0, household.β , PFI .mc.p | sparse ╠═╡ ╠═╡ results sa.results.mc.p ≈ Q star sas ╠═╡ md\"\"\" Solution and Analysis \"\"\" ddp etc setup DDPsa household, ss, prices, params function solve details0 ddp, statespace, etc solver PFI results QuantEcon.solve ddp, solver states statespace mc, sigma, v results df DataFrame states df.s ind 1 length sigma df.a ind sigma df.value v df.π stationary distributions mc | first df chain df begin leftjoin , DataFrame etc , on s ind, a ind select Not a ind, sa ind end df, results end results sa let ddp, etc ddp etc solve details0 ddp, ss, etc end md\"\"\" Analysis \"\"\" chain results sa.df begin stack c, q, a next, h next , value name val subset z i 1, p i 1 data mapping a, h, val, layout variable visual Surface AlgebraOfGraphics.draw axis type Axis3, end chain results sa.df begin groupby a, h, p i , p combine π sum π data mapping a, h, π, layout p i nonnumeric visual Surface , linestyle p nonnumeric, color z nonnumeric visual Lines AlgebraOfGraphics.draw axis type Axis3, end chain results sa.df begin groupby h, z, p combine π sum π data mapping h, π, linestyle p nonnumeric, color z nonnumeric visual Lines AlgebraOfGraphics.draw end chain results sa.df begin groupby a, z, p combine π sum π data mapping a, π, linestyle p nonnumeric, color z nonnumeric visual Lines AlgebraOfGraphics.draw end md\"\"\" Simulating a Housing Bust \"\"\" outtt let df, results results sa s ind, π chain df begin subset p i 2 select s ind, π bycol π . sum π end states subdf select DataFrame ss.states , Not p i, p s ind, s ind pre copy s ind s ind chain df begin subset p i 1 end s ind post copy s ind Q pre results.mc.p s ind pre, s ind pre Q trans results.mc.p s ind pre, s ind post Q post results.mc.p s ind post, s ind post πs Vector Float64 for t ∈ 1 100 π Q pre' π π long zeros length ss.states π long s ind pre . π push πs, π long end π Q trans' π π long zeros length ss.states π long s ind post . π push πs, π long for t ∈ 1 50 π Q post' π π long zeros length ss.states π long s ind post . π push πs, π long end πs, df, s ind pre, s ind post end let df DataFrame outtt.πs, \"t\" . string. 1 length outtt.πs df select outtt.df, Not π df df chain df begin stack r\"^t\", value name π transform t parse Int, variable 2 end subset t 50 stack c, a, h, eq, h next, a next, q, p , π, t, z i groupby t, variable combine value mean value, weights π data mapping t, value, weights π, layout variable, color z i nonnumeric quantileband AlgebraOfGraphics.draw facet linkyaxes false, end end select DataFrame ss.states , a i, h i, z i outtt.s ind pre, select DataFrame ss.states , a i, h i, z i outtt.s ind post, md\"\"\" Appendix \"\"\" TableOfContents md\"\"\" Packages \"\"\" "},{"url":"housing/housing/","title":"Simple Housing","tags":["housing"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 4 section 1 order 1 title \"Simple Housing\" layout \"layout.jlhtml\" tags \"housing\" description \"\" using Markdown using InteractiveUtils using Optim using QuantEcon using DataFrames, Chain, DataFrameMacros using CairoMakie, AlgebraOfGraphics using AlgebraOfGraphics draw using StatsBase weights using PlutoUI md\"\"\" danger \"Under construction \" This notebook is not ready for public consumption. Use at your own risk. \"\"\" md\"\"\" `housing.jl` | Version 0.1 | last updated Mar 28 2022 \"\"\" md\"\"\" ```math \\begin align &\\max \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t u c t, h t \\Bigr \\\\ &\\begin aligned \\text subject to &u c, h h^\\xi c^ 1 \\xi \\\\ &c t p h t a t p h t 1 1 \\delta a t 1 1 r y t \\cdot w \\\\ &\\log y t \\sim \\text some Markov Chain \\\\ &y 0, k 1 , h 1 \\text given \\end aligned \\end align ``` What needs to be specified parameter ``\\delta``, ``\\xi`` prices ``r``, ``w`` idiosynchratic productivity process initial state `` y 0, k 1 `` \"\"\" md\"\"\" Setting up the recursive problem Naive way two endogenous states ```math \\begin align \\tilde s t & a t 1 , h t 1 , y t \\\\ \\tilde a t & a t , h t \\\\ c \\tilde s, \\tilde a & y t \\cdot w \\underbrace a t 1 1 r p h t 1 1 \\delta \\omega t p h t a t \\\\ r \\tilde s, a, h & u c \\tilde s, \\tilde a , h \\\\ q \\underbrace \\cdot, \\cdot, y t \\tilde s t , \\underbrace \\hat a t, \\hat h t \\tilde a t , \\underbrace a t, h t, y t 1 \\tilde s t 1 & \\begin cases \\Pr y t | y t 1 &\\text if \\hat a t a t \\text and \\hat h t h t\\\\ 0 & \\text otherwise \\end cases \\end align ``` \"\"\" md\"\"\" Sophisticated way one endogenous state, two actions Only possible if housing perfectly liquid i.e. no adjustment frictions ```math \\begin align \\tilde s t & \\omega t, y t \\\\ \\tilde a t & a t , h t \\\\ c \\tilde s, \\tilde a & y t \\cdot w \\omega t a t p h t \\\\ r \\tilde s, a, h & u c \\tilde s, \\tilde a , h \\\\ q \\underbrace \\cdot, y t \\tilde s t , \\underbrace a t, h t \\tilde a t , \\underbrace \\omega t 1 , y t 1 \\tilde s t 1 & \\begin cases \\Pr y t | y t 1 &\\text if \\omega t 1 a t 1 r 1 \\delta ph t\\\\ 0 & \\text otherwise \\end cases \\end align ``` \"\"\" md\"\"\" Sophisticated way one endogenous state, one action Only possible if housing perfectly liquid i.e. no adjustment frictions preferences are simple enough ```math \\begin align \\tilde s t & \\omega t, y t \\\\ \\tilde a t & \\omega t 1 \\\\ c \\tilde s, \\tilde a & y t \\cdot w \\omega t a t p h t \\\\ r \\tilde s, \\omega t 1 & u c \\tilde s, \\tilde a , h \\tilde s, \\tilde a \\\\ q \\underbrace \\cdot, y t \\tilde s t , \\underbrace a t, h t \\tilde a t , \\underbrace \\omega t 1 , y t 1 \\tilde s t 1 & \\begin cases \\Pr y t | y t 1 &\\text if \\omega t 1 a t 1 r 1 \\delta ph t\\\\ 0 & \\text otherwise \\end cases \\end align ``` \"\"\" ξ 0.3 md\"\"\" Setting up the `DDP` \"\"\" md\"\"\" Reward `R` \"\"\" function consumption ω, z , ω next , h next, r, w, p , δ ω ω next 1 r z w p h next 1 1 δ 1 r end a next ω next , h next, p, r , δ ω next p 1 δ h next 1 r function consumption2 ω, z , policy, h next, prices, params a next a next policy, h next, prices, params w, p prices z w ω a next p h next end h max ω next , p, r , ϕ, δ max ω next 1 δ 1 r ϕ , eps function reward etc state, policy, h next, prices, params u a n a next policy, h next, prices, params c consumption state, policy, h next, prices, params c2 consumption2 state, policy, h next, prices, params a next a n assert c ≈ c2 reward u c, h next , c, h next, a next a n, policy... end function setup R etc R, etc, states, policies, prices, params u for i state, state ∈ enumerate states for i policy, policy ∈ enumerate policies h̄ h max policy, prices, params res maximize h next reward etc state, policy, h next, prices, params u .reward, eps , h̄ h opt Optim.maximizer res out reward etc state, policy, h opt, prices, params u R i state, i policy out.reward etc i state, i policy out..., h̄ end end end md\"\"\" Transitions `Q` \"\"\" function setup Q Q, states indices, policies indices, z chain for i next state, next ∈ enumerate states indices for i policy, ω next i ∈ enumerate policies indices for i state, z i ∈ enumerate states indices if next.ω i ω next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end md\"\"\" Solve `DDP` \"\"\" ε 0.25 z chain MarkovChain 1 ε ε 2 ε 2 ε 2 1 ε ε 2 ε 2 ε 2 1 ε , 1.25, 1.0, 0.75 function statespace ω vals range 1e 10, 20.0, length 200 , z chain states ω, z for ω ∈ ω vals, z ∈ z chain.state values | vec states indices ω i, z i for ω i ∈ 1 length ω vals , z i ∈ 1 length z chain.state values | vec policies ω next for ω next ∈ ω vals | vec policies indices ω next i for ω next i ∈ 1 length ω vals | vec states, states indices, policies, policies indices, z chain end function make u ξ, σ function u c, h if c 0 && h 0 C c^ 1 ξ h^ξ σ 1 ? log C C^ 1 σ 1 σ else h 0 Inf h^ξ 100 c 100 end end end function Household σ 2.0, ξ 0.3, β 0.96, u make u ξ, σ β, u end household Household Δ 0.01 make u ξ 0.5, σ 2.0 2 Δ, 0.01 Δ 1.0 params δ 0.02, ϕ 0.8 function setup R etc states, policies, prices, parms u proto reward etc first states , first policies , 0.01, prices, params u T typeof proto..., h̄ 0.1 etc Array T undef, length states , length policies R zeros length states , length policies setup R etc R, etc, states, policies, prices, params u R, etc end function setup DDP household, statespace, prices, params β, u household states, policies, states indices, policies indices, z chain statespace Rewards and policies R, etc setup R etc states, policies, prices, params u Transition function Q setup Q states indices, policies indices, z chain ddp DiscreteDP R, Q, β ddp, R, etc end md\"\"\" Analyze results \"\"\" function solve details0 ddp, statespace, other policies solver PFI results QuantEcon.solve ddp, solver states, policies statespace opp DataFrame other policies i, s for i, s ∈ enumerate results.sigma df hcat DataFrame states , DataFrame policies results.sigma , opp, makeunique true df.value results.v df.state states df.policy policies results.sigma df.additional policies other policies results.sigma df.π only stationary distributions results.mc df, results end function solve details ddp, statespace, additional policies solver PFI df solve details0 ddp, statespace, additional policies solver chain df begin transform consumption consumption state, policy, prices transform saving ω next ω select Not state, policy, additional policies end end md\"\"\" Equilibrium \"\"\" prices p 2.0, r 0.05, w 1.0 reward etc ω 2, z 1 , ω next 2.8 , 1.0, prices, params u make u ξ 0.5, σ 2 ω grid range 0.1, 10, length 200 ss statespace ω vals ω grid, z chain R, ddp, etc setup DDP household, ss, prices, params policies df mapreduce vcat, enumerate eachrow etc do i, row df DataFrame row df.state . i df end chain policies df begin subset state % 10 0 subset reward Inf stack c, h next, a next, reward data mapping ω next, value, layout variable, color state nonnumeric visual Lines draw facet linkyaxes false, end results df solve details ddp, ss, etc let fg chain results df begin stack Not ω, z, π a next, consumption, saving data mapping ω L\"current assets \\omega \", value \"policy\", layout variable, color z nonnumeric, visual Lines draw facet linkyaxes false, , legend position top, titleposition left end ax content fg.figure 2,1 abline ax, 0, 1, color gray, linestyle dash, loose fg end chain results df begin data mapping ω, π, color z nonnumeric visual Lines draw end chain results df begin stack a next, h next, ω next , π data mapping value, weights π, layout variable AlgebraOfGraphics.density draw facet linkyaxes false, linkxaxes false end H 1 function aggregates results chain results begin stack Not π groupby variable combine aggregate sum value, weights π zip .variable, .aggregate Dict end end agg aggregates results df h agg \"h next\" , a agg \"a next\" md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"housing/simple-housing-wealth-effects/","title":"Simple Housing Wealth Effects","tags":["housing"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 4 section 2 order 2 title \"Simple Housing Wealth Effects\" layout \"layout.jlhtml\" tags \"housing\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using Statistics mean using StatsBase weights using CairoMakie using AlgebraOfGraphics using DataFrames, DataFrameMacros, Chain using StructArrays using PlutoUI using PlutoUI Slider begin using StatsBase StatsBase, AbstractWeights using CategoricalArrays formatter from, to, i kwargs... \" i\" function CategoricalArrays.cut x AbstractArray, w AbstractWeights, ngroups Integer labels formatter cut x, StatsBase.quantile x, w, 1 ngroups 1 ngroups extend true, labels end end md\"\"\" `simple housing wealth effects.jl` | Version 1.1 | last updated May 25 2022 \"\"\" md\"\"\" Simple Housing Wealth Effects Based on the article Understanding Housing Wealth Effects Debt, Homeownership and the Lifecycle Greimel & Zadow, 2020 . TODO 2024 Students suggested to add more information to the calibration exercise It is fine to say that some parameters can be set according to external information e.g. \\delta . Only parameters for which such external information is not available need to be calibrated \"internally\" using the method of moments. The discussion of the chosen moments should ideally explain informally how the chosen moments identify the calibrated parameters. It is was not obvious to everyone that they are supposed to redefine the ```model statistics``` and ```data statistics``` lists which are displayed below the parameter sliders. \"\"\" md\"\"\" Model The model is a simplified version of the canonical macroeconomic model with housing. The agents' optimal value is ```math \\begin align V 0 h 0, d 0 &\\max c t, h t 1 \\sum j 0 ^ J 1 \\beta^j u c t, h t 1 \\beta^ J 1 \\psi h J \\\\ &\\begin aligned \\text s.t. & c t p x t \\pi t y \\\\ & x t h t 1 1 \\delta h t \\\\ & \\pi t 1 r d t d t 1 \\\\ &d J \\leq 0 &\\end aligned \\end align ``` \"\"\" md\"\"\" agents life for ``J`` periods and earn a deterministic income ``y`` in each period agents consume a non durable consumption good ``c`` and durable housing ``h`` which depreciates at rate ``\\delta`` agents can borrow debt ``d`` at interest rate ``r`` ``\\beta 1 r 1`` agents cannot die with debt ``d J \\leq 0`` ``p`` follows a Markov Chain on ``\\ p 1, p 2\\ ``, with transition matrix ``\\begin pmatrix 1 \\varepsilon & \\varepsilon \\\\ \\varepsilon & 1 \\varepsilon \\end pmatrix `` with ``\\varepsilon \\to 0``. That is agents think that the house price is constant. ``\\psi h `` captures a warm glow bequest motive. Old agents get some utility of passing on their house to the next generation. Absent a bequest motive agents would sell off their house before their death. The functional form is chosen to allow a closed form solution. \"\"\" md\"\"\" Parameters and Solution \"\"\" Base. kwdef struct SimpleHousingModel β 1 1 0.0245 δ 0.022 ξ 1 0.8875 J 60 y 1.0 d₀ 0.0 end rate β 1 β 1 θ J,r sum 1 1 r ^j for j in 0 J 1 bad name function solve tractable δ, β, ξ, y , d₀, J, p r rate β 𝒴 θ J,r y d₀ κ₁ ξ β 1 δ 1 β 1 δ κ₂ 1 β 1 δ 1 ξ ξ p ^ 1 ξ κ₃ 1 β 1 δ 1 ξ ξ Ω κ₃ ph 𝒴 1 δ θ J,r δ κ₃ h ph p c κ₃ ph π y ph δ c d zeros J d 1 d₀ ph c y for j ∈ 2 J d j d j 1 1 r π end df DataFrame j 0 J 1, d, c, ph, h, π, y c, h, ph, π, d, df end function solve tractable param, p J, β, y, d₀ param r rate β 𝒴 θ J,r y d₀ solve tractable param, d₀, J, p end mod0 SimpleHousingModel PROJ DIR joinpath DIR , \"..\", \"..\", \"..\", \"Research\", \"housing wealth effects\" | normpath md\"\"\" Optimal policies \"\"\" md\"\"\" ``\\beta`` bind β1 Slider 0.8 0.001 1.0, default 1 1 0.0245 , show value true ``\\delta`` bind δ1 Slider 0.0 0.005 0.1, default 0.022, show value true depreciation rate of housing ``\\xi`` bind ξ1 Slider 0.0 0.001 1.0, default 1 0.8875, show value true utility weight of housing ``J`` bind J1 Slider 10 5 400, default 60, show value true length of working life ``y`` bind y1 Slider 0.5 0.5 5.0, default 1, show value true income ``d 0`` bind d₀1 Slider 5 0.5 5, default 0, show value true initial debt if negative asset bind compare1 CheckBox default true compare with defaults \"\"\" policies0 solve tractable mod0, 1.0 .df policies slider let mod1 SimpleHousingModel β β1, δ δ1, J J1, ξ ξ1, y y1, d₀ d₀1 p 1.0 df solve tractable mod1, p .df end let if compare1 df vcat policies slider, policies0, source parameters \"sliders\", \"default\" else df transform policies slider, parameters \"sliders\" end chain df begin transform age j 25 stack Not age, j, parameters data mapping age, value, color variable, layout parameters visual ScatterLines, markersize 5 draw end end md\"\"\" Housing Wealth Effects \"\"\" md\"\"\" ``\\frac p 1 p 0 `` bind q by p Slider 0.5 0.1 1.5, default 0.9, show value true size of shock \"\"\" md\"\"\" An unexpected house price shock \"\"\" md\"\"\" ``j \\text shock `` bind j shock Slider 0 mod0.J 1, default 10, show value true age at which the shock hits \"\"\" let mod0 p₀ 1 p₁ q by p p₀ J, β, d₀, δ mod0 r rate β df₀ solve tractable mod0, d₀, J, p p₀ .df nt subset df₀, j j shock 1 | only | NamedTuple subset df₀, j j shock d₁ nt.d nt.ph p₀ p₁ 1 δ 1 r df₁ solve tractable mod0, d₀ d₁, J J j shock, p p₁ .df transform df₁, j j j shock df df₀ df₁ chain df begin transform age j 25 stack Not age, j data mapping age, value, color variable visual ScatterLines, markersize 5 draw figure figure padding 3, size 300, 300 end end md\"\"\" Consumption response over the lifecycle \"\"\" md\"\"\" ``\\beta`` bind β2 Slider 0.8 0.01 1.0, default 1 1 0.0245 , show value true ``\\delta`` bind δ2 Slider 0.0 0.005 0.1, default 0.022, show value true depreciation rate of housing ``\\xi`` bind ξ2 Slider 0.0 0.05 1.0, default 1 0.8875, show value true utility weight of housing ``J`` bind J2 Slider 10 5 400, default 60, show value true length of working life ``y`` bind y2 Slider 0.5 0.5 5.0, default 1, show value true income bind compare2 CheckBox default true compare with defaults \"\"\" function consumption response J, δ, β, ξ , q by p r rate β κ₃ 1 β 1 δ 1 ξ ξ Ω κ₃ df map 0 J 1 do j num 1 δ q by p θ J j,r δ Ω den 1 δ θ J j,r δ Ω c res num den 1 j, c res end | DataFrame transform df, age j 25 end cres df consumption response mod0, q by p let mod2 SimpleHousingModel β β2, δ δ2, J J2, ξ ξ2, y y2 df consumption response mod2, q by p if compare2 df vcat df, cres df, source parameters \"sliders\", \"default\" else transform df, parameters \"sliders\" end data df mapping age, c res \"consumption response\", color parameters visual ScatterLines | draw end ages cres df.age md\"\"\" Assignment Housing Wealth Effects in an Ageing Society In this assignment we will explore how demographic change is affecting the aggregate response to house price changes. \"\"\" answer1 md\"\"\" Your answer goes here ... \"\"\" model raw chain policies slider begin stack d, c, ph, h, y , π groupby variable combine value mean value, weights π NamedTuple tuple Symbol. .variable ... tuple .value... end model statistics ph model raw.ph model statistics md\"\"\" Exercise 2 Housing Wealth Effects in an Aging Society 6 points Across many countries the demographic structure is changing. The figure below shows historical and forecast age structures for the USA. One notable feature of this figure is the hump that moves from left to right over time. This hump represents the generation of baby boomers . Given that age is an important determinant of housing wealth effects we want to ask the question How do aggregate housing wealth effects change as the society ages? \"\"\" md\"\"\" 👉 Aggregate response 3 points | Compute the aggregate consumption response to a 10% reduction in house prices for varying age structures. You can use `cres df` and `age weights`. \"\"\" your analysis goes here answer2 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Appendix \"\"\" import CSV TableOfContents md\"\"\" Data \"\"\" md\"\"\" SCF \"\"\" scf checksums Dict 1989 \"3600d39fa908f2b6b32a63518fe38d2b7ca7d9c8047e947b054ea2e7d36f7b9e\", 1992 \"d86da7dc07819adb1f08683d7b04f782d2fb1c135ea94880ce4b6550db3c0ccd\", 1995 \"c28169ca73855a1b1f22a999655ea573fc5391b11884b9272c9cf2bf1ee5c442\", 1998 \"69fda43abc88df203f03b9a9e8cf5bf5bc0a626da4b99d44f2fd11dee2c0b11e\", 2001 \"28f5548f91d5f851ad643d9c172e00ecfeb1d6fe47126fb2496af5b980f75ffd\", 2004 \"bb08a6122a25348f6507fcd9377511820972108e8642d6ec1ab3ddf262c21071\", 2007 \"85324789b2ab6f5e5dfc05a8de294e4fd837f7e2174f41e5be5e146435a68aa9\", 2010 \"a85ee57748ec28b3366a4f0b9446ec8b0c34710f14097b6a6e03089c9ad8823a\", 2013 \"f13ed12756798c7e696dbf56ec26438cc2e0c46de4c3343afd3fd05ddfb9e6e8\", 2016 \"11e92c267f333fe10678c9cbb9752c10290085c35abd7c52f7f21c8df45dc468\", 2019 \"87766da9024f7b6742d277c955234cf6bee439248fbc5f689c81d91880fd1b05\", const SCF YEARS 1989 3 2019 begin using DataDeps ENV \"DATADEPS ALWAYS ACCEPT\" true for year in SCF YEARS register DataDep \"SCF year \", \"\", \"https www.federalreserve.gov econres files scfp year excel.zip\", scf checksums year checksum Union String,Vector String ... , Optional, if not provided will generate post fetch method unpack end end function get scf year assert year ∈ SCF YEARS str \"SCF year \" path datadep str str CSV.File joinpath path, \"SCFP year .csv\" | DataFrame end data raw chain get scf 2019 begin stack INCOME, NETWORTH, ASSET, DEBT, NH MORT, HOUSES , WGT groupby variable combine value mean value, weights WGT NamedTuple tuple Symbol. .variable ... tuple .value... end data statistics ph data raw.HOUSES data statistics chain get scf 2019 begin transform age bin bycol cut AGE, weights WGT , 20 transform age bin Meta.parse get age bin groupby age bin combine \"house value\" mean HOUSES, weights WGT , \"ownership rate\" mean HOUSES . 0, weights WGT , age mean AGE, weights WGT stack \"house value\", \"ownership rate\" , age data mapping age, value \"\", row variable visual ScatterLines draw facet linkyaxes false end md\"\"\" Demographics TODO for 2023 reproducibly compile the data in the notebook \"\"\" import HTTP ╠═╡ url \"https www2.census.gov programs surveys popproj datasets 2017 2017 popproj np2017 d1 mid.csv\" ╠═╡ ╠═╡ df pop DataFrame CSV.File HTTP.get url .body ╠═╡ ╠═╡ names df pop ╠═╡ ages url \"https greimel.github.io distributional macroeconomics assets datasets age.csv\" age df0 CSV.File HTTP.get ages url .body | DataFrame age df chain age df0 begin subset year ∈ 1980 10 2040 transform age range from to select age range, share share length age range , year flatten age range rename age range age end chain age df begin subset year ∈ 1980 20 2040 groupby year combine age, pmf share, cdf cumsum share transform inverse cdf 1 cdf stack pmf, inverse cdf , age, year data mapping age, value \"\", row variable, color year nonnumeric visual Lines draw facet linkyaxes false aside Label .figure 0,1 , \"The age distribution over time\", tellwidth false end age weights chain age df begin subset year ∈ 1980 10 2040 subset age ∈ ages aside wgts80 sum subset , year 1980 .share transform raw share share, share share wgts80 end md\"\"\" Infrastructure \"\"\" function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end begin limit1 100 show words limit answer1, limit1 end md\"\"\" Exercise 1 Calibration 4 points 👉 Choose ``n \\geq 1`` statistics that can be computed in the model and in the Survey of Consumer Finances. Choose ``n`` parameters from the model. Set the parameter values so that the statistics in the model match those in the data. 👉 Discuss your choice max. limit1 words . \"\"\" begin limit2 200 show words limit answer2, limit2 end md\"\"\" 👉 External validity 3 points | A politician asks you to forecast the consumption response to house price shock in 2030. Would you use the given model? Discuss some aspects of the real world that are missing from the model. The figure below provides two hints that you may pick up or ignore. max. limit2 words \"\"\" "},{"url":"julia-basics/basic-julia/","title":"Basic Julia","tags":["julia-basics"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 1 section 1 order 1 title \"Basic Julia\" layout \"layout.jlhtml\" tags \"julia basics\" description \"\" using Markdown using InteractiveUtils using PlutoUI md\"\"\" `basic julia.jl` | Version 1.2 | last updated Feb 3 2022 \"\"\" md\" A first glance at the Julia language This notebook briefly summarizes some of the basic Julia syntax that we will need for the problem sets. \" Markdown.MD Markdown.Admonition \"warning\", \"This notebook is taken from\", md\"\"\" Computational Thinking , a live online Julia Pluto textbook. computationalthinking.mit.edu https computationalthinking.mit.edu , original notebook https github.com mitmath 18S191 blob Fall20 lecture notebooks Basic%20Julia%20syntax.jl \"\"\" md\" Variables We can define a variable using ` ` assignment . Then we can use its value in other expressions \" x 3 y 2x md\"By default Julia displays the output of the last operation. You can suppress the output by adding ` ` a semicolon at the end. \" md\"We can ask what type a variable has using `typeof` \" typeof y md\" Functions\" md\"We can use a short form, one line function definition for simple functions \" f x 2 x md\"Typing the function's name gives information about the function. To call it we must use parentheses \" f f 10 md\"For longer functions we use the following syntax with the `function` keyword and `end` \" function g x, y z x y return z^2 end g 1, 2 md\" For loops\" md\"Use `for` to loop through a pre determined set of values \" let s 0 for i in 1 10 s s i end s end md\"Here, `1 10` is a range representing the numbers from 1 to 10 \" typeof 1 10 md\"Above we used a `let` block to define a new local variable `s`. But blocks of code like this are usually better inside functions, so that they can be reused. For example, we could rewrite the above as follows \" function mysum n s 0 for i in 1 n s s 1 end return s end mysum 100 md\" Conditionals `if`\" md\"We can evaluate whether a condition is true or not by simply writing the condition \" a 3 a 5 md\"We see that conditions have a Boolean `true` or `false` value. We can then use `if` to control what we do based on that value \" if a 5 \"small\" else \"big\" end md\"\"\"Note that the `if` also returns the last value that was evaluated, in this case the string `\"small\"` or `\"big\"`, Since Pluto is reactive, changing the definition of `a` above will automatically cause this to be reevaluated \"\"\" md\" Arrays\" md\" 1D arrays `Vector`s \" md\"We can make a `Vector` 1 dimensional, or 1D array using square brackets \" v 1, 2, 3 typeof v md\"The `1` in the type shows that this is a 1D array. We access elements also using square brackets \" v 2 v 2 10 md\"Note that Pluto does not automatically update cells when you modify elements of an array, but the value does change.\" md\"A nice way to create `Vector`s following a certain pattern is to use an array comprehension \" v2 i^2 for i in 1 10 md\" 2D arrays matrices \" md\"We can make small matrices 2D arrays with square brackets too \" M 1 2 3 4 typeof M md\"The `2` in the type confirms that this is a 2D array.\" md\"This won't work for larger matrices, though. For that we can use e.g.\" zeros 5, 5 md\"Note that `zeros` gives `Float64`s by default. We can also specify a type for the elements \" zeros Int, 4, 5 md\"We can then fill in the values we want by manipulating the elements, e.g. with a `for` loop.\" md\"A nice alternative syntax to create matrices following a certain pattern is an array comprehension with a double `for` loop \" i j for i in 1 5, j in 1 6 md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"julia-basics/more-julia/","title":"More Julia","tags":["julia-basics"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 1 section 2 order 1 title \"More Julia\" layout \"layout.jlhtml\" tags \"julia basics\" description \"\" using Markdown using InteractiveUtils using DataFrames using DataFrameMacros using Chain chain using PlutoUI md\"\"\" `more julia.jl` | Version 1.1 | last updated May 10 2022 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" More Julia \"\"\" md\"\"\" The purpose of this notebook is to make you familiar with Julia syntax that is frequently used in the course material. It also points out the peculiarities of Pluto notebooks. \"\"\" md\"\"\" Named tuples and keyword arguments Named tuples Like many other programming languages, Julia allows you to create tuples. The elements of tuples can be accessed by using the corresponding index \"\"\" standard tuple 1, 2 standard tuple 1 md\"\"\" Julia also has named tuples. Just like standard tuples, named tuples allow you to access an element using its index, but alternatively you can also access an element by its name. \"\"\" named tuple a 1, b 2 named tuple.a md\"\"\" This is convenient because it means that you do not need to remember if some parameter is the first element in a tuple or the second one. Below you can see an alternative way of creating named tuples that is frequently used in the course material \"\"\" let a 1 named tuple2 a, b 2 a is equivalent to a a end md\"\"\" Keyword arguments A similar syntax with a semicolon is used for keyword arguments that are identified by name and not by their position as normal function arguments \"\"\" function some function a, b 1 return a b end some function a 3, b 5 let a 3 some function a, b 5 a is equivalent to a a end md\"\"\" Vectorization with dot syntax You can apply a function to all elements of a vector by using the dot syntax \"\"\" 1,2,3 .^ 2 log. 1,2,3 md\"\"\" Note how Julia usually does things in a way that's mathematically consistent. Look at the following code. \"\"\" A ones 3, 3 exp A exp. A A^2 A .^ 2 md\"\"\" What would Python, R or Matlab do? \"\"\" md\"\"\" The pipe operator The pipe operator | makes it possible to write down nested function calls in a more readable way. For example, the two expressions below do the same thing \"\"\" round log named tuple.b named tuple.b | log | round md\"\"\" In case you use R The | operator in Julia is similar to the % % operator in R. \"\"\" md\"\"\" Unicode characters You can use Greek letters and other Unicode characters in your Julia code. For example, type \"\\alpha\" in the cell below without the quotation marks and press Tab on your keyboard. This should create an \\alpha symbol. \"\"\" md\"\"\" See the Julia documention https docs.julialang.org en v1 manual unicode input for a list of supported Unicode characters. For Greek letters, the abbreviations are the same as in LaTeX. \"\"\" md\"\"\" The \\in symbol An elegant way of writing loops is to use the \\in symbol instead of writing \"in\". The \\in symbol can be created by typing \"\\in\" and pressing Tab. \"\"\" i^2 for i ∈ 1 5 md\"\"\" Working with data Here are a few simple examples of working with DataFrames in Julia. If you are familiar with pandas, dplyr or Stata, have a look at this cheatsheet https dataframes.juliadata.org stable man comparisons . Also, have a look at the documentation of DataFrameMacros.jl https jkrumbiegel.github.io DataFrameMacros.jl stable which makes working with DataFrames much more convenient. \"\"\" md\"\"\" Creating a `DataFrame` \"\"\" df1 DataFrame x 1 10 md\"\"\" Transforming mutating a column \"\"\" transform df1, x ByRow x sqrt x transform df1, sqrt x uses transform from DataFrameMacros.jl md\"\"\" The ``` chain``` macro \"\"\" md\"\"\" The ``` chain``` macro works similar to the pipe operator. In the code for this course, the ``` chain``` macro is often applied to data frames together with macros from the ```DataFrameMacros``` package. \"\"\" df2 DataFrame A 1,2,2,1 , B randn 4 md\"\"\" Consider the data frame above. Let's say you would like to add up the values in the B column separately for each value of A take the absolute value of the resulting sums of B values. Using the ``` chain``` macro, we can perform this task with relatively concise code \"\"\" chain df2 begin groupby A combine sum B , automatically named C sum B specify name transform abs C end md\"\"\" Without the ``` chain``` macro, the code would look like this \"\"\" begin df groups groupby df2, A df sum combine df groups, sum B , C sum B transform df sum, abs C end md\"\"\" Pluto notebooks General advice Press F1 to see shortcuts for Pluto notebooks. Ctrl Click on an underlined variable or function to jump to its definition. Use the Live docs in the bottom right corner to get more information about any Julia function or object. Check the Github wiki https github.com fonsp Pluto.jl wiki for more information on Pluto notebooks. Automated updating of cells When changing a function or variable, Pluto automatically updates all affected cells. For example, change the value of d to some other number and see how the following cell updates automatically \"\"\" d 5 d 10 md\"\"\" This is different from jupyter notebooks in which you have to update related cells manually. The automated updating the advantage that you do not have to keep in mind the order in which to evaluate cells. However, it can also be annoying if some of the affected cells take a long time to run. At the time of writing, there is no way to turn off the automated updating but you can always manually disable cells with long run times by clicking on the three dots in the top right corner of a cell. \"\"\" md\"\"\" Only one expression per cell Pluto notebooks only allow one expression per cell. If you nevertheless want to place several expressions into the same cell, you have to use a begin ... end block \"\"\" begin e 10 f e 5 end md\"\"\" Cannot reuse variable names \"\"\" md\"\"\" Use `let` blocks to specify variable names locally. \"\"\" let g 3 end g md\"\"\" Deactivate cells \"\"\" ╠═╡ sleep 5 ╠═╡ md\"\"\" Imported Packages \"\"\" TableOfContents g 1 g 2 "},{"url":"long-run/comparisons/","title":"Has Rising Inequality Fueled the American Debt Boom?","tags":["long-run"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 5 section 1 order 1 title \"Has Rising Inequality Fueled the American Debt Boom?\" layout \"layout.jlhtml\" tags \"long run\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoUI Slider, TableOfContents, CheckBox, NumberField using CairoMakie, AlgebraOfGraphics using Chain chain using DataFrameMacros using DataFrames using CategoricalArrays using StatsBase weights using Statistics mean using LinearAlgebra I using Dates year md\"\"\" `comparisons.jl` | Version 1.0 | last updated May 17 2022 \"\"\" md\"\"\" Social Comparisons, Income Inequality and the Mortgage Boom This lecture is an OLG version of the model in Drechsel Grau & Greimel, 2022, Working Paper https www.greimel.eu static falling behind paper.pdf . Motivation Inequality and the Mortage Boom See the notebook `macroeconomic trends.jl`. Others Shape Our Economic Decisions Our economic decisions are influenced by our peers. Our consumption of visible goods depends on the consumption of our peers' visible goods. Neighbors of lottery winners buy bigger cars https www.aeaweb.org articles?id 10.1257 aer.101.5.2226 Nonrich consume more visible goods when top incomes rise https www.mitpressjournals.org doi abs 10.1162 REST a 00613 Home owners are less happy with their house when a big house is built nearby https papers.ssrn.com sol3 papers.cfm?abstract id 3378131 \"\"\" md\"\"\" Model We consider a lifecycle model where consumers live for two periods. ```math \\begin align &\\max c 1, c 2, h u c 1, s \\beta u c 2, s \\\\ &\\begin aligned \\text s.t. &u c, s c^ 1 \\xi s^\\xi \\\\ &s s h, \\bar h h \\phi \\bar h \\\\ &c 1 p h y d \\\\ &c 2 d 1 r y \\end aligned \\end align ``` \"\"\" Base. kwdef struct ComparisonsOLGModel β 0.95 discount factor ξ 0.3 utility weight of consumption ϕ 0.7 strength of the comparison motive G 0 0 0.5 0 0 0.5 0 0 0 p 1.0 groups \"bottom 50\", \"middle 40\", \"top 10\" group weights weights 0.5, 0.4, 0.1 end par0 ComparisonsOLGModel rate β 1 1 r md\"\"\" Simulating the model \"\"\" par md md\"\"\" ``\\beta`` discount factor assume ``\\beta 1 1 r `` ``\\theta`` utility weight of housing ``\\phi`` strength of the comparison motive ``p`` house price \"\"\" function solution β, ξ, ϕ, p, G, groups , y₀ κ₀ ξ 1 ξ 1 β κ₁ 1 β ξ p κ₂ 1 ξ h next y, h κ₁ y κ₂ ϕ G h function m next y, h h n h next y, h β . y p κ₀ h n ϕ G h end h₀ I ϕ κ₂ G \\ κ₁ y₀ h next, m next, h₀ end begin y₀ 0.5, 1, 2 T 10 end weight df par DataFrame grp par.groups, wgt par.group weights function simulate par, y₀, solution, T N size par.G, 2 h sim zeros N, T m sim zeros N, T y panel zeros N, T y panel , 1 . y₀ for t in 2 T y panel 1, t y panel 1, t 1 y panel 2, t y panel 2, t 1 y panel 3, t 1.1 y panel 3, t 1 end m next, h next, h₀ solution h sim , 1 h₀ m sim , 1 . m next y₀, h₀ for t in 2 T h sim , t h next y panel , t , h sim , t 1 m sim , t m next y panel , t , h sim , t 1 end sim df grp par.groups i , t for i in 1 N, t in 1 T | vec | DataFrame sim df.y y panel | vec sim df.h h sim | vec sim df.m m sim | vec chain sim df begin transform house2income h y, mort2income m y leftjoin weight df par , on grp disallowmissing end end sim df0 simulate par0, y₀, solution par0, y₀ , T md\"\"\" ``\\beta`` bind β1 Slider 0.7 0.05 1.0, show value true, default 0.95 discount factor ``\\xi`` bind ξ1 Slider 0.1 0.1 0.9, show value true, default 0.3 utility weight of housing ``\\phi`` bind ϕ1 Slider 0.1 0.1 0.9, show value true, default 0.7 strength of the comparison motive ``G`` comparison network bind gPP1 Slider 0.0 0.1 1.0, show value true, default 0.0 bind gPM1 Slider 0.0 0.1 1.0, show value true, default 0.7 bind gPR1 Slider 0.0 0.1 1.0, show value true, default 0.0 bind gMP1 Slider 0.0 0.1 1.0, show value true, default 0.0 bind gMM1 Slider 0.0 0.1 1.0, show value true, default 0.0 bind gMR1 Slider 0.0 0.1 1.0, show value true, default 0.7 bind gRP1 Slider 0.0 0.1 1.0, show value true, default 0.0 bind gRM1 Slider 0.0 0.1 1.0, show value true, default 0.0 bind gRR1 Slider 0.0 0.1 1.0, show value true, default 0.0 \"\"\" G1 gPP1 gPM1 gPR1 gMP1 gMM1 gMR1 gRP1 gRM1 gRR1 par1 ComparisonsOLGModel β β1, ξ ξ1, ϕ ϕ1, G G1 sim df vcat sim df0, simulate par1, y₀, solution par1, y₀ , T , source parameters baseline, sliders md\"\"\" Appendix \"\"\" function normalize var, norm var, norm val ref chain begin DataFrame var, norm var subset norm var norm val .var only end var . ref end function normalize var, norm var, norm val , norm var2, norm val2 ref chain begin DataFrame var, norm var, norm var2 subset norm var norm val, norm var2 norm val2 .var only end var . ref end aggregates sim df, par chain sim df begin stack h, m, y , grp, t, wgt, parameters groupby t, variable, parameters combine value mean value, weights wgt unstack variable, value transform house2income h y, mort2income m y stack Not t, parameters groupby variable, parameters transform normed bycol normalize value, t, 1 end chain aggregates sim df, par0 begin data mapping t, normed, color parameters \"\", layout variable visual ScatterLines draw legend position top, titleposition left end chain sim df begin stack Not grp, t, parameters subset variable ∉ \"wgt\", \"y\", \"h\", \"m\" groupby variable, grp, parameters transform value bycol normalize value, t, 1 data mapping t, value, color grp \"\", col parameters, row variable visual Lines, markersize 5 draw legend position top, titleposition left , facet linkyaxes minimal end md\"\"\" Controlling for consumer price inflation to be improved \"\"\" md\"\"\" DataDeps \"\"\" begin using DataDeps ENV \"DATADEPS ALWAYS ACCEPT\" true register DataDep \"MacroHistory\", \"\", \"http data.macrohistory.net JST JSTdatasetR5.dta\" , \"e4691b8ac90e8d6947c65ae197841862ded27a00c167a578c38eccf4f73043ce\" register DataDep \"CEX Betrand Morse\", \"\", \"https dataverse.harvard.edu api access datafile 2781811?format tab&gbrecs true\" , checksum Union String,Vector String ... , Optional, if not provided will generate register DataDep \"AggregatedDINA\", \"\", \"https greimel.github.io DINA.jl dev dina aggregated.csv\" , \"869b880aca5d8614135cd1910e4addaf9a1807dd88d050b890c970efffda7231\" end md\"\"\" Package environment \"\"\" md\"\"\" Plotting \"\"\" md\"\"\" Data wrangling \"\"\" md\"\"\" Other \"\"\" import CSV begin gdpdef CSV.File IOBuffer \"\"\" DATE GDPDEF 1947 01 01 12.2662500000000000 1948 01 01 12.9542500000000000 1949 01 01 12.9345000000000000 1950 01 01 13.0880000000000000 1951 01 01 14.0227500000000000 1952 01 01 14.2650000000000000 1953 01 01 14.4392500000000000 1954 01 01 14.5722500000000000 1955 01 01 14.8172500000000000 1956 01 01 15.3225000000000000 1957 01 01 15.8322500000000000 1958 01 01 16.1905000000000000 1959 01 01 16.4132500000000000 1960 01 01 16.6380000000000000 1961 01 01 16.8140000000000000 1962 01 01 17.0190000000000000 1963 01 01 17.2137500000000000 1964 01 01 17.4767500000000000 1965 01 01 17.7955000000000000 1966 01 01 18.2945000000000000 1967 01 01 18.8252500000000000 1968 01 01 19.6257500000000000 1969 01 01 20.5900000000000000 1970 01 01 21.6772500000000000 1971 01 01 22.7747500000000000 1972 01 01 23.7565000000000000 1973 01 01 25.0605000000000000 1974 01 01 27.3225000000000000 1975 01 01 29.8405000000000000 1976 01 01 31.4877500000000000 1977 01 01 33.4400000000000000 1978 01 01 35.7845000000000000 1979 01 01 38.7665000000000000 1980 01 01 42.2740000000000000 1981 01 01 46.2737500000000000 1982 01 01 49.1317500000000000 1983 01 01 51.0447500000000000 1984 01 01 52.8917500000000000 1985 01 01 54.5665000000000000 1986 01 01 55.6680000000000000 1987 01 01 57.0402500000000000 1988 01 01 59.0510000000000000 1989 01 01 61.3700000000000000 1990 01 01 63.6722500000000000 1991 01 01 65.8217500000000000 1992 01 01 67.3197500000000000 1993 01 01 68.9162500000000000 1994 01 01 70.3870000000000000 1995 01 01 71.8645000000000000 1996 01 01 73.1792500000000000 1997 01 01 74.4417500000000000 1998 01 01 75.2792500000000000 1999 01 01 76.3655000000000000 2000 01 01 78.0732500000000000 2001 01 01 79.7897500000000000 2002 01 01 81.0505000000000000 2003 01 01 82.5510000000000000 2004 01 01 84.7730000000000000 2005 01 01 87.4147500000000000 2006 01 01 90.0637500000000000 2007 01 01 92.4825000000000000 2008 01 01 94.2887500000000000 2009 01 01 95.0027500000000000 2010 01 01 96.1067500000000000 2011 01 01 98.1152500000000000 2012 01 01 99.9987500000000000 2013 01 01 101.7512500000000000 2014 01 01 103.6322500000000000 2015 01 01 104.6225000000000000 2016 01 01 105.7190000000000000 2017 01 01 107.7050000000000000 2018 01 01 110.2917500000000000 2019 01 01 112.2615000000000000 2020 01 01 113.6112500000000000 \"\"\" | DataFrame gdpdef.year year. gdpdef.DATE end get dina df CSV.File joinpath datadep\"AggregatedDINA\", \"dina aggregated.csv\" | DataFrame TableOfContents "},{"url":"long-run/indebted-demand/","title":"Indebted demand","tags":["long-run"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 5 section 2 order 2 title \"Indebted demand\" layout \"layout.jlhtml\" tags \"long run\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using LinearAlgebra using ForwardDiff using Roots using Chain, DataFrames, DataFrameMacros using AlgebraOfGraphics, CairoMakie using PlutoUI using PlutoUI Slider md\"\"\" `indebted demand.jl` | Version 1.1 | last updated May 31 2023 \"\"\" md\"\"\" Indebted demand This lecture is based on the paper Indebted Demand Mian, Straub & Sufi 2021 QJE . Motivation We have seen rising inequality, rising debt and falling interest rates. See the notebook `macroeconomic trends.jl`. This paper make the point that wealth inequality is driving down interest rates and driving up household debt if preferences are non homothetic . \"\"\" md\"\"\" Parameters and functional forms \"\"\" Base. kwdef struct IndebtedDemandModel μˢ 0.01 population share of the rich ωˢ 0.06 wealth share of the rich ρ 0.1 discount factor ℓ 0.0248 pledgeability of real assets δ 0.025 mortality rate η̃ 0.87 bequest parameter 1 calibrated ã 0.38 bequest parameter 2 calibrated – match MPC out of wealth of 0.01 λ 1 end η a, η̃, ã 1 1 η̃ ã log 1 exp η̃ a ã md\"\"\" Computing the equilibrium \"\"\" d r, ℓ ℓ r function r rhs r, d, params ρ, δ, ωˢ params ρ 1 δ ρ 1 δ ρ η ωˢ r d, params end f r, d, params r r rhs r, d, params function savings supply d, params, bracket 0.0001, 1.0 try return find zero r f r, d, params , bracket catch info f d, bracket 1 , params , f d, bracket 2 , params return missing end end function equilibrium df params chain begin DataFrame d range 4, 4, 200 transform r supply savings supply d, params transform r demand params.ℓ d stack r\"^r \", value name r transform variable replace variable, \"r \" \"\" subset ismissing r subset 0.0 r 0.13 end end function f equilibrium r, params f r, d r, params , params end md\"\"\" Comparative statics Inequality drives interest rates and household debt \"\"\" params default IndebtedDemandModel ωˢ 0.02 let params params default r eq find zero r f equilibrium r, params , 0.001, 0.1 d eq d r eq, params r eq, d eq end md\"\"\" ``\\omega^S`` bind ωˢ Slider 0.01 0.005 0.07, show value true, default 0.02 wealth share of the rich ``\\ell`` bind ℓ Slider 0.01 0.005 0.1, show value true, default 0.0248 pledgability of real assets \"\"\" params slider IndebtedDemandModel ωˢ, ℓ df default equilibrium df params default let df slider equilibrium df params slider df vcat df default, df slider, source parameters default, slider chain df begin data mapping d \"debt level\", r \"interest rate\", color variable \"\", linestyle parameters \" \" visual Lines draw legend position top, titleposition left end end md\"\"\" Calibration In the paper, they pick ``r`` and ``\\rho`` and choose the parameters `` \\tilde \\eta, ã `` from the ``\\eta`` function. \"\"\" md\"\"\" ``\\tilde \\eta`` bind η̃ Slider 0.5 0.01 1.3, default 0.87, show value true ``ã`` bind ã Slider 0.1 0.01 0.9, default 0.38, show value true \"\"\" let params IndebtedDemandModel ωˢ 0.06 r eq find zero r f equilibrium r, params , 0.001, 0.1 d eq d r eq, params r eq, d eq end let params IndebtedDemandModel ωˢ 0.06 r eq find zero r f equilibrium r, params , 0.001, 0.1 d eq d r eq, params r eq, d eq end let ρ, δ, ℓ, ωˢ params default r analytic ρ δ δ ρ ωˢ ℓ d analytic ℓ ρ δ δ ρ ωˢ ℓ end η prime a, params ForwardDiff.derivative a η a, params , a η prime 1.0, params default ε η a, params η prime a, params a η a, params ε η 3.0, params default function MPC a, r, params ρ, δ, ℓ, ωˢ params r ρ δ 1 √ 1 4 1 r ρ δ r ρ δ ε η a, params end function f cali η̃, ã params IndebtedDemandModel η̃, ã r 0.055 dd d r, params Δr f r, dd, params a params.ωˢ r dd mpc MPC a, r, params Δmpc mpc 0.01 info dd, Δr, Δmpc, mpc norm Δr, Δmpc end f cali η̃, ã md\"\"\" Appendix \"\"\" TableOfContents function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end "},{"url":"long-run/redistributive-growth/","title":"Redistributive growth","tags":["long-run"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 5 section 3 order 3 title \"Redistributive growth\" layout \"layout.jlhtml\" tags \"long run\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoUI using PlutoUI Slider using DataFrames using CairoMakie using ForwardDiff using Optim using LaTeXStrings md\"\"\" `redistributive growth.jl` | Version 1.2 | last updated on May 10, 2023 \"\"\" md\"\"\" Redistributive Growth This lecture is based on the paper Redistributive Growth Döttling and Perotti 2019 . This paper tries to explain various macroeconomic trends with a technological shift to intangible capital. \"\"\" md\"\"\" Parameterization \"\"\" md\"\"\" We use a slight variation of the parameterization in the September 2019 version of the paper. The utility from housing is v L \\log L . \"\"\" Base. kwdef struct RedistributiveGrowthModel L̄ 1 supply of land ϕ 0.2 fraction with high human capital h̃ 8 0.2 inelastic supply of high skilled labor l̃ 10 1 0.2 inelastic supply of low skilled labor α 0.33 capital share η 0.45 relative productivity of intangible capital & high skilled labor ω 0.9 fraction of intangibles that can be \"stolen\" by innovators ψ 1. cost for producing intangibles A 1. productivity end mod RedistributiveGrowthModel md\"\"\" Representative firm \"\"\" md\"\"\" We consider the special case \\rho \\rightarrow 0 in which the production function has a Cobb Douglas form Y F K, H, l, h A H^\\alpha h^ 1 \\alpha ^\\eta K^\\alpha l^ 1 \\alpha ^ 1 \\eta \"\"\" function F K, H, l, h, A, η, α A H^α h^ 1 α ^η K^α l^ 1 α ^ 1 η end md\"\"\" 1. Productivity of intangible capital \\eta bind η sl Slider range 0, 1, length 101 , default 0.5, show value true 2. Capital share \\alpha bind α sl Slider range 0, 1, length 101 , default 0.5, show value true 3. Common productivity factor A bind A sl Slider 1 100, default 1, show value true \"\"\" md\"\"\" Labor is supplied inelastically in this model so that l 1 \\phi \\tilde l and h \\phi \\tilde h . Therefore, we can write down the production function as a function of only K and H \"\"\" function F K, H, A, η, α, ϕ, l̃, h̃ l 1 ϕ l̃ h ϕ h̃ F K, H, l, h, A, η, α end md\"\"\" We can compute the first derivatives of the production function numerically which correspond to the factor prices price of physical capital 1 r price of intangible capital R H wage for manual workers w wage for high skill workers q \"\"\" F xx, par F xx..., par let Hs Ks range 0.01, 1, length 101 title latexstring \"Contour plot of \\ Y K, H, l 1, h 1 \\ \" fig Figure ax, plt contourf fig 1,1 , Hs, Ks, x, y F x, y, 1., 1., A A sl, η η sl, α α sl , axis title, xlabel L\"K\", ylabel L\"H\" Colorbar fig 1,2 , plt fig end function get prices K, H, mod ϕ, l̃, h̃ mod l 1 ϕ l̃ h ϕ h̃ xx K, H, l, h oneplusr, R H, w, q ForwardDiff.gradient x F x, mod , xx Y F xx, mod check Y w l q h oneplusr K R H H check, oneplusr, R H, w, q, Y end get prices 0.5, 1., mod md\"\"\" Steady state equilibrium \"\"\" md\"\"\" The equations that describe the steady state values of \\ K, H, Y, r, R H, f, p\\ together with the production function are given in the appendix of the paper 1 r \\alpha 1 \\eta \\frac Y K R H \\alpha \\eta \\frac Y H H \\frac \\omega \\psi R H f \\frac 1 \\omega R H H r p \\frac v' \\bar L r \\frac 1 \\bar L r 1 \\alpha Y p \\bar L f K \"\"\" md\"\"\" Exercise 1 3 points 👉 Provide brief derivations for equation 1 1 point and equation 4 2 points above. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Solving for the steady state \"\"\" md\"\"\" We use numerical methods to solve for the steady state. First, we reformulate the system of equations by substituting out the five variables \\ Y, r, R H, f, p\\ , so that we end up with a system of just two equations as a function of K and H \"\"\" function model equations 1 K, H, mod α, η, ω, L̄, ϕ, l̃, A mod Y F K, H, mod production function r α 1 η Y K 1 eq. 1 rearranged R H α η Y H eq. 2 f 1 ω R H H r eq. 4 p 1 L̄ r eq. 5 return Y, r, R H, f, p end function model equations 2 K, H, mod Y, r, R H, f, p model equations 1 K, H, mod α, ω, L̄, ψ mod eq 1 H ω ψ R H eq. 3 rearranged eq 2 1 α Y p L̄ f K eq. 6 rearranged return eq 1, eq 2 end md\"\"\" ```eq 1``` and ```eq 2``` in the function above should be zero at the steady state values of K and H . Consequently, the sum of the squares ```eq 1```² ```eq 2```² should also be zero in this case. This means that we can find the steady state values of K and H by applying a minimization algorithm to ```eq 1```² ```eq 2```². To make sure that the algorithm does not accidentally use negative values for K or H , we write down the objective function in terms of \\log K and \\log H . After running the minimization algorithm, we always need to check if the sum of squares is indeed zero or at least extremely close to zero . Other solution algorithms are possible and probably better than this approach. See this notebook https greimel.github.io distributional macroeconomics notebooks redistributive growth fabian with alternative solution methods for the redistributive growth model. \"\"\" function objective function log K log H, mod K exp log K log H 1 H exp log K log H 2 eq 1, eq 2 model equations 2 K, H, mod return eq 1^2 eq 2^2 end md\"\"\" We need to initialize the minimization algorithm at values for K and H that are associated with a positive interest rate r . Otherwise, the algorithm may converge to another minimum with a negative interest rate that is not economically meaningful. Below you can see that the interest rate associated with our starting values is indeed positive. \"\"\" begin K init 0.4 H init 1. model equations 1 K init, H init, mod end md\"\"\" Now we apply the minimization algorithm. The objective function is very close to 0 at the minimum that the algorithm found. \"\"\" res optimize x objective function x, mod , log K init , log H init md\"\"\" Since the arguments of the objective function are \\log K and \\log H , we need to exponentiate the minimizer to get the steady state values of K and H \"\"\" K, H exp. Optim.minimizer res md\"\"\" To find the steady state values of \\ Y, r, R H, f, p\\ , we put the steady state values of K and H into the equations that we have used to substitute out these five variables \"\"\" model equations 1 K, H, mod md\"\"\" Moreover, we can get steady state wages w and q by computing the numerical gradient of the production function \"\"\" get prices K, H, mod md\"\"\" Exercise 2 1 point The steady state interest rate r round model equations 1 K, H, mod .r 100,digits 1 % seems quite big at a first glance. 👉 Is steady state interest rate in the model roughly consistent with interest rates in the real world? Provide a brief explanation. max. 100 words \"\"\" answer 2 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Secular trends \"\"\" md\"\"\" The paper claims that a shift towards intangible capital \\eta \\uparrow in the model can explain the following macroeconomic trends declining interest rates r \\downarrow increasing share of intangible capital H H K \\uparrow declining physical investment scaled by GDP K Y \\downarrow increasing mortgage borrowing m Y \\uparrow increasing house prices p Y \\uparrow increasing stock prices f Y \\uparrow increasing wage inequality q w \\uparrow \"\"\" md\"\"\" To confirm that an increase in \\eta indeed generates the secular trends listed above for the given parameterization, we compute the steady state for a slightly higher value of \\eta such as \\eta round mod.η 0.1, digits 2 and compare the variables of interest in the two steady states. \"\"\" mod η RedistributiveGrowthModel η mod.η 0.1 model equations 1 K init, H init, mod η res η optimize x objective function x, mod η , log K init , log H init K η, H η exp. Optim.minimizer res η md\"\"\" The first row describes the steady state for the baseline value for \\eta , the second row for \\eta round mod η.η, digits 3 \"\"\" md\"\"\" Below you can find two helper functions to compute the macroeconomic variables of interest for given steady state values K , H , and to compare macroeconomic variables across steady states \"\"\" function compute trends variables K, H, mod Y, r, R H, f, p model equations 1 K, H, mod ϕ, L̄, l̃ mod w, q get prices K, H, mod m max 0, 1 ϕ p L̄ f w l̃ H HK H H K K Y K Y m Y m Y p Y p Y f Y f Y q w q w r, H HK, K Y, m Y, p Y, f Y, q w end begin trends vars compute trends variables K, H, mod trends vars η compute trends variables K η, H η, mod η DataFrame trends vars, trends vars η end function trends trends vars 1, trends vars 0 for key in keys trends vars 0 if trends vars 1 key trends vars 0 key 1e 6 sgn \"↑\" elseif trends vars 1 key trends vars 0 key 1e 6 sgn \"↓\" else sgn \"→\" end println key, \" \" , sgn end end trends trends vars η, trends vars md\"\"\" Alternative growth drivers \"\"\" md\"\"\" In the previous section, we found out that a technological shift to intangible capital \\eta \\uparrow can explain the secular trends at least qualitatively . But is it the only possible explanation of these trends? In order to exclude other possible explanations, we need to consider alternative growth drivers and check which of the secular trends they can replicate and which not. The following alternative growth drivers are already implemented in the model greater ease of innovation \\psi \\downarrow rising share of educated workers \\phi \\uparrow rising productivity of capital relative to labor \\alpha \\uparrow increased bargaining power for innovators over established firms \\omega \\uparrow \"\"\" md\"\"\" Exercise 3 2.5 points 👉 Pick one of the four alternative growth drivers listed above and conduct a comparison of steady states similar to the \\eta \\uparrow case. Which of the secular trends can this growth driver explain and which not? Provide a brief explanation for the changes in \\ r, H H K , K Y, m Y, p Y, f Y, w q\\ that are generated by the parameter change that you consider. max. 200 words \"\"\" Your code goes here ... answer 3 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Exercise 4 3.5 points An alternative growth driver are capital inflows from emerging countries into the developed world \"global savings glut\" . These capital inflows can be incorporated into the model by adding an exogenous increase in savings x to the steady state equations 1 \\alpha x Y p \\bar L f K 👉 Add the exogenous increase in savings to the model and repeat exercise 3 for this alternative growth driver. max. 200 words \"\"\" Your code goes here ... answer 4 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Before you submit ... 👉 Make sure you do not mention your name in the assignment. The assignments are graded anonymously. 👉 Make sure that that all group members proofread your submission. 👉 Make sure all the code is well documented . 👉 Make sure that you are within the word limit . Short and concise answers are appreciated. Answers longer than the word limit will lead to deductions. 👉 Go to the very top of the notebook and click on the symbol in the very top right corner. Export a static html file of this notebook for submission. The source code is embedded in the html file. \"\"\" md\"\"\" Appendix \"\"\" md\"\"\" Acknowledgments The visualization of the production function was contributed by Andrea Titton https github.com NoFishLikeIan . \"\"\" md\"\"\" Word limit functions \"\"\" function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end show words limit answer 2, 100 show words limit answer 3, 200 show words limit answer 4, 200 md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"preliminaries/aiyagari/","title":"Aiyagari","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 2 section 3 order 3 title \"Aiyagari\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoUI Button, Slider, TableOfContents, NumberField using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using DataFrames stack using StatsBase weights using Statistics mean using LinearAlgebra using Roots find zero, Brent using QuantEcon md\"\"\" `aiyagari.jl` | Version 1.1 | last updated May 16, 2022 \"\"\" md\"\"\" Bewley Huggett Aiyagari \"\"\" md\"\"\" Households' problem \"\"\" md\"\"\" ```math \\begin align &\\max \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t u c t \\Bigr \\\\ &\\begin aligned \\text subject to &u c \\log c \\\\ &c t k t k t 1 1 r \\delta y t \\cdot w \\\\ &\\log y t \\sim \\text some Markov Chain \\\\ &y 0, k 1 \\text given \\end aligned \\end align ``` What needs to be specified parameter ``\\delta`` prices ``r``, ``w`` idiosynchratic productivity process initial state `` y 0, k 1 `` \"\"\" md\"\"\" Let ``s k, y `` be the state and ``a k' `` be the action. We can then write ```math c s,a \\cdots y \\cdot w k\\cdot 1 r \\delta k' ``` Let us also define the reward function ```math r s, a \\cdots u c s,a \\cdots ``` Rewrite this recursively, ```math \\begin align v s \\max a \\in A r s, a \\operatorname E v s' |s, a \\end align ``` \"\"\" md\"\"\" Setup \"\"\" md\"\"\" To find a solution to the households' problem, we will use the Quantecon toolbox. The toolbox requires us to specify an n \\times m array R that contains the value of the reward function for each state and action R ij r s i, a j an n \\times m \\times n array Q that gives the probability to end up in state s' in the next period for a given state s and action a in this period Q ijk \\text Prob s' s k|s s i, a a j a discount factor \\beta . For more information on this way of formulating Discrete State Dynamic Programming problems, please have a look at the QuantEcon lecture notes https julia.quantecon.org dynamic programming discrete dp.html on this topic. \"\"\" md\"\"\" As a first step, we represent household preferences by a named tuple that contains the discount factor \\beta and the utility function u \\cdot \"\"\" function Household σ 1.0, β 0.96, u σ 1 ? log x x^ 1 σ 1 1 σ β, u end md\"\"\" Moreover, the function below constructs the state space for a given grid of asset values ```k vals``` and a given Markov process ```z chain```. The resulting vector of possible states has length n and the vector of possible policies has length m . \"\"\" function statespace k vals range 1e 10, 20.0, length 200 , z chain states k, z for k ∈ k vals, z ∈ z chain.state values | vec states indices k i, z i for k i ∈ 1 length k vals , z i ∈ 1 length z chain.state values | vec policies k next for k next ∈ k vals | vec policies indices k next i for k next i ∈ 1 length k vals | vec states, states indices, policies, policies indices, z chain end md\"\"\" Now we can compute the array of transition probabilities Q If the chosen amount of assets coincides with the amount of assets in the state next period, the transition probability is equal to the transition probability for the productivity process \\text Prob z'|z . In all other cases, the transition probability is zero. \"\"\" function setup Q Q, states indices, policies indices, z chain for i next state, next ∈ enumerate states indices for i policy, k next i ∈ enumerate policies indices for i state, z i ∈ enumerate states indices if next.k i k next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end md\"\"\" Before we can compute the reward array R , we first need a function that can compute consumption for a given state and action. The function below allows for a higher interest rate r \\text borrow r \\Delta r for households with negative assets. \"\"\" function consumption z, k , k next , q, w, Δr if k next 0 && Δr 0 r 1 q 1 k next 0 Δr q 1 1 r end c w z k q k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, policies, prices, u for k i, policy ∈ enumerate policies for s i, state ∈ enumerate states R s i, k i reward state, policy, prices, u end end return R end function setup R states, policies, prices, u R zeros length states , length policies setup R R, states, policies, prices, u end md\"\"\" Finally, we define a function that creates an instance of the ```DiscreteDP``` i.e. Discrete Dynamic Program class for given household preferences, a given state space and given prices. \"\"\" md\"\"\" Model parameters \"\"\" md\"\"\" First, let us define the interest rate, the wage, and the interest wedge for borrowers. We also define functions that turn the interest rate into the price of a bond q . \"\"\" r 0.02 q r 1 1 r prices q q r , w 1.0, Δr r 2 md\"\"\" Next, we define choose the parameters that govern household preferences. \"\"\" hh Household σ 2.0, β 0.96 md\"\"\" We also need to define the Markov chain for the productivity process \"\"\" z chain MarkovChain 0.75 0.25 0.25 0.75 , 1.25, 0.75 function setup DDP household, statespace, prices β, u household states, policies, states indices, policies indices statespace R setup R states, policies, prices, u Q setup Q states indices, policies indices, z chain DiscreteDP R, Q, β end md\"\"\" We combine this Markov chain with a grid for assets ```k vals``` to construct the state space. The smallest asset value on the grid defines the maximum amount that a household can borrow. The largest asset value on the grid needs to be large enough so that it does not distort the model solution. \"\"\" ss statespace k vals range 1., 5., length 200 , z chain md\"\"\" As the final step, we create an instance of the ```DiscreteDP``` class for the previously defined parameter values. \"\"\" ddp setup DDP hh, ss, prices md\"\"\" Solve households' problem \"\"\" md\"\"\" We solve the households' problem using the policy function iteration PFI algorithm from the QuantEcon toolbox. In the data frame below, each row corresponds to point in the state space. \\pi denotes the stationary distribution. \"\"\" function solve details0 ddp, states, policies solver PFI results QuantEcon.solve ddp, solver df DataFrame states DataFrame policies results.sigma df.state states df.policy policies results.sigma df.π stationary distributions results.mc , 1 1 df end function solve details ddp, states, policies solver PFI df solve details0 ddp, states, policies solver chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end end results solve details ddp, ss.states, ss.policies solver PFI md\"\"\" Policy functions The figure below show how much a household should consume and how much it should save given its current amount of assets and productivity state. \"\"\" let fg chain results begin stack Not k, z, π data mapping k L\"current assets k \", value \"policy\", layout variable, color z nonnumeric, visual Lines draw facet linkyaxes false, , legend position top, titleposition left end ax content fg.figure 2,1 fg end k first chain results begin subset k next k groupby z combine first k end md\"\"\" Below, we compute the lowest asset value at which we observe dissaving by the household. Households in the low productivity state dissave even when they are very close to the borrowing constraint, while households in the high productivity state only start dissaving above an asset level of round k first 1, \"k first\" , digits 3 . \"\"\" md\"\"\" Stationary distribution The figure below depicts the probability density over assets for separately for the two productivity levels. \"\"\" chain results begin data mapping k, π, color z nonnumeric visual Lines draw end md\"\"\" More on the stationary distribution In the first lecture you have learned that the Aiyagari model is a Markov chain with respect to the n \\times n transition matrix Q^ that is implicitly defined by the stochastic income process and the optimal savings rule. Note that Q^ is different from the n \\times m \\times n matrix Q which did not impose the optimal savings rule. In the cell below, we compute Q^ by combining the optimal savings rule with the Q matrix. We also check if the rows of Q^ sum to 1 \"\"\" begin res QuantEcon.solve ddp, PFI Q setup Q ss.states indices, ss.policies indices, ss.z chain Q star 1 zeros length ss.states , length ss.states for i state, state ∈ enumerate ss.states indices Q star 1 i state, Q i state,res.sigma i state , end sum Q star 1 dims 2 ' end md\"\"\" Within the QuantEcon framework, the Q^ matrix is saved as ```res.mc.p``` where ```res``` is some results object that is returned by the ```QuantEcon.solve``` function. Below, we check if the Q^ matrix computed by us is the same as the Q^ matrix computed by the ```QuantEcon project``` \"\"\" begin Q star 2 res.mc.p isapprox Q star 1, Q star 2 end md\"\"\" If the Markov chain is ergodic, we can obtain the stationary distribution by starting with an arbitray distribution \\pi 1 over the state space and applying the transition matrix to it until the distribution converges to the stationary distribution \\pi \\infty . You can do this using the buttons below Restart Initialize \\pi 1 such that all agents are in the high income state with zero assets Update \\pi i 1 ' \\pi i' \\cdot Q^ Feel free to choose another initialization. Note that Pluto automatically applies one update step after you press \"Restart\". \"\"\" md\"\"\" bind restart dens Button \"Restart\" bind update dens Button \"Update\" \"\"\" begin restart dens j 1 I need to use array here because otherwise Pluto complains that there are multiple definitions of j dist zeros size ss.states dist 1 1. df DataFrame ss.states df.π dist end begin update dens j 1 j 1 1 df.π df.π' Q star 1 ' print j 1 , \" iterations\" chain df begin data mapping k, π, color z nonnumeric visual Lines draw end end md\"\"\" Aggregate outcomes \"\"\" md\"\"\" The function below computes aggregate consumption, aggregate assets etc. Since we assume that there is a probability mass 1 of households, computing the aggregate variables means computing the average over the state space weighted by the stationary distribution of households. \"\"\" function aggregates results chain results begin stack Not π groupby variable combine aggregate sum value, weights π zip .variable, .aggregate Dict end end agg aggregates results md\"\"\" Interactive results \"\"\" md\"\"\" Risk aversion coefficient \\sigma \"\"\" bind σ slider Slider 1. 0.25 3., show value true, default 2. md\"\"\" Discount factor \\beta \"\"\" bind β slider Slider 0.95 0.005 0.97, show value true, default 0.96 begin hh slider Household σ σ slider, β β slider ddp slider setup DDP hh slider, ss, prices results slider solve details ddp slider, ss.states, ss.policies solver PFI end md\"\"\" Aggregate savings round mean results slider.k, weights results slider.π , digits 3 \"\"\" begin fg chain results slider begin stack Not k, z data mapping k \"current assets k\", value, layout variable, color z nonnumeric, visual Lines draw facet linkyaxes false, , legend position top, titleposition left end ax content fg.figure 2,2 ablines ax, 0, 1, color gray, linestyle dash, loose fg end md\"\"\" Huggett equilibrium \"\"\" md\"\"\" Setup To compute the Huggett equilibrium, we need a function that computes the amount of excess savings in the economy for a given interest rate r . \"\"\" function excess savings hh, statespace, r w, Δr ddp setup DDP hh, statespace, w, q q r , Δr Δr results solve details ddp, statespace.states, statespace.policies, solver PFI return ζ mean results.k, weights results.π end ζ r excess savings hh, ss, r, w prices.w, Δr prices.Δr md\"\"\" Finding the equilibrium In the Huggett equilribium, the equilibrium interest rate is the interest rate at which the excess savings \\zeta r are zero. To find this interest rate, we use the so called bisection algorithm. \"\"\" md\"\"\" Initial interval for interest rate As a first step, we need to find an interval so that excess savings are positive at one endpoint and negative at the other endpoint. Left endpoint r l bind left NumberField 0.00 0.01 0.04, 0.01 Right endpoint r r bind right NumberField 0.01 0.01 0.04, 0.03 \"\"\" md\"\"\" Excess savings at left endpoint ``\\zeta r l `` round excess savings hh, ss, left prices.w, prices.Δr , digits 4 right endpoint ``\\zeta r r `` round excess savings hh, ss, right prices.w, prices.Δr , digits 4 \"\"\" md\"\"\" If you have found such an interval, you can be sure that the excess savings function \\zeta r crosses zero at least once in this interval. This means that we can start the bisection algorithm now. Bisection algorithm One step of the bisection algorithm works as follows compute the midpoint r m 1 2 r l r d if the sign of \\zeta r m is different from the sign of \\zeta r l use the midpoint r m as the right endpoint of the new interval and leave the left endpoint unchanged if the sign of \\zeta r m is different from the sign of \\zeta r r use the midpoint r m as the left endpoint of the new interval and leave the right endpoint unchanged bind start Button \"Restart bisection\" bind go Button \"Bisect the interval\" \"\"\" begin start left vec left right vec right ζ left vec ζ left ζ right vec ζ right if ζ left vec end ζ right vec end 0. throw DomainError left, right , \"Function has the same sign at the left endpoint and at the right endpoint\" end end begin go mid left vec end right vec end 2 ζ mid ζ mid if ζ left vec end ζ mid 0. push left vec, left vec end push ζ left vec, ζ left vec end push right vec, mid push ζ right vec, ζ mid elseif ζ right vec end ζ mid 0. push left vec, mid push ζ left vec, ζ mid push right vec, right vec end push ζ right vec, ζ right vec end else throw DomainError left, right , \"Function has the same sign at the left endpoint and at the right endpoint\" end info left vec end , right vec end f Figure ax1 Axis f 1, 1 , xlabel \"interest rate r\", ylabel \"excess savings ζ\" scatter ax1, left vec, ζ left vec scatter ax1, right vec, ζ right vec vspan ax1, left vec end , right vec end , ymin 1., y max 1., color grey, 0.2 r vec vcat left vec, reverse right vec ζ vec vcat ζ left vec, reverse ζ right vec lines ax1, r vec, ζ vec, color \"black\" xlabel ax1, \"excess savings ζ\" ylabel ax1, \"interest rate r\" current figure end md\"\"\" Aiyagari equilibrium \"\"\" md\"\"\" Setup \"\"\" md\"\"\" The production function is F K, N A K^\\alpha N^ 1 \\alpha where K is the capital stock and N is labor. \"\"\" function production f, K return f.A K ^ f.α f.N ^ 1 f.α end md\"\"\" The function below creates a named tuple with all parameters that describe the technology of the firm. \"\"\" function Firm A 1, N 1, α 0.33, δ 0.05 A, N, α, δ end md\"\"\" From the first order conditions we can derive three functions that will be useful later on the capital demand function and its inverse ```K to r``` a function that computes the wage that is associated with the given interest rate \"\"\" function capital demand f, r K f.α f.A r f.δ ^ 1 1 f.α f.N return K end function K to r f, K Compute the interest rate that is associated with the given demand for capital return f.A f.α f.N K ^ 1 f.α f.δ end function r to w f, r Compute the wage that is associated with the given interest rate return f.A 1 f.α f.A f.α r f.δ ^ f.α 1 f.α end md\"\"\" Model parameters \"\"\" firm Firm md\"\"\" For the household problem, we choose other model parameters than in the Huggett model. Moreover, we use less grid points for assets to make sure that the calibration of \\beta does not take too much time. \"\"\" hh2 Household β 0.96, u log ss2 statespace k vals range 1e 10, 20.0, length 100 , z chain MarkovChain 0.9 0.1 0.1 0.9 , 0.1 1.0 md\"\"\" Finding the equilibrium \"\"\" md\"\"\" First, we have a look at the capital demand and supply curves \"\"\" function capital supply hh, f, statespace, r w r to w f, r ddp setup DDP hh, statespace, w, q q r , Δr 0.0 results solve details ddp, statespace.states, statespace.policies, solver PFI return K mean results.k, weights results.π end begin r vals supply range 0.001, 0.04, length 20 k vals capital supply. Ref hh2 , Ref firm , Ref ss2 , r vals supply r vals demand K to r. Ref firm , k vals end let fig Figure ax fig 1, 1 Axis fig, xlabel \"capital\", ylabel \"interest rate\" lines k vals, r vals demand, label \"demand\" lines k vals, r vals supply, label \"supply\" axislegend fig end function excess demand hh, f, statespace, r supply capital supply hh, f, statespace, r demand capital demand f, r return demand supply end begin initial bracket 0.005, 0.055 r eq find zero r excess demand hh2, firm, ss2, r , initial bracket, Brent k eq capital demand firm, r eq r eq, k eq end md\"\"\" To determine the exact equilibrium interest rate, we apply a root finding algorithm to a function that computes excess demand for capital for a given interest rate. We could of course use the bisection algorithm that we have used to compute the Huggett equilibrium above. But to make sure that the code is fast enough, we take the Brent algorithm https en.wikipedia.org wiki Brent%27s method which is implemented in the ```Roots.jl``` package. Since the household's decision problem needs to be solved for a different value of the interest rate at each step of the algorithm, finding the equilibrium can be time consuming, especially in more complicated models. The resulting equilibrium interest rate is round r eq, digits 4 and the associated capital stock is round k eq, digits 3 . \"\"\" wto target 3.63 md\" Calibrating the discount factor \\beta Now, let's choose the discount factor \\beta such that the wealth to output ratio K F K,N matches the US value of round wto target, digits 3 Auclert and Rognlie, 'Inequality and Aggregate Demand', Appendix B . We can achieve this by minimizing the objective function O \\beta \\left \\frac K \\beta F K \\beta ,N 3.63\\right ^2 where K \\beta denotes the equilibrium capital stock in the Aiyagari model that is associated with a given discount factor \\beta . \" function wealth to output ratio β, u, firm, statespace, initial bracket hh β Household β β, u u r eq find zero r excess demand hh β, firm, statespace, r , initial bracket, Brent , atol 1e 5, rtol 1e 5, xatol 1e 5, xrtol 1e 5 k eq capital demand firm, r eq return k eq production firm, k eq end wealth to output ratio 0.96, hh2.u, firm, ss2, initial bracket begin β vals 0.945 0.005 0.965 wto vals wealth to output ratio β, hh2.u, firm, ss2, initial bracket for β in β vals obj vals wto vals . wto target .^ 2 end lines β vals, obj vals, axis xlabel L\"discount factor β \", ylabel \"value of the objective function\" β cal find zero β wealth to output ratio β, hh2.u, firm, ss2, initial bracket wto target, 0.945, 0.965 , Brent , atol 1e 5, rtol 1e 5, xatol 1e 5, xrtol 1e 5 md\"\"\" Appendix \"\"\" TableOfContents md\"\"\" Acknowledgements This notebook has been dramatically improved by Daniel Schmidt https github.com danieljschmidt . \"\"\" "},{"url":"preliminaries/lifecycle/","title":"Lifecycle models","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 2 section 4 order 4 title \"Lifecycle models\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils using QuantEcon using Chain, DataFrameMacros, DataFrames using CairoMakie using AlgebraOfGraphics draw using StatsBase using StatsBase weights using AlgebraOfGraphics using AlgebraOfGraphics density using AoGExtensions using LinearAlgebra using LightGraphs using PlutoUI TableOfContents md\"\"\" danger \"Under construction \" This notebook is not ready for public consumption. Use at your own risk. \"\"\" md\"\"\" `lifecycle.jl` | Version 0.1 | last updated Apr 13 2022 \"\"\" md\"\"\" Lifecycle models The setup should be basically identical to the one in `aiyagari.jl`, except that demographic structure is changed. We'll cover the case of finite lifetime and perpetual youth. \"\"\" md\"\"\" Setup \"\"\" function statespace a vals range 1e 10, 20.0, length 200 , z chain states a, z for a ∈ a vals, z ∈ z chain.state values | vec states indices a i, z i for a i ∈ 1 length a vals , z i ∈ 1 length z chain.state values | vec policies a next for a next ∈ a vals | vec policies indices a next i for a next i ∈ 1 length a vals | vec states, states indices, policies, policies indices, z chain end function Household σ 1.0, β 0.96, m 0.0, u σ 1 ? log x x^ 1 σ 1 1 σ β, u, m end function setup Q Q, states indices, policies indices, z chain for i next state, next ∈ enumerate states indices for i policy, a next i ∈ enumerate policies indices for i state, z i ∈ enumerate states indices if next.a i a next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end function consumption z, a , a next , q, w, Δr if a next 0 && Δr 0 r 1 q 1 a next 0 Δr q 1 1 r end c w z a q a next c, a next end function reward etc state, policy, prices, u c, a next consumption state, policy, prices if c 0 reward u c else reward 100 000 100 c end reward, c end function setup R etc R, etc, states, policies, prices, u for i policy, policy ∈ enumerate policies for i state, state ∈ enumerate states out reward etc state, policy, prices, u R i state, i policy out.reward etc i state, i policy out... end end return nothing end function setup R etc states, policies, prices, u proto reward etc first states , first policies , prices, u T typeof proto etc Array T undef, length states , length policies R zeros length states , length policies setup R etc R, etc, states, policies, prices, u R, etc end md\"\"\" State space \"\"\" r guess hh, scale 0.9 1 hh.β 1 hh.m scale q r 1 1 r r from q q 1 q 1 md\"\"\" Solve Households' problem \"\"\" md\"\"\" Infinite lifetime vs finite lifetime vs perpetual youth \"\"\" md\"\"\" Finite lifetime \"\"\" J 40 Create an instance of Household hh Household m 1 J r r guess hh, 0.8 prices q q r , w 1.0, Δr r 2 function simulate J ddp, J, v term, states, policies , other policies, π₀ vs, sigmas backward induction ddp, J, v term initial distribution π copy π₀ initialize DataFrame to store the results dfs DataFrame for j ∈ 1 J σ sigmas , j R σ, Q σ RQ sigma ddp, σ op DataFrame other policies i, s for i, s ∈ enumerate σ df DataFrame states DataFrame policies σ op df.j . j df.π vec π π π Q σ Q initial distribution push dfs, df end vcat dfs... end md\"\"\" Perpetual youth \"\"\" function simulate ddp, J, states, policies , other policies, π₀, solver PFI results QuantEcon.solve ddp, solver σ results.sigma R σ, Q σ RQ sigma ddp, σ op DataFrame other policies i, s for i, s ∈ enumerate σ df0 DataFrame states DataFrame policies σ op initial distribution π copy π₀ initialize DataFrame to store the results dfs DataFrame for j ∈ 1 J df copy df0 df.j . j df.π vec π π π Q σ Q initial distribution push dfs, df end vcat dfs... end md\"\"\" Evolution of assets over age \"\"\" ╠═╡ chain df big begin data mapping j, a, weights π visual Violin draw end ╠═╡ ε 0.1 z chain MarkovChain 1 ε ε ε 1 ε , 1.25, 0.75 function setup DDP household, statespace, prices β, m, u household states, policies, states indices, policies indices statespace Rewards and policies R, etc setup R etc states, policies, prices, u Transition function Q setup Q states indices, policies indices, z chain ddp DiscreteDP R, Q, β 1 m ddp, R, etc end ss statespace a vals range 2, 2.0, length 200 , z chain Use the instance to build a discrete dynamic program am ddp, etc let ddp, etc setup DDP hh, ss, prices am ddp ddp, etc end v term map ss.states do a, z a ≥ 0 ? 0 100 000 a end initial distribution let i 0 findfirst DataFrame ss.states .a . 0 π₀ map ss.states indices do a i a i i 0 ? 1.0 0.0 end π₀ sum π₀ end df big simulate J am ddp, J, v term, ss, etc, initial distribution' chain df big begin stack a, a next, c , j, π groupby j, variable combine value mean value, weights π data mapping j, value, layout variable visual ScatterLines draw facet linkyaxes false, end chain df big begin data mapping a, weights π density histogram draw end chain df big begin stack a, a next, c , j, π, z groupby j, variable data mapping j, value, weights π, color z nonnumeric, layout variable quantileband draw facet linkyaxes false, end df big2 simulate am ddp, J, ss, etc, initial distribution' chain df big2 begin stack a, a next, c , j, π groupby j, variable combine value mean value, weights π data mapping j, value, layout variable visual ScatterLines draw facet linkyaxes false, end chain df big2 begin stack a, a next, c , j, π, z groupby j, variable data mapping j, value, weights π, color z nonnumeric, layout variable quantileband draw facet linkyaxes false, end chain df big begin combine a mean a, weights π , a next mean a next, weights π , end chain df big2 begin combine a mean a, weights π , a next mean a next, weights π , end md\"\"\" Perpetual youth \"\"\" md\"\"\" constant death probability ``m`` \"\"\" m 1 45 hh perp youth Household m md\"\"\" Appendix \"\"\" md\"\"\" Stationary distribution \"\"\" begin abstract type StatDistSolver end struct Eigen StatDistSolver end struct GTH StatDistSolver end struct Iterate StatDistSolver end end function stationary distribution mc MarkovChain, solver StatDistSolver GTH kwargs... stationary distribution mc.p, solver kwargs... end function stationary distribution Q AbstractMatrix, m, solver kwargs... Q̃ 1 m Q m I stationary distribution Q̃, solver kwargs... end function stationary distribution Q AbstractMatrix, m, π₀, π m π₀ I 1 m Q π' end function stationary distribution Q AbstractMatrix, m, π₀, Iterate maxit 400, π guess π₀, rtol √eps π copy π guess for i in 1 maxit π new 1 m π Q m π₀ if isapprox π new, π rtol info \"Converged after i iterations\" return π new' end if i maxit warn \"Didn't converge after i iterations\" return π new' end π . π new end nothing end function stationary distribution Q AbstractMatrix, GTH this essentially copies the implementation of QuantEcon.jl n size Q, 1 π zeros n ids only attracting components DiGraph Q π ids . gth solve Q ids,ids π end function stationary distribution Q AbstractMatrix, Iterate rtol √eps , maxit 400 Qn copy Q for i in 1 maxit Qn new Qn Q if isapprox Qn new, Qn rtol info \"Converged after i iterations\" break end if i maxit warn \"Didn't converge after i iterations\" end Qn . Qn new end Qn 1, end function real if real x assert isreal x real x end function stationary distribution Q AbstractMatrix, Eigen values, vectors eigen Q' find unit eigenvalue i only findall values .≈ 1.0 get corresponding eigenvector π vectors , i make sure it isn't complex, normalize sum to 1 π real if real π π . π sum π end function solve details0 ddp, states, policies , other policies m, π₀, solver PFI results QuantEcon.solve ddp, solver op DataFrame other policies i, s for i, s ∈ enumerate results.sigma df hcat DataFrame states , DataFrame policies results.sigma , op, makeunique true df.value results.v df.state states df.policy policies results.sigma df.additional policies other policies results.sigma df.π stationary distribution results.mc.p, m, π₀, GTH df, results df end function solve details ddp, statespaces, etc m, π₀, solver PFI df solve details0 ddp, statespaces, etc m, π₀, solver chain df begin select Not state, policy, additional policies end end Solve using policy function iteration results df solve details am ddp, ss, etc hh.m, π₀ initial distribution', solver PFI chain results df begin combine a mean a, weights π , a next mean a next, weights π , end chain results df begin groupby a combine π sum π data mapping a, π visual Lines draw end let ddp setup DDP hh perp youth, ss, prices assert ddp.beta hh perp youth.β 1 hh perp youth.m m hh perp youth results QuantEcon.solve ddp, PFI σ results.sigma R σ, Q σ RQ sigma ddp, σ Q̃ 1 m Q σ m I mc aux MarkovChain copy Q̃ π only stationary distributions mc aux assert π ≈ stationary distribution Q̃, Eigen assert π ≈ stationary distribution Q̃, GTH assert π ≈ stationary distribution Q̃, Iterate , rtol eps ^ 3 4 assert π ≈ stationary distribution Q σ, m, Eigen assert π ≈ stationary distribution Q σ, m, π', GTH assert π ≈ stationary distribution Q σ, m, π', Iterate π guess fill 1 400, 1, 400 , rtol eps ^ 3 4 end md\"\"\" Misc \"\"\" TableOfContents "},{"url":"preliminaries/macroeconomic-trends/","title":"Macroeconomic trends","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 2 section 1 order 1 title \"Macroeconomic trends\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils using DataFrames, DataFrameMacros, Chain begin using CategoricalArrays using StatsBase formatter from, to, i kwargs... \" i\" function CategoricalArrays.cut x AbstractArray, w AbstractWeights, ngroups Integer labels formatter cut x, StatsBase.quantile x, w, 1 ngroups 1 ngroups extend true, labels end end using AlgebraOfGraphics, CairoMakie using Dates year using PlutoUI md\"\"\" `macroeconomic trends.jl` | Version 1.0 | last updated May 5 2022 \"\"\" md\"\"\" Remarkable Macroeconomic Trends \"\"\" md\"\"\" Aggregate trends MacroHistory database https www.macrohistory.net app download 9834516169 JST documentation.pdf?t 1641215586 House prices, Debt, Interest rate, Inflation \"\"\" md\"\"\" Inequality US Distributional National Accounts We will first take a look at a few facts from the US distributional national accounts data Piketty, Saez & Zucman, 2018 and then try explain them using our simple model of social comparisons. \"\"\" md\"\"\" note \"Note\" The DINA dataset can only be downloaded in bulk. It is 1GB in zipped form. You can use my package DINA.jl https github.com greimel DINA.jl to easily download and store the data. Here we will work with summary statistics that can are taken from the docs of DINA.jl https greimel.github.io DINA.jl latest . \"\"\" md\"\"\" The US Inequality Boom \"\"\" md\"\"\" The US Household Debt Boom \"\"\" md\"\"\" Household balance sheets SCF Networth Flow Chart https www.federalreserve.gov econres files Networth%20Flowchart.pdf rising debt which kinds of debt rising homeownership rising asset share of housing shifting expenditure shares CEX \"\"\" md\"\"\" Household assets Mainly housing \"\"\" md\"\"\" Household debt Mainly mortgages \"\"\" md\"\"\" Homeownership \"\"\" md\"\"\" Indebtedness over time \"\"\" md\"\"\" Appendix \"\"\" import HTTP function normalize var, norm var, norm val ref chain begin DataFrame var, norm var subset norm var norm val .var only end var . ref end function normalize var, norm var, norm val , norm var2, norm val2 ref chain begin DataFrame var, norm var, norm var2 subset norm var norm val, norm var2 norm val2 .var only end var . ref end md\"\"\" Controlling for consumer price inflation to be improved \"\"\" md\"\"\" DataDeps SCF, CEX, MacroHistory \"\"\" import CSV function csv from url url csv CSV.File HTTP.get url .body df DataFrame csv end begin dina df csv from url \"https greimel.github.io DINA.jl dev dina aggregated.csv\" transform dina df, three groups categorical, renamecols false levels dina df.three groups, \"bottom 50\", \"middle 40\", \"top 10\" wgt dweght inc peinc byvar inc dbt var ownermort, rentalmort, nonmort, hwdeb var byvar dbt var dina df end agg df let id var group id, age, year, wgt chain dina df begin select id var..., var... stack Not id var groupby variable, year combine value mean value, weights wgt unstack variable, value transform d, inc ByRow string d \"2inc\" for d in dbt var ... end end debt fig let df chain agg df begin stack dbt var, year, inc transform value value inc groupby variable transform \"relative to 1980\" bycol normalize value, year 1980 transform \"relative to total debt in 1980\" bycol normalize value, year 1980, variable \"hwdeb\" stack \"relative to 1980\", \"relative to total debt in 1980\" , variable, year , variable name \"normalization\" end fg chain df begin data mapping year, value, layout normalization, color variable \"\" visual Lines draw legend position bottom, titleposition left , facet linkyaxes false, end Label fg.figure 0, , \"Growth of Household Debt To Income in the USA\" fg end begin gdpdef CSV.File IOBuffer \"\"\" DATE GDPDEF 1947 01 01 12.2662500000000000 1948 01 01 12.9542500000000000 1949 01 01 12.9345000000000000 1950 01 01 13.0880000000000000 1951 01 01 14.0227500000000000 1952 01 01 14.2650000000000000 1953 01 01 14.4392500000000000 1954 01 01 14.5722500000000000 1955 01 01 14.8172500000000000 1956 01 01 15.3225000000000000 1957 01 01 15.8322500000000000 1958 01 01 16.1905000000000000 1959 01 01 16.4132500000000000 1960 01 01 16.6380000000000000 1961 01 01 16.8140000000000000 1962 01 01 17.0190000000000000 1963 01 01 17.2137500000000000 1964 01 01 17.4767500000000000 1965 01 01 17.7955000000000000 1966 01 01 18.2945000000000000 1967 01 01 18.8252500000000000 1968 01 01 19.6257500000000000 1969 01 01 20.5900000000000000 1970 01 01 21.6772500000000000 1971 01 01 22.7747500000000000 1972 01 01 23.7565000000000000 1973 01 01 25.0605000000000000 1974 01 01 27.3225000000000000 1975 01 01 29.8405000000000000 1976 01 01 31.4877500000000000 1977 01 01 33.4400000000000000 1978 01 01 35.7845000000000000 1979 01 01 38.7665000000000000 1980 01 01 42.2740000000000000 1981 01 01 46.2737500000000000 1982 01 01 49.1317500000000000 1983 01 01 51.0447500000000000 1984 01 01 52.8917500000000000 1985 01 01 54.5665000000000000 1986 01 01 55.6680000000000000 1987 01 01 57.0402500000000000 1988 01 01 59.0510000000000000 1989 01 01 61.3700000000000000 1990 01 01 63.6722500000000000 1991 01 01 65.8217500000000000 1992 01 01 67.3197500000000000 1993 01 01 68.9162500000000000 1994 01 01 70.3870000000000000 1995 01 01 71.8645000000000000 1996 01 01 73.1792500000000000 1997 01 01 74.4417500000000000 1998 01 01 75.2792500000000000 1999 01 01 76.3655000000000000 2000 01 01 78.0732500000000000 2001 01 01 79.7897500000000000 2002 01 01 81.0505000000000000 2003 01 01 82.5510000000000000 2004 01 01 84.7730000000000000 2005 01 01 87.4147500000000000 2006 01 01 90.0637500000000000 2007 01 01 92.4825000000000000 2008 01 01 94.2887500000000000 2009 01 01 95.0027500000000000 2010 01 01 96.1067500000000000 2011 01 01 98.1152500000000000 2012 01 01 99.9987500000000000 2013 01 01 101.7512500000000000 2014 01 01 103.6322500000000000 2015 01 01 104.6225000000000000 2016 01 01 105.7190000000000000 2017 01 01 107.7050000000000000 2018 01 01 110.2917500000000000 2019 01 01 112.2615000000000000 2020 01 01 113.6112500000000000 \"\"\" | DataFrame gdpdef.year year. gdpdef.DATE end df3 let chain gdpdef begin transform prices bycol normalize GDPDEF, year 1980 end id var group id, three groups, age, year, wgt chain dina df begin select id var..., var... subset age ∉ 65 stack Not id var groupby three groups, year, variable combine value mean value, weights wgt leftjoin , select gdpdef, year, prices , on year transform real value value prices end end ineq fig let fg chain df3 begin subset variable \"peinc\" groupby three groups transform normalized bycol normalize real value, year 1980 data visual Lines mapping year, normalized, color three groups \"\" draw axis title \"Growth of real pre tax incomes across income groups\", end ax content fg.figure 1,1 vlines ax, 1980, 2007 , linestyle dash, loose , color gray fg end d2y fig chain df3 begin select variable, value, year, three groups subset variable ∈ \"ownermort\", \"peinc\" unstack variable, value transform mort2inc ownermort peinc groupby three groups transform normalized bycol normalize mort2inc, year 1980 data visual Lines mapping year, normalized, color three groups \"\" draw axis title \"Mortgage to income by income group\", end scf checksums Dict 1989 \"3600d39fa908f2b6b32a63518fe38d2b7ca7d9c8047e947b054ea2e7d36f7b9e\", 1992 \"d86da7dc07819adb1f08683d7b04f782d2fb1c135ea94880ce4b6550db3c0ccd\", 1995 \"c28169ca73855a1b1f22a999655ea573fc5391b11884b9272c9cf2bf1ee5c442\", 1998 \"69fda43abc88df203f03b9a9e8cf5bf5bc0a626da4b99d44f2fd11dee2c0b11e\", 2001 \"28f5548f91d5f851ad643d9c172e00ecfeb1d6fe47126fb2496af5b980f75ffd\", 2004 \"bb08a6122a25348f6507fcd9377511820972108e8642d6ec1ab3ddf262c21071\", 2007 \"85324789b2ab6f5e5dfc05a8de294e4fd837f7e2174f41e5be5e146435a68aa9\", 2010 \"a85ee57748ec28b3366a4f0b9446ec8b0c34710f14097b6a6e03089c9ad8823a\", 2013 \"f13ed12756798c7e696dbf56ec26438cc2e0c46de4c3343afd3fd05ddfb9e6e8\", 2016 \"11e92c267f333fe10678c9cbb9752c10290085c35abd7c52f7f21c8df45dc468\", 2019 \"87766da9024f7b6742d277c955234cf6bee439248fbc5f689c81d91880fd1b05\", begin using DataDeps ENV \"DATADEPS ALWAYS ACCEPT\" true for year in 1989 3 2019 register DataDep \"SCF year \", \"\", \"https www.federalreserve.gov econres files scfp year excel.zip\", scf checksums year checksum Union String,Vector String ... , Optional, if not provided will generate post fetch method unpack end register DataDep \"MacroHistory\", \"\", \"http data.macrohistory.net JST JSTdatasetR5.dta\" , \"e4691b8ac90e8d6947c65ae197841862ded27a00c167a578c38eccf4f73043ce\" register DataDep \"CEX Betrand Morse\", \"\", \"https dataverse.harvard.edu api access datafile 2781811?format tab&gbrecs true\" , checksum Union String,Vector String ... , Optional, if not provided will generate end import StatFiles function get macro history DataFrame StatFiles.load joinpath datadep\"MacroHistory\", \"JSTdatasetR5.dta\" end chain get macro history begin subset country ∈ \"USA\", \"Germany\" , \"Netherlands\" select \"nominal interest short \" stir, \"nominal interest long \" ltrate, \"debt to GDP\" tloans gdp, \"real house prices\" hpnom cpi, \"household debt to GDP\" thh gdp, year, country stack Not year, country subset ismissing value data mapping year, value, layout variable, color country visual Lines draw facet linkyaxes false, end function get cex file joinpath datadep\"CEX Betrand Morse\", \"BertrandMorseTrickleCEXData.tab\" CSV.File file | DataFrame end const SCF YEARS 1989 3 2019 function get scf year assert year ∈ SCF YEARS str \"SCF year \" path datadep str str CSV.File joinpath path, \"SCFP year .csv\" | DataFrame end chain get scf 2019 begin transform q nw bycol cut NETWORTH, weights WGT , 5 stack ASSET, FIN, NFIN, HOUSES, STOCKS , WGT, q nw groupby q nw, variable combine value mean value, weights WGT unstack variable, value stack Not q nw, ASSET transform value value ASSET data mapping q nw \"net worth quantile poor to rich \", value \"share of total assets\", color variable \"\" visual Lines draw legend position top, titleposition left end chain get scf 2019 begin transform q nw bycol cut NETWORTH, weights WGT , 5 stack DEBT, NH MORT, CCBAL , WGT, q nw groupby q nw, variable combine value mean value, weights WGT unstack variable, value stack Not q nw, DEBT transform value value DEBT data mapping q nw \"net worth quantile poor to rich \", value \"share of total debt\", color variable \"\" visual Lines draw legend position top, titleposition left end scf df let scf vec map get scf, SCF YEARS vcat scf vec..., cols union, source year SCF YEARS end chain scf df begin groupby year combine homeownership mean HHOUSES, weights WGT data mapping year, homeownership visual ScatterLines draw end summaries chain scf df begin select NETWORTH, INCOME, annual income WAGEINC, DEBT, NH MORT, HHOUSES, HOUSES, WGT, ASSET, year transform tenure HHOUSES 1 ? \"owner\" \"renter\" stack Not year, WGT, tenure groupby tenure, variable, year combine value mean value, weights WGT , WGT sum WGT aside total chain begin groupby variable, year combine value mean value, weights WGT transform tenure \"combined\" end select Not WGT vcat , total unstack variable, value select year, tenure, ph2y HOUSES annual income, \"mortage to income\" NH MORT annual income, leverage NH MORT HOUSES, \"debt to income\" DEBT annual income, nw2y NETWORTH annual income, ph2a HOUSES ASSET end chain summaries begin stack Not year, tenure data mapping year, value, color tenure \"\", layout variable visual Lines draw facet linkyaxes false, , legend position top, titleposition left end cex get cex names cex chain cex begin select state, year, weight, housingtype, last renteqhome99 subset ismissing last renteqhome99 end md\"\"\" Other \"\"\" TableOfContents begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end "},{"url":"preliminaries/rbc-to-imrohoroglu/","title":"RBC & Imrohoroglu (1989) as Markov Chains","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 2 section 2 order 2 title \"RBC & Imrohoroglu 1989 as Markov Chains\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using SparseArrays using QuantEcon using Chain, DataFrameMacros using CairoMakie using AlgebraOfGraphics using AlgebraOfGraphics draw using StatsBase using PlutoUI using PlutoUI Slider using DataFrames using LaTeXStrings md\"\"\" `rbc to imrohoroglu.jl` | Version 0.1 | last updated May 2 2023 \"\"\" md\"\"\" Introduction \"\"\" md\"\"\" 1. Recap Finite State Markov Chains \"\"\" ╠═╡ mc MarkovChain 0.5 0.1 0.4 0.1 0.4 0.5 0.3 0.3 0.4 , \"unemployed\", \"employed\", \"other\" ╠═╡ mc tauchen 20, 0.9, 1.0 simulate mc, 10 N length mc.state values I 1000 T 10 sim df mapreduce vcat, 1 I do i DataFrame i, t 1 T, state simulate mc, T end md\"\"\" Tracking individuals \"\"\" chain sim df begin subset i 4 subset i % 50 0 data mapping t L\"time t \", state \"state e.g. income \", color i nonnumeric visual ScatterLines mapping t naive visual VLines draw axis title \"Sample paths of selected agents\", end blue Makie.wong colors 1 md\"\"\" Tracking the whole distribution \"\"\" md\"\"\" ... in a naive way \"\"\" bind t naive Slider 1 10, default 1, show value true chain sim df begin aside begin bins sort unique .state end subset t t naive data mapping state visual Hist bins, color blue, normalization probability draw end let fig Figure chain sim df begin subset t % 10 1 aside begin xtick labels string. sort unique .t xticks collect 1 length xtick labels , xtick labels xlabel L\"time t \" ylabel \"cross sectional distribution\" axis xticks, xlabel, ylabel bins sort unique sim df.state end data mapping state, color t t naive , nonnumeric, offset t nonnumeric visual Hist bins, direction x, normalization probability, scale to 0.6 draw fig 1,1 , axis end fig end md\"\"\" ... in a more sophisticated way assuming a continuum of agents \"\"\" π₀ fill 1 N, N initial distribution bind t soph Slider 0 100, default 0, show value true barplot mc.state values, vec π₀' mc.p^ t soph , axis title latexstring \"Cross sectional distribution at \\ t t soph \\ \" let fig Figure ax Axis fig 1,1 , xlabel L\"time t \", ylabel \"cross sectional distribution\" for t ∈ 0 10 barplot ax, mc.state values, vec π₀' mc.p^t . 4, direction x, offset t, color t t soph ? Makie.wong colors 1 gray40 end fig end md\"\"\" 2. The RBC Model A Sample Path of a Markov Chain \"\"\" md\"\"\" Set up the Dynamic Program \"\"\" z chain MarkovChain 0.75 0.25 0.25 0.75 , 1.25, 0.75 r 0.02 q r 1 1 r prices q q r , w 1.0, Δr r 2 md\"\"\" Solution is a Markov Chain \"\"\" md\"\"\" 3. Bewley Huggett Aiyagari Tracking the Distribution of a Markov Chain warning \"Note\" We are not solving for the equilibrium interest rate ``r`` here. So we are in Partial Equilibrium setting of Imrohoroglu 1989 . \"\"\" md\"\"\" Specify initial distribution \"\"\" bind t soph ddp Slider 0 100, default 0, show value true md\"\"\" Appendix \"\"\" function Household σ 1.0, β 0.96, u σ 1 ? log x x^ 1 σ 1 1 σ β, u end hh Household σ 2.0, β 0.96 function statespace k vals range 1e 10, 20.0, length 200 , z chain states k, z for k ∈ k vals, z ∈ z chain.state values | vec states indices k i, z i for k i ∈ 1 length k vals , z i ∈ 1 length z chain.state values | vec policies k next for k next ∈ k vals | vec policies indices k next i for k next i ∈ 1 length k vals | vec states, states indices, policies, policies indices, z chain end ss statespace k vals range 1., 5., length 200 , z chain states DataFrame ss.states policies DataFrame ss.policies N ddp length ss.states π₀ ddp fill 1 N ddp, N ddp function setup Q Q, states indices, policies indices, z chain for i next state, next ∈ enumerate states indices for i policy, k next i ∈ enumerate policies indices for i state, z i ∈ enumerate states indices if next.k i k next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end function consumption z, k , k next , q, w, Δr if k next 0 && Δr 0 r 1 q 1 k next 0 Δr q 1 1 r end c w z k q k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, policies, prices, u for k i, policy ∈ enumerate policies for s i, state ∈ enumerate states R s i, k i reward state, policy, prices, u end end return R end function setup R states, policies, prices, u R zeros length states , length policies setup R R, states, policies, prices, u end function setup DDP household, statespace, prices β, u household states, policies, states indices, policies indices statespace R setup R states, policies, prices, u Q setup Q states indices, policies indices, z chain DiscreteDP R, Q, β end ddp setup DDP hh, ss, prices results QuantEcon.solve ddp, PFI mc ddp results.mc mc ddp.p | sparse path0 simulate mc ddp, 100 let fig Figure resolution 800, 400 path DataFrame ss.states path0 lines fig 1,1 , path.k, axis title \"evolution of capital\", xlabel \"time\" lines fig 1,2 , path.z, axis title \"evolution of productivity\", xlabel \"time\" fig end barplot mc.state values, vec π₀ ddp' mc ddp.p^ t soph ddp , axis title latexstring \"Cross sectional distribution at \\ t t soph ddp \\ \" let fig Figure ax Axis fig 1,1 , xlabel L\"time t \", ylabel \"cross sectional distribution\" for t ∈ 0 10 barplot ax, mc.state values, vec π₀ ddp' mc ddp.p^t . 70, direction x, offset t, color t t soph ddp ? Makie.wong colors 1 gray40 end fig end function solve details0 ddp, states, policies solver PFI results QuantEcon.solve ddp, solver df DataFrame states DataFrame policies results.sigma df.state states df.policy policies results.sigma df.π stationary distributions results.mc , 1 1 df end function solve details ddp, states, policies solver PFI df solve details0 ddp, states, policies solver chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end end md\"\"\" Packages \"\"\" TableOfContents "},{"url":"tutorials/continuous-time-moll-solution/","title":"Tutorial 3A (Solution)","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 6 order 6.5 title \"Tutorial 3A Solution \" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils using PlutoUI using AlgebraOfGraphics, CairoMakie using Parameters using LinearAlgebra using SparseArrays using DataFrames using Chain chain using Roots find zero, Brent md\"\"\" `continuous time moll solution.jl` | Version 1.1 | last updated May 2, 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" Huggett model in continuous time In this notebook, we consider a Huggett economy in continuous time. Income follows a Poisson process. More information on the algorithms can be found in the Online Appendix of Achdou et al. 2021 https benjaminmoll.com wp content uploads 2020 02 HACT Numerical Appendix.pdf . The Julia code in this notebook follows the closely the Matlab code snippets https benjaminmoll.com codes that Ben Moll uploaded on his website. Warning The code is not particularly robust to changes in the parameters. If you change one model parameter and get an error message, it sometimes helps to increase the maximum asset value on the grid. \"\"\" md\"\"\" Two income states \"\"\" md\"\"\" Model \"\"\" with kw struct HuggettPoisson2 σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference N z 2 z Matrix Float64 0.1 0.2 income states row vector λ Matrix Float64 0.02 0.03 intensities row vector asset grid parameters N a Int64 500 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1.5 da Float64 aₘₐₓ aₘᵢₙ N a 1 end md\"\"\" We work with an equi spaced asset grid with N a grid points. The difference between two grid points is denoted by \\Delta a . Section 7 in the online appendix explains how to deal with non uniform grids. \"\"\" function construct a m N a, aₘᵢₙ, aₘₐₓ m aᵢ for aᵢ in range aₘᵢₙ, aₘₐₓ, N a | hcat asset grid column vector end md\"\"\" HJB equation implicit method \"\"\" md\"\"\" \\rho v 1 a \\max c u c v 1' a z 1 ra c \\lambda 1 v 2 a v 1 a \\rho v 2 a \\max c u c v 2' a z 2 ra c \\lambda 2 v 1 a v 2 a \"\"\" md\"\"\" Algorithm Notation v i,j is short hand notation for v j a i . Start with an initial guess for the value function v i,j ^0 . A natural choice is v i,j ^0 \\frac u z j ra i \\rho . For n 1, ... maxit 1 Approximate v i,j ^n ' , j 1,2 using a finite difference method Notation Superscript n is omitted. forward difference v i,j,F ' \\frac v i 1,j v i,j \\Delta a backward diffrence v i,j,B ' \\frac v i,j v i 1,j \\Delta a The state constraint a \\ge a \\text min needs to be enforced by setting v' 1,j,B u' z j ra \\text min . savings according to forward difference s i,j,F z j ra i u' ^ 1 v' i,j,F savings according to backward difference s i,j,B z j ra i u' ^ 1 v' i,j,B The finite difference approximation of v i,j ^n ' is v' i,j v' i,j,F 1 s i,j,F 0 v' i,j,B 1 s i,j,B 0 \\bar v i,j 1 s i,j,F \\le 0 \\le s i,j,B where \\bar v i,j u' s j r a i . We assume concavity of the value function here so that the case s i,j,F 0 and s i,j,B 0 cannot occur. 2 Compute the consumption policy implied by the value function c i,j ^n u' ^ 1 v i,j ^n ' 3 Find updated value function v^ n 1 ```math \\begin align &\\frac v i,j ^ n 1 v i,j ^ n \\Delta \\rho v i,j ^ n 1 \\\\ &u c i,j ^n v i,j,F ^ n 1 ' \\underbrace z j ra i c i,j,F ^n s i,j,F ^n ^ v i,j,B ^ n 1 ' \\underbrace z j ra i c i,j,B ^n s i,j,B ^n ^ \\lambda j v i, j ^ n 1 v i,j ^ n 1 \\end align ``` where \\Delta is the step size. This is a system of 2N a linear equations. Since v^ n 1 is implicitly defined by the equations above, this approach is referred to as the implicit method. The system of equations can be written in matrix notation as \\frac 1 \\Delta v^ n 1 v^n \\rho v^ n 1 u^n A^n v^ n 1 The 2N a \\times 2N a matrix A^n can be written as a sum of two matrices \\bar A ^n and A \\text switch A^n \\bar A ^n A \\text switch \\begin pmatrix \\bar A 11 ^n & 0 \\\\ 0 & \\bar A 22 ^n \\end pmatrix \\begin pmatrix \\lambda 1 I & \\lambda 1 I \\\\ \\lambda 2 I & \\lambda 2 I \\end pmatrix where I is a N a \\times N a identity matrix. Since A \\text switch stays unchanged, it can be pre computed outside the for loop. The N a \\times N a submatrices \\bar A 11 ^n and \\bar A 22 ^n are tri diagonal The 1 diagonal is filled with x i,j \\frac s^n i,j,B ^ \\Delta a , i 2, \\dots N a The main diagonal is filled with y i,j \\frac s^n i,j,F ^ \\Delta a \\frac s^n i,j,B ^ \\Delta a , i 1, \\dots N a The 1 diagonal is filled with z i,j \\frac s^n i,j,F ^ \\Delta a , i 1, \\dots N a 1 Since A^n is a sparse matrix, computers can solve the system of linear equations quickly even for large N a . 4 Stop if v^ n 1 is close enough to v^n . \"\"\" function solve HJB implicit m HuggettPoisson2, r maxit 100, crit 1e 6, Δ 1000 σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 precompute A switch matrix id sparse I, N a, N a A switch 1 hcat λ 1 id, λ 1 id A switch 2 hcat λ 2 id, λ 2 id A switch vcat A switch 1, A switch 2 initial guess for value function v₀ zeros N a, 2 for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit STEP 1 forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 STEP 2 c dv upwind .^ 1 σ u c.^ 1 σ 1 σ STEP 3 X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da A11 spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 0 Y ,2 , 1 Z 1 N a 1,2 A1 hcat A11, spzeros N a, N a A2 hcat spzeros N a, N a , A22 A vcat A1, A2 A switch B ρ 1 Δ sparse I, 2 N a, 2 N a A b vec u vec v Δ v new stacked B \\ b v new reshape v new stacked, N a, 2 STEP 4 v change v new v dist it maximum abs. v change v v new if dist it crit ȧ z . r. a c return v, c, ȧ, A, it, dist end end error \"Algorithm did not converge\" end md\"\"\" KF equation \"\"\" md\"\"\" 0 \\frac d da s 1 a g 1 a \\lambda 1 g 1 a \\lambda 2 g 2 a 0 \\frac d da s 2 a g 2 a \\lambda 2 g 2 a \\lambda 1 g 1 a where s j a z j ra c j a 1 \\int \\bar a ^\\infty g 1 a da \\int \\bar a ^\\infty g 2 a da Algorithm A finite difference approximation of the KF equation results into the matrix equation A^T g 0 where A is the matrix from implicit algorithm for the HJB equation. \"\"\" md\"\"\" Putting everything together \"\"\" m HuggettPoisson2 md\"\"\" Equilibrium interest rate \"\"\" md\"\"\" 0 \\int \\bar a ^\\infty ag 1 a da \\int \\bar a ^\\infty ag 2 a da S r \"\"\" initial bracket 0.01, 0.03 md\"\"\" Three income states \"\"\" md\"\"\" Model \"\"\" md\"\"\" In the case of 2 income states, we represented the intensities of the Poisson process as a vector \\lambda \\lambda 1, \\lambda 2 where \\lambda j is the rate at which agents leave income state j and switch to the other income state. An alternative representation would be a matrix \\Lambda \\begin pmatrix \\lambda 1 & \\lambda 1 \\\\ \\lambda 2 & \\lambda 2 \\end pmatrix In the case of 3 income states, the matrix representation becomes more convenient \\Lambda \\begin pmatrix \\lambda 12 \\lambda 13 & \\lambda 12 & \\lambda 13 \\\\ \\lambda 21 & \\lambda 21 \\lambda 23 & \\lambda 23 \\\\ \\lambda 31 & \\lambda 32 & \\lambda 31 & \\lambda 32 \\end pmatrix where \\lambda jk is the rate at which agents in state j switch to state k . \"\"\" with kw struct HuggettPoisson3 σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference N z 3 z Matrix Float64 0.1 0.15 0.2 income states row vector Λ Matrix Float64 0.06 0.04 0.02 0.02 0.04 0.02 0.02 0.04 0.06 assert all abs. sum Λ dims 2 . 1e 12 asset grid parameters N a Int64 500 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1. da Float64 aₘₐₓ aₘᵢₙ N a 1 end md\"\"\" Exercise 1 HJB equation \"\"\" md\"\"\" 👉 Write down the system of HJB equations for the case of 3 income states. \"\"\" md\"\"\" Version 1 \\rho v j a \\max c u c v j' a z j ra c \\sum k 1 ^3 \\Lambda j,k v k a Version 2 \\rho v j a \\max c u c v j' a z j ra c \\sum k\\neq j \\lambda j,k v k a v j a for j 1,2,3 \"\"\" md\"\"\" 👉 How does the matrix A^n look like for 3 income states? \"\"\" md\"\"\" ```math \\begin align A^n \\begin pmatrix \\bar A 11 ^n & 0 & 0 \\\\ 0 & \\bar A 22 ^n & 0 \\\\ 0 & 0 & \\bar A 33 ^n \\end pmatrix \\begin pmatrix \\lambda 12 \\lambda 13 I & \\lambda 12 I & \\lambda 13 I \\\\ \\lambda 21 I & \\lambda 21 \\lambda 23 I & \\lambda 23 I \\\\ \\lambda 31 I & \\lambda 32 I & \\lambda 31 \\lambda 32 I \\end pmatrix \\end align ``` \"\"\" md\"\"\" 👉 Adapt the algorithm for solving the HJB equation so that it can deal with 3 income states. Writing separate algorithms for 2 and 3 income states is of course not very elegant from a programming perspective, but it hopefully helps you to understand the algorithm in Achdou et al. better. \"\"\" function solve HJB implicit m HuggettPoisson3, r maxit 100, crit 1e 6, Δ 1000 σ, ρ, z, Λ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, 3 dvb zeros N a, 3 precompute A switch matrix id sparse I, N a, N a A switch 1 hcat Λ 1,1 id, Λ 1,2 id, Λ 1,3 id A switch 2 hcat Λ 2,1 id, Λ 2,2 id, Λ 2,3 id A switch 3 hcat Λ 3,1 id, Λ 3,2 id, Λ 3,3 id A switch vcat A switch 1, A switch 2, A switch 3 initial guess for value function v₀ zeros N a, 3 for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit STEP 1 forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 STEP 2 c dv upwind .^ 1 σ u c.^ 1 σ 1 σ STEP 3 X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da zero spzeros N a, N a A11 spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 0 Y ,2 , 1 Z 1 N a 1,2 A33 spdiagm 1 X 2 N a,3 , 0 Y ,3 , 1 Z 1 N a 1,3 A1 hcat A11, zero, zero A2 hcat zero, A22, zero A3 hcat zero, zero, A33 A vcat A1, A2, A3 A switch B ρ 1 Δ sparse I, 3 N a, 3 N a A b vec u vec v Δ v new stacked B \\ b v new reshape v new stacked, N a, 3 STEP 4 v change v new v dist it maximum abs. v change v v new if dist it crit ȧ z . r. a c return v, c, ȧ, A, it, dist end end error \"Algorithm did not converge\" end md\"\"\" Results \"\"\" m3 HuggettPoisson3 initial bracket3 0.01, 0.03 md\"\"\" N z income states \"\"\" md\"\"\" Model \"\"\" with kw struct HuggettPoissonN σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference N z Int64 4 z Matrix Float64 0.1 0.13 0.17 0.2 income states row vector Λ Matrix Float64 0.07 0.04 0.02 0.01 0.02 0.05 0.02 0.01 0.01 0.02 0.05 0.02 0.01 0.02 0.04 0.07 assert all abs. sum Λ dims 2 . 1e 12 asset grid parameters N a Int64 500 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1.5 da Float64 aₘₐₓ aₘᵢₙ N a 1 end md\"\"\" Exercise 2 HJB equation optional \"\"\" md\"\"\" 👉 Adapt the algorithm for solving the HJB equation so that it can deal with an arbitrary number N z of income states. \"\"\" function solve HJB implicit m HuggettPoissonN, r maxit 100, crit 1e 6, Δ 1000 σ, ρ, N z, z, Λ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, N z dvb zeros N a, N z precompute A switch matrix id sparse I, N a, N a A switch rows hcat Λ j,k id for k in range 1,N z ... for j in range 1,N z A switch vcat A switch rows... initial guess for value function v₀ zeros N a, N z for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit STEP 1 forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 STEP 2 c dv upwind .^ 1 σ u c.^ 1 σ 1 σ STEP 3 X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da A bar blockdiag spdiagm 1 X 2 N a,j , 0 Y ,j , 1 Z 1 N a 1,j for j in range 1,N z ... A A bar A switch B ρ 1 Δ sparse I, N z N a, N z N a A b vec u vec v Δ v new stacked B \\ b v new reshape v new stacked, N a, N z STEP 4 v change v new v dist it maximum abs. v change v v new if dist it crit ȧ z . r. a c return v, c, ȧ, A, it, dist end end error \"Algorithm did not converge\" end t impl elapsed solve HJB implicit m, 0.03 md\"\"\" Results \"\"\" mN HuggettPoissonN initial bracketN 0.01, 0.035 md\"\"\" Appendix \"\"\" md\"\"\" HJB equation explicit method \"\"\" md\"\"\" Basic dea Start with some initial guess v i,j ^0 and update v i,j ^n as follows \\frac v i,j ^ n 1 v i,j ^n \\Delta \\rho v i,j ^n u c i,j ^n v i,j ^n ' z j ra i c i,j ^n \\lambda i v i, j ^n v i,j ^n In contrast to the implicit method, we can rearrange for v i,j ^ n 1 in the equation above. The disadvantage of the explicit method is that it converges only if \\Delta is not too large. \"\"\" function solve HJB explicit m HuggettPoisson2, r maxit 100000, crit 1e 6 σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 initial guess for value function v₀ zeros N a, 2 for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit step size for updating the value function Δ .9 da z 2 . r. aₘₐₓ for it in range 1, maxit forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 c dv upwind .^ 1 σ ȧ z . r. a c v switch zeros N a, 2 v switch ,2 v ,1 v switch ,1 v ,2 HJB equation v change c.^ 1 σ 1 σ dv upwind . ȧ ones N a,1 λ. v switch v ρ v updating the value function v , v Δ v change dist it maximum abs. v change if dist it crit return v, c, ȧ, it, dist end end error \"Algorithm did not converge\" end t expl elapsed solve HJB explicit m, 0.03 crit 1e 6 md\"\"\" Implicit vs. explicit method \"\"\" md\"\"\" Implicit method \"\"\" md\"\"\" Explicit method \"\"\" md\"\"\" Helper functions \"\"\" HuggettPoisson Union HuggettPoisson2, HuggettPoisson3, HuggettPoissonN function solve KF m HuggettPoisson, A N a, da, N z m AT transpose A b zeros N z N a, 1 i fix 1 b i fix .1 AT i fix, hcat zeros 1, i fix 1 , 1., zeros 1,N z N a i fix g stacked AT\\b g sum sum g stacked da g stacked norm g stacked . g sum assert sum g stacked norm da ≈ 1 g reshape g stacked norm, N a, N z end function results to df m HuggettPoisson v, c, ȧ, g nothing N a, N z, z m a construct a m df DataFrame df.a a ones 1, N z | vec df.z ones N a, 1 z | vec df.c c | vec df.ȧ ȧ | vec df.v v | vec if isnothing g df.g g | vec end df end function solve df m HuggettPoisson, r maxit 100, crit 1e 6, Δ 1000 v, c, ȧ, A, it last, dist solve HJB implicit m, r maxit, crit, Δ g solve KF m, A df results to df m v, c, ȧ, g return df, it last, dist end df, it last, dist solve df m, 0.03 maxit 100 let df.g max min. df.g,df.g 2 do not show the point mass at the borrowing constraint chain df begin stack Not a, z, g data mapping a, value, layout variable, color z nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end end let df dist DataFrame iteration range 1, it last , time range 0, t impl, it last , log10 dist log10. dist 1 it last figure resolution 500, 250 chain df dist begin data mapping time, log10 dist visual Lines draw figure end end function excess demand m HuggettPoisson, r maxit 100, crit 1e 6, Δ 1000 da m df, it last, dist solve df m, r maxit, crit, Δ A dot df.a, df.g da end r eq find zero r excess demand m, r , initial bracket, Brent r eq3 find zero r excess demand m3, r , initial bracket3, Brent r eqN find zero r excess demand mN, r , initial bracketN, Brent df3, it last3, dist3 solve df m3, r eq3 let df3.g max min. df3.g, df3.g 2 do not show the point mass at the borrowing constraint chain df3 begin stack Not a, z, g data mapping a, value, layout variable, color z nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end end dfN, it lastN, distN solve df mN, r eqN let dfN.g max min. dfN.g, dfN.g 1 5 do not show the point mass at the borrowing constraint chain dfN begin stack Not a, z, g data mapping a, value, layout variable, color z nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end end function solve explicit df m HuggettPoisson2, r maxit 100000, crit 1e 6 v, c, ȧ, it last, dist solve HJB explicit m, r maxit, crit df results to df m v, c, ȧ return df, it last, dist end df expl, it last expl, dist expl solve explicit df m, 0.03 crit 1e 6 df expl , c, ȧ, v . df , c, ȧ, v let df dist DataFrame iteration range 1, it last expl , time range 0, t expl, it last expl , log10 dist log10. dist expl 1 it last expl figure resolution 500, 250 chain df dist begin data mapping time, log10 dist visual Lines draw figure end end md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"tutorials/continuous-time-moll/","title":"Tutorial 3A","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 6 order 6 title \"Tutorial 3A\" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils using PlutoUI using AlgebraOfGraphics, CairoMakie using Parameters using LinearAlgebra using SparseArrays using DataFrames using Chain chain using Roots find zero, Brent md\"\"\" `continuous time moll.jl` | Version 1.1 | last updated May 2, 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" Huggett model in continuous time In this notebook, we consider a Huggett economy in continuous time. Income follows a Poisson process. More information on the algorithms can be found in the Online Appendix of Achdou et al. 2021 https benjaminmoll.com wp content uploads 2020 02 HACT Numerical Appendix.pdf . The Julia code in this notebook follows the closely the Matlab code snippets https benjaminmoll.com codes that Ben Moll uploaded on his website. Warning The code is not particularly robust to changes in the parameters. If you change one model parameter and get an error message, it sometimes helps to increase the maximum asset value on the grid. \"\"\" md\"\"\" Two income states \"\"\" md\"\"\" Model \"\"\" with kw struct HuggettPoisson2 σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference N z 2 z Matrix Float64 0.1 0.2 income states row vector λ Matrix Float64 0.02 0.03 intensities row vector asset grid parameters N a Int64 500 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1.5 da Float64 aₘₐₓ aₘᵢₙ N a 1 end md\"\"\" We work with an equi spaced asset grid with N a grid points. The difference between two grid points is denoted by \\Delta a . Section 7 in the online appendix explains how to deal with non uniform grids. \"\"\" function construct a m N a, aₘᵢₙ, aₘₐₓ m aᵢ for aᵢ in range aₘᵢₙ, aₘₐₓ, N a | hcat asset grid column vector end md\"\"\" HJB equation implicit method \"\"\" md\"\"\" \\rho v 1 a \\max c u c v 1' a z 1 ra c \\lambda 1 v 2 a v 1 a \\rho v 2 a \\max c u c v 2' a z 2 ra c \\lambda 2 v 1 a v 2 a \"\"\" md\"\"\" Algorithm Notation v i,j is short hand notation for v j a i . Start with an initial guess for the value function v i,j ^0 . A natural choice is v i,j ^0 \\frac u z j ra i \\rho . For n 1, ... maxit 1 Approximate v i,j ^n ' , j 1,2 using a finite difference method Notation Superscript n is omitted. forward difference v i,j,F ' \\frac v i 1,j v i,j \\Delta a backward diffrence v i,j,B ' \\frac v i,j v i 1,j \\Delta a The state constraint a \\ge a \\text min needs to be enforced by setting v' 1,j,B u' z j ra \\text min . savings according to forward difference s i,j,F z j ra i u' ^ 1 v' i,j,F savings according to backward difference s i,j,B z j ra i u' ^ 1 v' i,j,B The finite difference approximation of v i,j ^n ' is v' i,j v' i,j,F 1 s i,j,F 0 v' i,j,B 1 s i,j,B 0 \\bar v i,j 1 s i,j,F \\le 0 \\le s i,j,B where \\bar v i,j u' s j r a i . We assume concavity of the value function here so that the case s i,j,F 0 and s i,j,B 0 cannot occur. 2 Compute the consumption policy implied by the value function c i,j ^n u' ^ 1 v i,j ^n ' 3 Find updated value function v^ n 1 ```math \\begin align &\\frac v i,j ^ n 1 v i,j ^ n \\Delta \\rho v i,j ^ n 1 \\\\ &u c i,j ^n v i,j,F ^ n 1 ' \\underbrace z j ra i c i,j,F ^n s i,j,F ^n ^ v i,j,B ^ n 1 ' \\underbrace z j ra i c i,j,B ^n s i,j,B ^n ^ \\lambda j v i, j ^ n 1 v i,j ^ n 1 \\end align ``` where \\Delta is the step size. This is a system of 2N a linear equations. Since v^ n 1 is implicitly defined by the equations above, this approach is referred to as the implicit method. The system of equations can be written in matrix notation as \\frac 1 \\Delta v^ n 1 v^n \\rho v^ n 1 u^n A^n v^ n 1 The 2N a \\times 2N a matrix A^n can be written as a sum of two matrices \\bar A ^n and A \\text switch A^n \\bar A ^n A \\text switch \\begin pmatrix \\bar A 11 ^n & 0 \\\\ 0 & \\bar A 22 ^n \\end pmatrix \\begin pmatrix \\lambda 1 I & \\lambda 1 I \\\\ \\lambda 2 I & \\lambda 2 I \\end pmatrix where I is a N a \\times N a identity matrix. Since A \\text switch stays unchanged, it can be pre computed outside the for loop. The N a \\times N a submatrices \\bar A 11 ^n and \\bar A 22 ^n are tri diagonal The 1 diagonal is filled with x i,j \\frac s^n i,j,B ^ \\Delta a , i 2, \\dots N a The main diagonal is filled with y i,j \\frac s^n i,j,F ^ \\Delta a \\frac s^n i,j,B ^ \\Delta a , i 1, \\dots N a The 1 diagonal is filled with z i,j \\frac s^n i,j,F ^ \\Delta a , i 1, \\dots N a 1 Since A^n is a sparse matrix, computers can solve the system of linear equations quickly even for large N a . 4 Stop if v^ n 1 is close enough to v^n . \"\"\" function solve HJB implicit m HuggettPoisson2, r maxit 100, crit 1e 6, Δ 1000 σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 precompute A switch matrix id sparse I, N a, N a A switch 1 hcat λ 1 id, λ 1 id A switch 2 hcat λ 2 id, λ 2 id A switch vcat A switch 1, A switch 2 initial guess for value function v₀ zeros N a, 2 for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit STEP 1 forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 STEP 2 c dv upwind .^ 1 σ u c.^ 1 σ 1 σ STEP 3 X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da A11 spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 0 Y ,2 , 1 Z 1 N a 1,2 A1 hcat A11, spzeros N a, N a A2 hcat spzeros N a, N a , A22 A vcat A1, A2 A switch B ρ 1 Δ sparse I, 2 N a, 2 N a A b vec u vec v Δ v new stacked B \\ b v new reshape v new stacked, N a, 2 STEP 4 v change v new v dist it maximum abs. v change v v new if dist it crit ȧ z . r. a c return v, c, ȧ, A, it, dist end end error \"Algorithm did not converge\" end md\"\"\" KF equation \"\"\" md\"\"\" 0 \\frac d da s 1 a g 1 a \\lambda 1 g 1 a \\lambda 2 g 2 a 0 \\frac d da s 2 a g 2 a \\lambda 2 g 2 a \\lambda 1 g 1 a where s j a z j ra c j a 1 \\int \\bar a ^\\infty g 1 a da \\int \\bar a ^\\infty g 2 a da Algorithm A finite difference approximation of the KF equation results into the matrix equation A^T g 0 where A is the matrix from implicit algorithm for the HJB equation. \"\"\" md\"\"\" Putting everything together \"\"\" m HuggettPoisson2 md\"\"\" Equilibrium interest rate \"\"\" md\"\"\" 0 \\int \\bar a ^\\infty ag 1 a da \\int \\bar a ^\\infty ag 2 a da S r \"\"\" initial bracket 0.01, 0.03 md\"\"\" Three income states \"\"\" md\"\"\" Model \"\"\" md\"\"\" In the case of 2 income states, we represented the intensities of the Poisson process as a vector \\lambda \\lambda 1, \\lambda 2 where \\lambda j is the rate at which agents leave income state j and switch to the other income state. An alternative representation would be a matrix \\Lambda \\begin pmatrix \\lambda 1 & \\lambda 1 \\\\ \\lambda 2 & \\lambda 2 \\end pmatrix In the case of 3 income states, the matrix representation becomes more convenient \\Lambda \\begin pmatrix \\lambda 12 \\lambda 13 & \\lambda 12 & \\lambda 13 \\\\ \\lambda 21 & \\lambda 21 \\lambda 23 & \\lambda 23 \\\\ \\lambda 31 & \\lambda 32 & \\lambda 31 & \\lambda 32 \\end pmatrix where \\lambda jk is the rate at which agents in state j switch to state k . \"\"\" with kw struct HuggettPoisson3 σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference N z 3 z Matrix Float64 0.1 0.15 0.2 income states row vector Λ Matrix Float64 0.06 0.04 0.02 0.02 0.04 0.02 0.02 0.04 0.06 assert all abs. sum Λ dims 2 . 1e 12 asset grid parameters N a Int64 500 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1. da Float64 aₘₐₓ aₘᵢₙ N a 1 end md\"\"\" Exercise 1 HJB equation \"\"\" md\"\"\" 👉 Write down the system of HJB equations for the case of 3 income states. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 How does the matrix A^n look like for 3 income states? \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 Adapt the algorithm for solving the HJB equation so that it can deal with 3 income states. Writing separate algorithms for 2 and 3 income states is of course not very elegant from a programming perspective, but it hopefully helps you to understand the algorithm in Achdou et al. better. \"\"\" function solve HJB implicit m HuggettPoisson3, r maxit 100, crit 1e 6, Δ 1000 σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 precompute A switch matrix id sparse I, N a, N a A switch 1 hcat λ 1 id, λ 1 id A switch 2 hcat λ 2 id, λ 2 id A switch vcat A switch 1, A switch 2 initial guess for value function v₀ zeros N a, 2 for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit STEP 1 forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 STEP 2 c dv upwind .^ 1 σ u c.^ 1 σ 1 σ STEP 3 X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da A11 spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 0 Y ,2 , 1 Z 1 N a 1,2 A1 hcat A11, spzeros N a, N a A2 hcat spzeros N a, N a , A22 A vcat A1, A2 A switch B ρ 1 Δ sparse I, 2 N a, 2 N a A b vec u vec v Δ v new stacked B \\ b v new reshape v new stacked, N a, 2 STEP 4 v change v new v dist it maximum abs. v change v v new if dist it crit ȧ z . r. a c return v, c, ȧ, A, it, dist end end error \"Algorithm did not converge\" end md\"\"\" Results \"\"\" m3 HuggettPoisson3 initial bracket3 0.01, 0.03 r eq3 find zero r excess demand m3, r , initial bracket3, Brent df3, it last3, dist3 solve df m3, r eq3 let df3.g max min. df3.g, df3.g 2 do not show the point mass at the borrowing constraint chain df3 begin stack Not a, z, g data mapping a, value, layout variable, color z nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end end md\"\"\" N z income states \"\"\" md\"\"\" Model \"\"\" with kw struct HuggettPoissonN σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference N z Int64 4 z Matrix Float64 0.1 0.13 0.17 0.2 income states row vector Λ Matrix Float64 0.07 0.04 0.02 0.01 0.02 0.05 0.02 0.01 0.01 0.02 0.05 0.02 0.01 0.02 0.04 0.07 assert all abs. sum Λ dims 2 . 1e 12 asset grid parameters N a Int64 500 aₘᵢₙ Float64 0.1 aₘₐₓ Float64 1.5 da Float64 aₘₐₓ aₘᵢₙ N a 1 end md\"\"\" Exercise 2 HJB equation optional \"\"\" md\"\"\" 👉 Adapt the algorithm for solving the HJB equation so that it can deal with an arbitrary number N z of income states. \"\"\" function solve HJB implicit m HuggettPoissonN, r maxit 100, crit 1e 6, Δ 1000 σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 precompute A switch matrix id sparse I, N a, N a A switch 1 hcat λ 1 id, λ 1 id A switch 2 hcat λ 2 id, λ 2 id A switch vcat A switch 1, A switch 2 initial guess for value function v₀ zeros N a, 2 for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit STEP 1 forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 STEP 2 c dv upwind .^ 1 σ u c.^ 1 σ 1 σ STEP 3 X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da A11 spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 0 Y ,2 , 1 Z 1 N a 1,2 A1 hcat A11, spzeros N a, N a A2 hcat spzeros N a, N a , A22 A vcat A1, A2 A switch B ρ 1 Δ sparse I, 2 N a, 2 N a A b vec u vec v Δ v new stacked B \\ b v new reshape v new stacked, N a, 2 STEP 4 v change v new v dist it maximum abs. v change v v new if dist it crit ȧ z . r. a c return v, c, ȧ, A, it, dist end end error \"Algorithm did not converge\" end t impl elapsed solve HJB implicit m, 0.03 md\"\"\" Results \"\"\" mN HuggettPoissonN initial bracketN 0.01, 0.035 r eqN find zero r excess demand mN, r , initial bracketN, Brent dfN, it lastN, distN solve df mN, r eqN let dfN.g max min. dfN.g, dfN.g 1 5 do not show the point mass at the borrowing constraint chain dfN begin stack Not a, z, g data mapping a, value, layout variable, color z nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end end md\"\"\" Appendix \"\"\" md\"\"\" HJB equation explicit method \"\"\" md\"\"\" Basic dea Start with some initial guess v i,j ^0 and update v i,j ^n as follows \\frac v i,j ^ n 1 v i,j ^n \\Delta \\rho v i,j ^n u c i,j ^n v i,j ^n ' z j ra i c i,j ^n \\lambda i v i, j ^n v i,j ^n In contrast to the implicit method, we can rearrange for v i,j ^ n 1 in the equation above. The disadvantage of the explicit method is that it converges only if \\Delta is not too large. \"\"\" function solve HJB explicit m HuggettPoisson2, r maxit 100000, crit 1e 6 σ, ρ, z, λ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 initial guess for value function v₀ zeros N a, 2 for i, zᵢ in enumerate z v₀ ,i zᵢ . r a .^ 1 σ 1 σ ρ end v v₀ initialize vector that keeps track of convergence dist ones maxit step size for updating the value function Δ .9 da z 2 . r. aₘₐₓ for it in range 1, maxit forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, z . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, z . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf z . r . a cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb z . r . a cb consumption and derivate of value function at steady state c0 z . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state dv upwind dvf. If dvb. Ib dv0. I0 c dv upwind .^ 1 σ ȧ z . r. a c v switch zeros N a, 2 v switch ,2 v ,1 v switch ,1 v ,2 HJB equation v change c.^ 1 σ 1 σ dv upwind . ȧ ones N a,1 λ. v switch v ρ v updating the value function v , v Δ v change dist it maximum abs. v change if dist it crit return v, c, ȧ, it, dist end end error \"Algorithm did not converge\" end t expl elapsed solve HJB explicit m, 0.03 crit 1e 6 md\"\"\" Implicit vs. explicit method \"\"\" md\"\"\" Implicit method \"\"\" md\"\"\" Explicit method \"\"\" md\"\"\" Helper functions \"\"\" HuggettPoisson Union HuggettPoisson2, HuggettPoisson3, HuggettPoissonN function solve KF m HuggettPoisson, A N a, da, N z m AT transpose A b zeros N z N a, 1 i fix 1 b i fix .1 AT i fix, hcat zeros 1, i fix 1 , 1., zeros 1,N z N a i fix g stacked AT\\b g sum sum g stacked da g stacked norm g stacked . g sum assert sum g stacked norm da ≈ 1 g reshape g stacked norm, N a, N z end function results to df m HuggettPoisson v, c, ȧ, g nothing N a, N z, z m a construct a m df DataFrame df.a a ones 1, N z | vec df.z ones N a, 1 z | vec df.c c | vec df.ȧ ȧ | vec df.v v | vec if isnothing g df.g g | vec end df end function solve df m HuggettPoisson, r maxit 100, crit 1e 6, Δ 1000 v, c, ȧ, A, it last, dist solve HJB implicit m, r maxit, crit, Δ g solve KF m, A df results to df m v, c, ȧ, g return df, it last, dist end df, it last, dist solve df m, 0.03 maxit 100 let df.g max min. df.g,df.g 2 do not show the point mass at the borrowing constraint chain df begin stack Not a, z, g data mapping a, value, layout variable, color z nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end end let df dist DataFrame iteration range 1, it last , time range 0, t impl, it last , log10 dist log10. dist 1 it last figure resolution 500, 250 chain df dist begin data mapping time, log10 dist visual Lines draw figure end end function excess demand m HuggettPoisson, r maxit 100, crit 1e 6, Δ 1000 da m df, it last, dist solve df m, r maxit, crit, Δ A dot df.a, df.g da end r eq find zero r excess demand m, r , initial bracket, Brent function solve explicit df m HuggettPoisson2, r maxit 100000, crit 1e 6 v, c, ȧ, it last, dist solve HJB explicit m, r maxit, crit df results to df m v, c, ȧ return df, it last, dist end df expl, it last expl, dist expl solve explicit df m, 0.03 crit 1e 6 df expl , c, ȧ, v . df , c, ȧ, v let df dist DataFrame iteration range 1, it last expl , time range 0, t expl, it last expl , log10 dist log10. dist expl 1 it last expl figure resolution 500, 250 chain df dist begin data mapping time, log10 dist visual Lines draw figure end end md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"tutorials/mobility-aiyagari-solution/","title":"Tutorial 1 (Solution)","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 2 order 2.5 title \"Tutorial 1 Solution \" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils using PlutoUI TableOfContents using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using QuantEcon md\"\"\" `mobility aiyagari solution.jl` | Version 1.1 | last updated May 1 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" An extension of the Aiyagari model Introduction In this notebook, you are supposed to get more familiar with the ```QuantEcon``` framework by implementing and solving a model yourself. For this purpose, we consider an extension to the Aiyagari model in which individuals incur a cost when they accept a job offer with a higher salary for example because they have to move house. For simplicity consider two types of jobs with salaries z 1 and z 2 where z 1 z 2 . Agents with z 2 get fired and end up with z 1 with probability p 1 . Agents with z 1 receive job offers with the higher salary z 2 with probability p 2 . In order to accept an offer, an agent has to pay a moving cost \\xi . \"\"\" md\"\"\" Exercise 1 No borrowing constraint 👉 Assume for a moment that there is no borrowing constraint in the model. What condition needs to be satisfied so that agents will accept the job with the higher salary? \"\"\" md\"\"\" Answer In a model without a borrowing constraint, agents will always accept the job with the higher salary if the moving cost \\xi is lower than the additional income from accepting the job \\xi \\sum t 0 ^\\infty \\left \\frac 1 p 1 1 r \\right ^t z 2 z 1 \\frac 1 1 \\frac 1 p 1 1 r z 2 z 1 In particular, if there is no borrowing constraint, the decision whether to accept or not does not depend on wealth. \"\"\" md\"\"\" Model In the following, we consider an Aiyagari type model with a borrowing constraint k\\ge 0 and explore how the moving cost interacts with the borrowing constraint. We model the first year of the job with the high salary as a separate state because the moving cost only needs to be paid in the first period and hence we need to keep track of this information. Moreover, we exploit that paying a cost \\xi in the first period of the new job is mathematically equivalent to having a lower salary z 3 z 2 \\xi in the first period. V k, \\tilde z \\max k', z u c E V k', \\tilde z '|z \\text subject to 1 r \\cdot k z c k' where \\tilde z is the drawn job state and z is the chosen job state. Usually, z \\tilde z holds, i.e. the agent accepts the drawn state. The only exception is a job offer \\tilde z z 3 in which agents also have the option to reject and continue with the low salary z z 1 . All other \\tilde z , z combinations are forbidden. The transition matrix for future draws \\tilde z ' given the current state z is | | \\tilde z ' z 1 | \\tilde z ' z 2 | \\tilde z ' z 3 | | | | | | | z z 1 | 1 p 2 |0 | p 2 | | z z 2 | p 1 | 1 p 1 |0 | | z z 3 | p 1 | 1 p 1 |0 | This model formulation is not the most efficient one in terms of computation time because we always include all values of z as possible actions even though many \\tilde z , z combinations are not allowed. However, in this course we do not care much about computational efficiency and it is more important that the model is easy to implement. \"\"\" md\"\"\" Model parameters \"\"\" prices q 1 1 0.03 , w 1.0, Δr 0. p 1 0.2 p 2 0.3 z 1 1.0 z 2 1.2 z 3 0.5 z chain MarkovChain 1 p 2 0. p 2 p 1 1 p 1 0. p 1 1 p 1 0. , z 1, z 2, z 3 ξ z 2 z 3 ξ thresh 1 1 prices.q 1 p 1 z 2 z 1 md\"\"\" For the given parameters, the threshold value of the moving cost ξ for the case without a borrowing constraint is round ξ thresh, digits 3 . This means that for the value of ```ξ``` round ξ, digits 3 that is given above, an agent that does not face a borrowing constraint would always accept the job offer. \"\"\" md\"\"\" Solving the model \"\"\" function Household σ 1.0, β 0.96, u σ 1 ? log x x^ 1 σ 1 1 σ β, u end hh Household β 0.96, u log function statespace k vals range 1e 10, 20.0, length 200 , z chain n k length k vals n z length z chain.state values states k, z draw for k ∈ k vals, z draw ∈ z chain.state values | vec states indices k i, z draw i for k i ∈ 1 n k, z draw i ∈ 1 n z | vec policies k next, z for k next ∈ k vals, z ∈ z chain.state values | vec policies indices k next i, z i for k next i ∈ 1 n k, z i ∈ 1 n z | vec states, states indices, policies, policies indices, z chain end ss statespace k vals range 0., 2., length 250 , z chain md\"\"\" Exercise 2 Construct Q In the n \\times m \\times n array of transition probabilities Q , the array element Q ijk states the probability to be in state s' s k in the next period given the current state s s i and the action a a j . 👉 Complete the ```setup Q ``` function. \"\"\" function setup Q Q, states indices, policies indices, z chain for i next state, next state ∈ enumerate states indices for i pol, pol ∈ enumerate policies indices for i state, state ∈ enumerate states indices solution start if next state.k i pol.k next i Q i state, i pol, i next state z chain.p pol.z i, next state.z draw i end solution end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end md\"\"\" Exercise 3 Construct R In the n \\times m reward array R , the element R ij states the reward that is associated with the state s s i and the action a a j . You can forbid the agent to take certain actions by setting the associated reward to a very large negative number. 👉 Complete the ```setup R ``` function. \"\"\" function consumption k , k next, z , q, w, Δr if k next 0 && Δr 0 r 1 q 1 k next 0 Δr q 1 1 r end c w z k q k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, states indices, policies, policies indices, prices, u for p i, policy ∈ enumerate policies z i pol policies indices p i .z i for s i, state ∈ enumerate states z i state states indices s i .z draw i solution start if z i state z i pol R s i, p i reward state, policy, prices, u elseif z i state 3 && z i pol 1 R s i, p i reward state, policy, prices, u else R s i, p i 100 000 end solution end end end return R end function setup R states, states indices, policies, policies indices, prices, u R zeros length states , length policies setup R R, states, states indices, policies, policies indices, prices, u end function setup DDP household, statespace, prices β, u household states, policies, states indices, policies indices statespace R setup R states, states indices, policies, policies indices, prices, u Q setup Q states indices, policies indices, statespace.z chain DiscreteDP R, Q, β end ddp setup DDP hh, ss, prices md\"\"\" Analyzing the results \"\"\" md\"\"\" Exercise 4 Plot results 👉 Activate the two cells below as soon as you are sure that your Q and R arrays are correctly specified. \"\"\" begin results QuantEcon.solve ddp, PFI df DataFrame ss.states DataFrame ss.policies results.sigma df.state ss.states df.policy ss.policies results.sigma df.π stationary distributions results.mc , 1 1 df chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end end begin resolution 800, 900 fig Figure resolution ax1 Axis fig 1, 1 , title \"Consumption policy\" ax2 Axis fig 1, 2 , title \"Savings policy\" ax3 Axis fig 2, 1 , title \"Job state policy\" ax4 Axis fig 2, 2 , title \"Stationary distribution for z draw z 1\" ax5 Axis fig 3, 1 , title \"Stationary distribution for z draw z 2\" ax6 Axis fig 3, 2 , title \"Stationary distribution for z draw z 3\" plt1 data df mapping k, consumption, color z draw nonnumeric visual Lines plt2 data df mapping k, saving, color z draw nonnumeric visual Lines plt3 data df mapping k, z, color z draw nonnumeric visual Lines ag draw ax1, plt1 draw ax2, plt2 draw ax3, plt3 df groups groupby df, z draw for ax, df group in zip ax4, ax5, ax6 , df groups plt data df group mapping k, π visual Lines draw ax, plt end legend fig 4, 1 , ag, orientation horizontal, tellheight true fig end md\"\"\" Exercise 5 Discuss results 👉 What is interesting about the policy functions and the stationary distribution plotted above? Please write down your observations in the cell below. \"\"\" md\"\"\" Answer Let's only focus on ```z draw``` z 3 , i.e. the case in which the agent receives a good job offer with salary z 2 and has to decide whether to accept and pay the moving cost ξ z 2 z 3 or to stay in the bad job with salary z 1 . We find that the job acceptance decision depends on wealth If the agent has very few assets, she rejects the offer because does not want to sacrifice consumption in order to pay the moving cost. Moreover, we see that agents in the bad job save so that they are able to accept good offers without enduring one period of low consumption. \"\"\" md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"tutorials/mobility-aiyagari/","title":"Tutorial 1","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 2 order 2 title \"Tutorial 1\" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils using PlutoUI TableOfContents using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using QuantEcon md\"\"\" `mobility aiyagari.jl` | Version 1.1 | last updated May 1 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" An extension of the Aiyagari model Introduction In this notebook, you are supposed to get more familiar with the ```QuantEcon``` framework by implementing and solving a model yourself. For this purpose, we consider an extension to the Aiyagari model in which individuals incur a cost when they accept a job offer with a higher salary for example because they have to move house. For simplicity consider two types of jobs with salaries z 1 and z 2 where z 1 z 2 . Agents with z 2 get fired and end up with z 1 with probability p 1 . Agents with z 1 receive job offers with the higher salary z 2 with probability p 2 . In order to accept an offer, an agent has to pay a moving cost \\xi . \"\"\" md\"\"\" Exercise 1 No borrowing constraint 👉 Assume for a moment that there is no borrowing constraint in the model. What condition needs to be satisfied so that agents will accept the job with the higher salary? \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Model In the following, we consider an Aiyagari type model with a borrowing constraint k\\ge 0 and explore how the moving cost interacts with the borrowing constraint. We model the first year of the job with the high salary as a separate state because the moving cost only needs to be paid in the first period and hence we need to keep track of this information. Moreover, we exploit that paying a cost \\xi in the first period of the new job is mathematically equivalent to having a lower salary z 3 z 2 \\xi in the first period. V k, \\tilde z \\max k', z u c E V k', \\tilde z '|z \\text subject to 1 r \\cdot k z c k' where \\tilde z is the drawn job state and z is the chosen job state. Usually, z \\tilde z holds, i.e. the agent accepts the drawn state. The only exception is a job offer \\tilde z z 3 in which agents also have the option to reject and continue with the low salary z z 1 . All other \\tilde z , z combinations are forbidden. The transition matrix for future draws \\tilde z ' given the current state z is | | \\tilde z ' z 1 | \\tilde z ' z 2 | \\tilde z ' z 3 | | | | | | | z z 1 | 1 p 2 |0 | p 2 | | z z 2 | p 1 | 1 p 1 |0 | | z z 3 | p 1 | 1 p 1 |0 | This model formulation is not the most efficient one in terms of computation time because we always include all values of z as possible actions even though many \\tilde z , z combinations are not allowed. However, in this course we do not care much about computational efficiency and it is more important that the model is easy to implement. \"\"\" md\"\"\" Model parameters \"\"\" prices q 1 1 0.03 , w 1.0, Δr 0. p 1 0.2 p 2 0.3 z 1 1.0 z 2 1.2 z 3 0.5 z chain MarkovChain 1 p 2 0. p 2 p 1 1 p 1 0. p 1 1 p 1 0. , z 1, z 2, z 3 ξ z 2 z 3 ξ thresh 1 1 prices.q 1 p 1 z 2 z 1 md\"\"\" For the given parameters, the threshold value of the moving cost ξ for the case without a borrowing constraint is round ξ thresh, digits 3 . This means that for the value of ```ξ``` round ξ, digits 3 that is given above, an agent that does not face a borrowing constraint would always accept the job offer. \"\"\" md\"\"\" Solving the model \"\"\" function Household σ 1.0, β 0.96, u σ 1 ? log x x^ 1 σ 1 1 σ β, u end hh Household β 0.96, u log function statespace k vals range 1e 10, 20.0, length 200 , z chain n k length k vals n z length z chain.state values states k, z draw for k ∈ k vals, z draw ∈ z chain.state values | vec states indices k i, z draw i for k i ∈ 1 n k, z draw i ∈ 1 n z | vec policies k next, z for k next ∈ k vals, z ∈ z chain.state values | vec policies indices k next i, z i for k next i ∈ 1 n k, z i ∈ 1 n z | vec states, states indices, policies, policies indices, z chain end ss statespace k vals range 0., 2., length 250 , z chain md\"\"\" Exercise 2 Construct Q In the n \\times m \\times n array of transition probabilities Q , the array element Q ijk states the probability to be in state s' s k in the next period given the current state s s i and the action a a j . 👉 Complete the ```setup Q ``` function. \"\"\" function setup Q Q, states indices, policies indices, z chain for i next state, next state ∈ enumerate states indices for i pol, pol ∈ enumerate policies indices for i state, state ∈ enumerate states indices Your solution goes here ... ... end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end md\"\"\" Exercise 3 Construct R In the n \\times m reward array R , the element R ij states the reward that is associated with the state s s i and the action a a j . You can forbid the agent to take certain actions by setting the associated reward to a very large negative number. 👉 Complete the ```setup R ``` function. \"\"\" function setup R R, states, states indices, policies, policies indices, prices, u for p i, policy ∈ enumerate policies z i pol policies indices p i .z i for s i, state ∈ enumerate states z i state states indices s i .z draw i Your solution goes here ... ... end end return R end function setup R states, states indices, policies, policies indices, prices, u R zeros length states , length policies setup R R, states, states indices, policies, policies indices, prices, u end function consumption k , k next, z , q, w, Δr if k next 0 && Δr 0 r 1 q 1 k next 0 Δr q 1 1 r end c w z k q k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup DDP household, statespace, prices β, u household states, policies, states indices, policies indices statespace R setup R states, states indices, policies, policies indices, prices, u Q setup Q states indices, policies indices, statespace.z chain DiscreteDP R, Q, β end ddp setup DDP hh, ss, prices md\"\"\" Analyzing the results \"\"\" md\"\"\" Exercise 4 Plot results 👉 Activate the two cells below as soon as you are sure that your Q and R arrays are correctly specified. \"\"\" begin results QuantEcon.solve ddp, PFI df DataFrame ss.states DataFrame ss.policies results.sigma df.state ss.states df.policy ss.policies results.sigma df.π stationary distributions results.mc , 1 1 df chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end end begin resolution 800, 900 fig Figure resolution ax1 Axis fig 1, 1 , title \"Consumption policy\" ax2 Axis fig 1, 2 , title \"Savings policy\" ax3 Axis fig 2, 1 , title \"Job state policy\" ax4 Axis fig 2, 2 , title \"Stationary distribution for z draw z 1\" ax5 Axis fig 3, 1 , title \"Stationary distribution for z draw z 2\" ax6 Axis fig 3, 2 , title \"Stationary distribution for z draw z 3\" plt1 data df mapping k, consumption, color z draw nonnumeric visual Lines plt2 data df mapping k, saving, color z draw nonnumeric visual Lines plt3 data df mapping k, z, color z draw nonnumeric visual Lines ag draw ax1, plt1 draw ax2, plt2 draw ax3, plt3 df groups groupby df, z draw for ax, df group in zip ax4, ax5, ax6 , df groups plt data df group mapping k, π visual Lines draw ax, plt end legend fig 4, 1 , ag, orientation horizontal, tellheight true fig end md\"\"\" Exercise 5 Discuss results 👉 What is interesting about the policy functions and the stationary distribution plotted above? Please write down your observations in the cell below. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"tutorials/mpcs-aiyagari-solution/","title":"Assignment 1 (Solution)","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 1 order 1.5 title \"Assignment 1 Solution \" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils using NonparametricRegression using Statistics mean, median using StatsBase weights using Plots using PlutoUI TableOfContents using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using QuantEcon md\"\"\" `mpcs aiyagari solution.jl` | Version 1.1 | last updated May 2 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" MPCs in the Aiyagari model Households' problem In this exercise, we have a closer look at the marginal propensity to consume in a Aiyagari Huggett economy. The households' problem is ```math \\begin align &\\max c t, k t \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t u c t \\Bigr \\\\ &\\begin aligned \\text subject to &u c \\log c \\\\ &k t \\ge 0 \\\\ &c t k t k t 1 1 r y t \\cdot w\\\\ &y t \\sim \\text some Markov Chain \\\\ &y 0, k 1 \\text given \\end aligned \\end align ``` To be more precise, we are considering the MPC out of an unexpected transitory shock dx t that enters the budget constraint like this c t k t k t 1 1 r y t \\cdot w dx t \"\"\" md\"\"\" Exercise 1 Motivation 1 point 👉 Why do economists and policy makers care about the average MPC in the population and about MPC heterogeneity? Give at least 2 reasons. \"\"\" md\"\"\" Answer Direct transfers to individuals during recessions such as the Economic Impact Payments in the US are only an effective stimulus policy if the MPC of these individuals is high. MPCs are important for the effects of wide set of economic policies on consumption and output, e.g. tax reforms, government spending, and monetary policy. MPC heterogeneity matters if these policies affect some households more than others. Different consumption savings models make very different predictions about the average MPC and MPC heterogeneity. Therefore, empirical evidence can help to distinguish between competing theories. \"\"\" md\"\"\" Model parameters \"\"\" r 0.03 prices q 1 1 r , w 1.0 z chain MarkovChain 0.75 0.25 0.25 0.75 , 1.25, 0.75 k vals range 0., 5., length 500 md\"\"\" Exercise 2 No income risk 2 points As a first step, let's consider a more simple model without income risk and without the ad hoc borrowing constraint k t\\ge 0 . 👉 Derive an analytical formula for the MPC and plug in the model parameters given above. 👉 What can you say about the average MPC and MPC heterogeneity in this model? \"\"\" md\"\"\" Solution to the households' problem The case with income risk and the ad hoc borrowing constraint does not have an analytical solution. Therefore, we solve the households' problem using functions from the ```aiygari.jl``` notebook \"\"\" md\"\"\" The consumption policy that we obtain from the ```QuantEcon``` solver has small jumps. This is not an actual property of the policy function but happens because we have only solved a discretized version of the households' problem. You can check for yourself that the size of the jumps decreases as you increase the number of grid points. \"\"\" md\"\"\" Since we will use the slope of the policy function to analyze the MPC, the jumps are very inconvenient. Therefore, you will work with the smoothed version of the consumption policy which is saved in the ```c sm``` column of the ```results2``` data frame. \"\"\" md\"\"\" The figure below shows both the raw consumption function and its smoothed version \"\"\" md\"\"\" Exercise 3 MPCs in the Aiyagari model \"\"\" md\"\"\" 3a Compute MPCs 1.5 points 👉 Use the smoothed consumption policy to compute the MPC at each point of the state space. Save the MPC values in an additional column of the results data frame. Hint It is most convenient to consider a transitory income shock of the size dx 1 r \\Delta k where \\Delta k is the distance between two adjacent grid points. \"\"\" md\"\"\" The algorithm cannot compute the MPC at the right most grid point and sets it to zero. \"\"\" md\"\"\" 3b Average MPC 1 point 👉 What is the average MPC in the Aiyagari model for the given parameters? \"\"\" md\"\"\" 3c MPC heterogeneity 3 points 👉 Explore MPC heterogeneity in the Aiyagari model graphically. 👉 How much do MPCs vary in the population? Which households have particularly high MPCs? \"\"\" md\"\"\" Answer The histogram shows that the majority of households has an MPC of about 0.1. A considerable fraction of households has much higher MPCs close to 1. \"\"\" md\"\"\" The figure below shows the MPC as a function of assets and the income state. All high MPC households are in the low income state and at or close to the borrowing constraint k 0 . The wiggles in the MPC for high asset levels k\\ge 2 indicate that the bandwidth that we used for smoothing out the jumps is too small in this area of the state space. However, this does not matter much for our analysis of MPC heterogeneity because there are barely any households with k\\ge 2 . \"\"\" md\"\"\" Exercise 4 Outlook 1.5 points The empirical literature on MPCs typically finds average annual MPCs in the range 30 50% Jappelli and Pistaferri, 2014 https www.aeaweb.org articles?id 10.1257 mac.6.4.107 Fagereng et al., 2021 https www.aeaweb.org articles?id 10.1257 mac.20190211 Commault, 2022 https www.aeaweb.org articles?id 10.1257 mac.20190296 . Most empirical papers also find that households with little liquid wealth tend to have higher MPCs than households with a lot of liquid wealth. Models with income risk and a borrowing constraint like the one in Exercise 3 usually generate average annual MPCs lower than 30% if they are calibrated properly. 👉 Why are average MPCs in the data higher than in Aiyagari type models? Mention and explain at least 3 potential mechanisms that are not present in the model. \"\"\" md\"\"\" Answer Finite lifetimes can generate high MPCs among old households who do not have a strong bequest motive. A lot of wealth is illiquid, i.e. it can only be accessed if a transaction cost is paid housing or not all all pension wealth for young people . These illiquid assets typically pay higher returns than liquid assets. Therefore, many wealthy households might hold little liquid wealth and behave similarly to households who do not have any wealth at all. Kaplan and Violante, 2014 https onlinelibrary.wiley.com doi abs 10.3982 ECTA10528 In the model that we studied above, households end up in the low asset high MPC state solely due to bad luck. Preference heterogeneity might be an alternative mechanism since households that are impatient or have a high intertemporal elasticity of substition tend to have higher MPCs and less wealth than their peers. Gelman, 2021 https www.sciencedirect.com science article pii S0304393220300350 Aguiar et al., 2021 https www.nber.org papers w26643 Re computing the optimal consumption path after a small transitory income shock is a difficult task. Households may decide to follow a more simple rule e.g. spend small windfall gains completely if the associated utility loss is small compared to the computational cost of smoothing consumption. Reis, 2005 https www.sciencedirect.com science article pii S0304393206001401 Kueng, 2018 https academic.oup.com qje article 133 4 1693 5036538?login true Hyperbolic discounting is another potential mechanism that can generate a high average MPC, possibly combined with illiquid assets Since rational households are aware of their present bias, they use the illiquid asset as a commitment technology to guard against over consumption arising from time inconsistent preferences. Laibson, 1997 https academic.oup.com qje article 112 2 443 1870925?login true \"\"\" md\"\"\" Before you submit ... 👉 Make sure you do not mention your name in the assignment. The assignments are graded anonymously. 👉 Make sure that that all group members proofread your submission. 👉 Make sure all the code is well documented . 👉 Make sure that you are within the word limit . Short and concise answers are appreciated. Answers longer than the word limit will lead to deductions. 👉 Go to the very top of the notebook and click on the symbol in the very top right corner. Export a static html file of this notebook for submission. The source code is embedded in the html file. \"\"\" md\"\"\" Appendix Functions from ```aiyagari.jl``` The only difference to ```aiyagari.jl``` is that I made some changes to the ```consumption``` function. \"\"\" function Household σ 1.0, β 0.96, u σ 1 ? log x x^ 1 σ 1 1 σ β, u end hh Household β 0.96, u log md\"\"\" Answer Intertemporal optimization \\frac 1 c t \\beta 1 r \\frac 1 c t 1 \\implies c t k \\beta^k 1 r ^k c t Intertemporal budget constraint \\underbrace 1 r k t 1 w\\sum k 0 ^ \\infty \\frac y t k 1 r ^k W t \\sum k 0 ^ \\infty \\frac c t k 1 r ^k Combining both equations W t c t \\sum k 0 ^\\infty \\beta^k \\frac 1 1 \\beta c t \\implies c t 1 \\beta W t MPC \\frac dc t dx t \\frac dc t dW t 1 \\beta For the value of \\beta given in the exercise, the model without income risk implies a very low MPC of round 1 hh.β ,digits 4 for all households regardless of wealth or income. Note that this result does not require income w y t to be constant over time or over individuals The only necessary assumption is that there is no income risk. \"\"\" function statespace k vals range 1e 10, 20.0, length 200 , z chain states k, z for k ∈ k vals, z ∈ z chain.state values | vec states indices k i, z i for k i ∈ 1 length k vals , z i ∈ 1 length z chain.state values | vec policies k next for k next ∈ k vals | vec policies indices k next i for k next i ∈ 1 length k vals | vec states, states indices, policies, policies indices, z chain end ss statespace k vals, z chain function setup Q Q, states indices, policies indices, z chain for i next state, next ∈ enumerate states indices for i policy, k next i ∈ enumerate policies indices for i state, z i ∈ enumerate states indices if next.k i k next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end function consumption z, k , k next , q, w r 1 q 1 c w z 1 r k k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, policies, prices, u for k i, policy ∈ enumerate policies for s i, state ∈ enumerate states R s i, k i reward state, policy, prices, u end end return R end function setup R states, policies, prices, u R zeros length states , length policies setup R R, states, policies, prices, u end function setup DDP household, statespace, prices β, u household states, policies, states indices, policies indices statespace R setup R states, policies, prices, u Q setup Q states indices, policies indices, statespace.z chain DiscreteDP R, Q, β end ddp setup DDP hh, ss, prices function solve details0 ddp, states, policies solver PFI results QuantEcon.solve ddp, solver df DataFrame states DataFrame policies results.sigma df.state states df.policy policies results.sigma df.π stationary distributions results.mc , 1 1 df end function solve details ddp, states, policies solver PFI df solve details0 ddp, states, policies solver chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end end results solve details ddp, ss.states, ss.policies solver PFI let resolution 800, 400 fig Figure resolution ax1 Axis fig 1, 1 , title \"Consumption policy function\" ax2 Axis fig 1, 2 , title \"Stationary distribution\" plt1 data results mapping k, consumption, color z nonnumeric visual Lines plt2 data results mapping k, π, color z nonnumeric visual Lines ag draw ax1, plt1 draw ax2, plt2 legend fig 2, 1 , ag, orientation horizontal, tellheight true fig end begin n k length k vals results.c sm zeros length ss.states results z groupby results, z rz1 results z 1 rz1.c sm npregress rz1.k, rz1.consumption, rz1.k, 0.08 method ll, to do change on Website kernelfun NormalKernel rz2 results z 2 rz2.c sm 1 n k÷5 npregress rz2.k, rz2.consumption, rz2.k 1 n k÷5 , 0.04 method ll, kernelfun NormalKernel use smaller bandwidth where curvature of consumption function is high rz2.c sm n k÷5 1 end npregress rz2.k, rz2.consumption, rz2.k n k÷5 1 end , 0.08 method ll, kernelfun NormalKernel results2 DataFrame results z end chain results2 begin data mapping k, consumption, c sm , color z nonnumeric visual Lines draw end begin results2.mpc zeros length ss.states results2 z groupby results2, z for rz in results2 z dc diff rz.c sm dx 1 r diff rz.k rz.mpc 1 end 1 dc . dx end results mpc DataFrame results2 z end avg mpc mean results mpc.mpc, weights results mpc.π median mpc median results mpc.mpc, weights results mpc.π md\"\"\" Answer The average MPC in the Aiygari model is round avg mpc,digits 3 100 % for the given parameters. The median is round median mpc,digits 3 100 %. \"\"\" Plots.histogram results mpc.mpc, weights results mpc.π, bins 0 0.025 1. let resolution 800, 400 fig Figure resolution ax1 Axis fig 1, 1 , title \"MPC using smoothed consumption policy \" ax2 Axis fig 1, 2 , title \"Stationary distribution\" plt1 data results mpc mapping k, mpc, color z nonnumeric visual Lines plt2 data results mpc mapping k, π, color z nonnumeric visual Lines ag draw ax1, plt1 draw ax2, plt2 legend fig 2, 1 , ag, orientation horizontal, tellheight true fig end md\"\"\" Word limit functions \"\"\" function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"tutorials/mpcs-aiyagari/","title":"Assignment 1","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 1 order 1 title \"Assignment 1\" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils using NonparametricRegression using PlutoUI TableOfContents using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using QuantEcon md\"\"\" `mpcs aiyagari.jl` | Version 1.2 | last updated May 7, 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" MPCs in the Aiyagari model Households' problem In this exercise, we have a closer look at the marginal propensity to consume in a Aiyagari Huggett economy. The households' problem is ```math \\begin align &\\max c t, k t \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t u c t \\Bigr \\\\ &\\begin aligned \\text subject to &u c \\log c \\\\ &k t \\ge 0 \\\\ &c t k t k t 1 1 r y t \\cdot w\\\\ &y t \\sim \\text some Markov Chain \\\\ &y 0, k 1 \\text given \\end aligned \\end align ``` To be more precise, we are considering the MPC out of an unexpected transitory shock dx t that enters the budget constraint like this c t k t k t 1 1 r y t \\cdot w dx t \"\"\" md\"\"\" Exercise 1 Motivation 1 point 👉 Why do economists and policy makers care about the average MPC in the population and about MPC heterogeneity? Give at least 2 reasons. max 150 words \"\"\" answer 1 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Model parameters \"\"\" r 0.03 prices q 1 1 r , w 1.0 z chain MarkovChain 0.75 0.25 0.25 0.75 , 1.25, 0.75 k vals range 0., 5., length 500 md\"\"\" Exercise 2 No income risk 2 points As a first step, let's consider a more simple model without income risk and without the ad hoc borrowing constraint k t\\ge 0 . 👉 Derive an analytical formula for the MPC and plug in the model parameters given above. 👉 What can you say about the average MPC and MPC heterogeneity in this model? \"\"\" md\"\"\" Your answer goes here \"\"\" md\"\"\" Solution to the households' problem The case with income risk and the ad hoc borrowing constraint does not have an analytical solution. Therefore, we solve the households' problem using functions from the ```aiygari.jl``` notebook \"\"\" md\"\"\" The consumption policy that we obtain from the ```QuantEcon``` solver has small jumps. This is not an actual property of the policy function but happens because we have only solved a discretized version of the households' problem. You can check for yourself that the size of the jumps decreases as you increase the number of grid points. \"\"\" md\"\"\" Since we will use the slope of the policy function to analyze the MPC, the jumps are very inconvenient. Therefore, you will work with the smoothed version of the consumption policy which is saved in the ```c sm``` column of the ```results2``` data frame. \"\"\" md\"\"\" The figure below shows both the raw consumption function and its smoothed version \"\"\" md\"\"\" Exercise 3 MPCs in the Aiyagari model \"\"\" md\"\"\" 3a Compute MPCs 1.5 points 👉 Use the smoothed consumption policy to compute the MPC at each point of the state space. Save the MPC values in an additional column of the results data frame. Hint It is most convenient to consider a transitory income shock of the size dx 1 r \\Delta k where \\Delta k is the distance between two adjacent grid points. \"\"\" Your code goes here ... md\"\"\" 3b Average MPC 1 point 👉 What is the average MPC in the Aiyagari model for the given parameters? \"\"\" Your code goes here ... md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 3c MPC heterogeneity 3 points 👉 Explore MPC heterogeneity in the Aiyagari model graphically. 👉 How much do MPCs vary in the population? Which households have particularly high MPCs? max. 100 words \"\"\" Your code goes here ... answer 3c md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Exercise 4 Outlook 1.5 points The empirical literature on MPCs typically finds average annual MPCs in the range 30 50% Jappelli and Pistaferri, 2014 https www.aeaweb.org articles?id 10.1257 mac.6.4.107 Fagereng et al., 2021 https www.aeaweb.org articles?id 10.1257 mac.20190211 Commault, 2022 https www.aeaweb.org articles?id 10.1257 mac.20190296 . Most empirical papers also find that households with little liquid wealth tend to have higher MPCs than households with a lot of liquid wealth. Models with income risk and a borrowing constraint like the one in Exercise 3 usually generate average annual MPCs lower than 30% if they are calibrated properly. 👉 Why are average MPCs in the data higher than in Aiyagari type models? Mention and explain at least 3 potential mechanisms that are not present in the model. max. 200 words \"\"\" answer 4 md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Before you submit ... 👉 Make sure you do not mention your name in the assignment. The assignments are graded anonymously. 👉 Make sure that that all group members proofread your submission. 👉 Make sure all the code is well documented . 👉 Make sure that you are within the word limit . Short and concise answers are appreciated. Answers longer than the word limit will lead to deductions. 👉 Go to the very top of the notebook and click on the symbol in the very top right corner. Export a static html file of this notebook for submission. The source code is embedded in the html file. \"\"\" md\"\"\" Appendix Functions from ```aiyagari.jl``` The only difference to ```aiyagari.jl``` is that I made some changes to the ```consumption``` function. \"\"\" function Household σ 1.0, β 0.96, u σ 1 ? log x x^ 1 σ 1 1 σ β, u end hh Household β 0.96, u log function statespace k vals range 1e 10, 20.0, length 200 , z chain states k, z for k ∈ k vals, z ∈ z chain.state values | vec states indices k i, z i for k i ∈ 1 length k vals , z i ∈ 1 length z chain.state values | vec policies k next for k next ∈ k vals | vec policies indices k next i for k next i ∈ 1 length k vals | vec states, states indices, policies, policies indices, z chain end ss statespace k vals, z chain function setup Q Q, states indices, policies indices, z chain for i next state, next ∈ enumerate states indices for i policy, k next i ∈ enumerate policies indices for i state, z i ∈ enumerate states indices if next.k i k next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end function consumption z, k , k next , q, w r 1 q 1 c w z 1 r k k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, policies, prices, u for k i, policy ∈ enumerate policies for s i, state ∈ enumerate states R s i, k i reward state, policy, prices, u end end return R end function setup R states, policies, prices, u R zeros length states , length policies setup R R, states, policies, prices, u end function setup DDP household, statespace, prices β, u household states, policies, states indices, policies indices statespace R setup R states, policies, prices, u Q setup Q states indices, policies indices, statespace.z chain DiscreteDP R, Q, β end ddp setup DDP hh, ss, prices function solve details0 ddp, states, policies solver PFI results QuantEcon.solve ddp, solver df DataFrame states DataFrame policies results.sigma df.state states df.policy policies results.sigma df.π stationary distributions results.mc , 1 1 df end function solve details ddp, states, policies solver PFI df solve details0 ddp, states, policies solver chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end end results solve details ddp, ss.states, ss.policies solver PFI let resolution 800, 400 fig Figure resolution ax1 Axis fig 1, 1 , title \"Consumption policy function\" ax2 Axis fig 1, 2 , title \"Stationary distribution\" plt1 data results mapping k, consumption, color z nonnumeric visual Lines plt2 data results mapping k, π, color z nonnumeric visual Lines ag draw ax1, plt1 draw ax2, plt2 legend fig 2, 1 , ag, orientation horizontal, tellheight true fig end begin n k length k vals results.c sm zeros length ss.states results z groupby results, z rz1 results z 1 rz1.c sm npregress rz1.k, rz1.consumption, rz1.k, 0.08 method ll, kernelfun NormalKernel rz2 results z 2 rz2.c sm 1 n k÷5 npregress rz2.k, rz2.consumption, rz2.k 1 n k÷5 , 0.04 method ll, kernelfun NormalKernel use smaller bandwidth where curvature of consumption function is high rz2.c sm n k÷5 1 end npregress rz2.k, rz2.consumption, rz2.k n k÷5 1 end , 0.08 method ll, kernelfun NormalKernel results2 DataFrame results z end chain results2 begin data mapping k, consumption, c sm , color z nonnumeric visual Lines draw end md\"\"\" Word limit functions \"\"\" function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end show words limit answer 1, 150 show words limit answer 3c, 100 show words limit answer 4, 200 md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"tutorials/redistributive-growth-solution/","title":"Assignment 2B (Solution)","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 4 order 4 title \"Assignment 2B Solution \" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoUI TableOfContents using DataFrames using ForwardDiff using Optim begin using Plots, LaTeXStrings theme dao default size 500 . √2, 1 , dpi 150 end md\"\"\" `redistributive growth solution.jl` | Version 1.1 | last updated on May 2, 2023 \"\"\" md\"\"\" Redistributive Growth This lecture is based on the paper Redistributive Growth Döttling and Perotti 2019 . This paper tries to explain various macroeconomic trends with a technological shift to intangible capital. \"\"\" md\"\"\" Parameterization \"\"\" md\"\"\" We use a slight variation of the parameterization in the September 2019 version of the paper. The utility from housing is v L \\log L . \"\"\" Base. kwdef struct RedistributiveGrowthModel L̄ 1 supply of land ϕ 0.2 fraction with high human capital h̃ 8 0.2 inelastic supply of high skilled labor l̃ 10 1 0.2 inelastic supply of low skilled labor α 0.33 capital share η 0.45 relative productivity of intangible capital & high skilled labor ω 0.9 fraction of intangibles that can be \"stolen\" by innovators ψ 1. cost for producing intangibles A 1. productivity end mod RedistributiveGrowthModel md\"\"\" Representative firm \"\"\" md\"\"\" We consider the special case \\rho \\rightarrow 0 in which the production function has a Cobb Douglas form Y F K, H, l, h A H^\\alpha h^ 1 \\alpha ^\\eta K^\\alpha l^ 1 \\alpha ^ 1 \\eta \"\"\" function F K, H, l, h, A, η, α A H^α h^ 1 α ^η K^α l^ 1 α ^ 1 η end md\"\"\" 1. Productivity of intangible capital \\eta bind η sl Slider range 0, 1, length 101 , default 0.5, show value true 2. Capital share \\alpha bind α sl Slider range 0, 1, length 101 , default 0.5, show value true 3. Common productivity factor A bind A sl Slider 1 100, default 1, show value true \"\"\" md\"\"\" Labor is supplied inelastically in this model so that l 1 \\phi \\tilde l and h \\phi \\tilde h . Therefore, we can write down the production function as a function of only K and H \"\"\" function F K, H, A, η, α, ϕ, l̃, h̃ l 1 ϕ l̃ h ϕ h̃ F K, H, l, h, A, η, α end md\"\"\" We can compute the first derivatives of the production function numerically which correspond to the factor prices price of physical capital 1 r price of intangible capital R H wage for manual workers w wage for high skill workers q \"\"\" F xx, par F xx..., par let H list K list range 0.01, 1, length 101 title latexstring \"Contour plot of \\ Y K, H, l 1, h 1 \\ \" contourf K list, H list, x, y F x, y, 1., 1., A A sl, η η sl, α α sl , title title, xlabel L\"K\", ylabel L\"H\" end function get prices K, H, mod ϕ, l̃, h̃ mod l 1 ϕ l̃ h ϕ h̃ xx K, H, l, h oneplusr, R H, w, q ForwardDiff.gradient x F x, mod , xx Y F xx, mod check Y w l q h oneplusr K R H H check, oneplusr, R H, w, q, Y end get prices 0.5, 1., mod md\"\"\" Steady state equilibrium \"\"\" md\"\"\" The equations that describe the steady state values of \\ K, H, Y, r, R H, f, p\\ together with the production function are given in the appendix of the paper 1 r \\alpha 1 \\eta \\frac Y K R H \\alpha \\eta \\frac Y H H \\frac \\omega \\psi R H f \\frac 1 \\omega R H H r p \\frac v' \\bar L r \\frac 1 \\bar L r 1 \\alpha Y p \\bar L f K \"\"\" md\"\"\" Exercise 1 3 points 👉 Provide brief derivations for equation 1 1 point and equation 4 2 points above. \"\"\" md\"\"\" Solution Equation 1 is the first order condition with respect to capital in the profit maximization problem of the representative firm 1 r F K K, H, l, h \\alpha 1 \\eta A H^\\alpha h^ 1 \\alpha ^\\eta K^ \\alpha 1 \\eta 1 l^ 1 \\alpha 1 \\eta \\alpha 1 \\eta \\frac Y K Equation 4 can be derived as follows The first order condition in the household's problem with respect to shares is f t \\frac f t 1 d t 1 r t 1 Repeatedly applying this equation to substitute out f t k yields f t \\sum k 0 ^\\infty \\frac d t k \\prod l 0 ^k 1 r t l 1 For the steady state, this implies if r 0 f \\sum k 0 ^\\infty \\frac d 1 r ^k \\frac d r Finally, because we have a constant returns to scale production function d Y wl qw 1 r K \\omega R H H 1 \\omega R H H \"\"\" md\"\"\" Solving for the steady state \"\"\" md\"\"\" We use numerical methods to solve for the steady state. First, we reformulate the system of equations by substituting out the five variables \\ Y, r, R H, f, p\\ , so that we end up with a system of just two equations as a function of K and H \"\"\" function model equations 1 K, H, mod α, η, ω, L̄, ϕ, l̃, A mod Y F K, H, mod production function r α 1 η Y K 1 eq. 1 rearranged R H α η Y H eq. 2 f 1 ω R H H r eq. 4 p 1 L̄ r eq. 5 return Y, r, R H, f, p end function model equations 2 K, H, mod Y, r, R H, f, p model equations 1 K, H, mod α, ω, L̄, ψ mod eq 1 H ω ψ R H eq. 3 rearranged eq 2 1 α Y p L̄ f K eq. 6 rearranged return eq 1, eq 2 end md\"\"\" ```eq 1``` and ```eq 2``` in the function above should be zero at the steady state values of K and H . Consequently, the sum of the squares ```eq 1```² ```eq 2```² should also be zero in this case. This means that we can find the steady state values of K and H by applying a minimization algorithm to ```eq 1```² ```eq 2```². To make sure that the algorithm does not accidentally use negative values for K or H , we write down the objective function in terms of \\log K and \\log H . After running the minimization algorithm, we always need to check if the sum of squares is indeed zero or at least extremely close to zero . Other solution algorithms are possible and probably better than this approach. See this notebook https greimel.github.io distributional macroeconomics notebooks redistributive growth fabian with alternative solution methods for the redistributive growth model. \"\"\" function objective function log K log H, mod K exp log K log H 1 H exp log K log H 2 eq 1, eq 2 model equations 2 K, H, mod return eq 1^2 eq 2^2 end md\"\"\" We need to initialize the minimization algorithm at values for K and H that are associated with a positive interest rate r . Otherwise, the algorithm may converge to another minimum with a negative interest rate that is not economically meaningful. Below you can see that the interest rate associated with our starting values is indeed positive. \"\"\" begin K init 0.4 H init 1. model equations 1 K init, H init, mod end md\"\"\" Now we apply the minimization algorithm. The objective function is very close to 0 at the minimum that the algorithm found. \"\"\" res optimize x objective function x, mod , log K init , log H init md\"\"\" Since the arguments of the objective function are \\log K and \\log H , we need to exponentiate the minimizer to get the steady state values of K and H \"\"\" K, H exp. Optim.minimizer res md\"\"\" To find the steady state values of \\ Y, r, R H, f, p\\ , we put the steady state values of K and H into the equations that we have used to substitute out these five variables \"\"\" model equations 1 K, H, mod md\"\"\" Moreover, we can get steady state wages w and q by computing the numerical gradient of the production function \"\"\" get prices K, H, mod md\"\"\" Exercise 2 1 point The steady state interest rate r round model equations 1 K, H, mod .r 100,digits 1 % seems quite big at a first glance. 👉 Is steady state interest rate in the model roughly consistent with interest rates in the real world? Provide a brief explanation. max. 100 words \"\"\" annual r 1 model equations 1 K, H, mod .r ^ 1 30 1 answer 2 md\"\"\" Since the model features households that live two periods, one should not interpret 1 period as 1 year, but maybe rather as 30 years. In this case, the steady state interest rate of round model equations 1 K, H, mod .r 100,digits 1 % corresponds to an annual rate of round annual r 100,digits 1 %. This is roughly in line with the interest rates that are observed in the real world. If anything, this interest rate is too low if we take into account that the calibration tries to match the US economy in 1980 when real interest rates were higher than nowadays. \"\"\" md\"\"\" Secular trends \"\"\" md\"\"\" The paper claims that a shift towards intangible capital \\eta \\uparrow in the model can explain the following macroeconomic trends declining interest rates r \\downarrow increasing share of intangible capital H H K \\uparrow declining physical investment scaled by GDP K Y \\downarrow increasing mortgage borrowing m Y \\uparrow increasing house prices p Y \\uparrow increasing stock prices f Y \\uparrow increasing wage inequality q w \\uparrow \"\"\" md\"\"\" To confirm that an increase in \\eta indeed generates the secular trends listed above for the given parameterization, we compute the steady state for a slightly higher value of \\eta such as \\eta round mod.η 0.1, digits 2 and compare the variables of interest in the two steady states. \"\"\" mod η RedistributiveGrowthModel η mod.η 0.1 model equations 1 K init, H init, mod η res η optimize x objective function x, mod η , log K init , log H init K η, H η exp. Optim.minimizer res η md\"\"\" The first row describes the steady state for the baseline value for \\eta , the second row for \\eta round mod η.η, digits 3 \"\"\" md\"\"\" Below you can find two helper functions to compute the macroeconomic variables of interest for given steady state values K , H , and to compare macroeconomic variables across steady states \"\"\" function compute trends variables K, H, mod Y, r, R H, f, p model equations 1 K, H, mod ϕ, L̄, l̃ mod w, q get prices K, H, mod m max 0, 1 ϕ p L̄ f w l̃ H HK H H K K Y K Y m Y m Y p Y p Y f Y f Y q w q w r, H HK, K Y, m Y, p Y, f Y, q w end begin trends vars compute trends variables K, H, mod trends vars η compute trends variables K η, H η, mod η DataFrame trends vars, trends vars η end function trends trends vars 1, trends vars 0 for key in keys trends vars 0 if trends vars 1 key trends vars 0 key 1e 6 sgn \"↑\" elseif trends vars 1 key trends vars 0 key 1e 6 sgn \"↓\" else sgn \"→\" end println key, \" \" , sgn end end trends trends vars η, trends vars md\"\"\" Alternative growth drives \"\"\" md\"\"\" In the previous section, we found out that a technological shift to intangible capital \\eta \\uparrow can explain the secular trends at least qualitatively . But is it the only possible explanation of these trends? In order to exclude other possible explanations, we need to consider alternative growth drivers and check which of the secular trends they can replicate and which not. The following alternative growth drivers are already implemented in the model greater ease of innovation \\psi \\downarrow rising share of educated workers \\phi \\uparrow rising productivity of capital relative to labor \\alpha \\uparrow increased bargaining power for innovators over established firms \\omega \\uparrow \"\"\" md\"\"\" Exercise 3 2.5 points 👉 Pick one of the four alternative growth drivers listed above and conduct a comparison of steady states similar to the \\eta \\uparrow case. Which of the secular trends can this growth driver explain and which not? Provide a brief explanation for the changes in \\ r, H H K , K Y, m Y, p Y, f Y, w q\\ that are generated by the parameter change that you consider. max. 200 words \"\"\" mod ϕ RedistributiveGrowthModel ϕ mod.ϕ 0.1 model equations 1 K init, H init, mod ϕ res ϕ optimize x objective function x, mod ϕ , log K init , log H init K ϕ, H ϕ exp. Optim.minimizer res ϕ begin trends vars ϕ compute trends variables K ϕ, H ϕ, mod ϕ DataFrame trends vars, trends vars ϕ end trends trends vars ϕ, trends vars K ϕ, H ϕ model equations 1 K ϕ, H ϕ, mod ϕ answer 3 md\"\"\" The verbal answer is omitted here because it depends on the growth driver considered. If the feedback that I provided on Canvas is not sufficiently clear, let me know. \"\"\" md\"\"\" Exercise 4 3.5 points An alternative growth driver are capital inflows from emerging countries into the developed world \"global savings glut\" . These capital inflows can be incorporated into the model by adding an exogenous increase in savings x to the steady state equations 1 \\alpha x Y p \\bar L f K 👉 Add the exogenous increase in savings to the model and repeat exercise 3 for this alternative growth driver. max. 200 words \"\"\" md\"\"\" Solution \"\"\" Base. kwdef struct RedistributiveGrowthModel2 L̄ 1 supply of land ϕ 0.2 fraction with high human capital h̃ 8 0.2 inelastic supply of high skilled labor l̃ 10 1 0.2 inelastic supply of low skilled labor α 0.33 capital share η 0.45 relative productivity of intangible capital & high skilled labor ω 0.9 fraction of intangibles that can be \"stolen\" by innovators ψ 1. cost for producing intangibles A 1. productivity x 0. end mod x RedistributiveGrowthModel2 x 0.1 function model equations 2 x K, H, mod x Y, r, R H, f, p model equations 1 K, H, mod x α, ω, L̄, ψ, x mod x eq 1 H ω ψ R H eq. 3 rearranged eq 2 1 α x Y p L̄ f K eq. 6 rearranged return eq 1, eq 2 end function objective function x log K log H, mod x K exp log K log H 1 H exp log K log H 2 eq 1, eq 2 model equations 2 x K, H, mod x return eq 1^2 eq 2^2 end res x optimize x objective function x x, mod x , log K init , log H init K x, H x exp. Optim.minimizer res x begin trends vars x compute trends variables K x, H x, mod x DataFrame trends vars, trends vars x end trends trends vars x, trends vars answer 4 md\"\"\" extra inflow of savings reduces interest rate and increases asset prices houses, shares lower interest rates make physical capital cheaper and, as a result, both K Y \\uparrow and H H K \\downarrow more expensive houses lead to increase in mortgage borrowing \"\"\" md\"\"\" Before you submit ... 👉 Make sure you do not mention your name in the assignment. The assignments are graded anonymously. 👉 Make sure that that all group members proofread your submission. 👉 Make sure all the code is well documented . 👉 Make sure that you are within the word limit . Short and concise answers are appreciated. Answers longer than the word limit will lead to deductions. 👉 Go to the very top of the notebook and click on the symbol in the very top right corner. Export a static html file of this notebook for submission. The source code is embedded in the html file. \"\"\" md\"\"\" Appendix \"\"\" md\"\"\" Acknowledgments The visualization of the production function is taken from a notebook that was contributed by Andrea Titton https github.com NoFishLikeIan . \"\"\" md\"\"\" Word limit functions \"\"\" function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end show words limit answer 2, 100 show words limit answer 3, 200 show words limit answer 4, 200 md\"\"\" Imported packages \"\"\" "},{"url":"tutorials/simple-housing-wealth-effects-solution/","title":"Assignment 2A (Solution)","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 3 order 3 title \"Assignment 2A Solution \" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using Statistics mean using StatsBase weights using CairoMakie using AlgebraOfGraphics using DataFrames, DataFrameMacros, Chain using StructArrays using PlutoUI using PlutoUI Slider begin using StatsBase StatsBase, AbstractWeights using CategoricalArrays formatter from, to, i kwargs... \" i\" function CategoricalArrays.cut x AbstractArray, w AbstractWeights, ngroups Integer labels formatter cut x, StatsBase.quantile x, w, 1 ngroups 1 ngroups extend true, labels end end md\"\"\" `simple housing wealth effects solution.jl` | Version 1.1 | last updated May 31 2023 \"\"\" md\"\"\" Simple Housing Wealth Effects Based on the article Understanding Housing Wealth Effects Debt, Homeownership and the Lifecycle Greimel & Zadow, 2020 . \"\"\" md\"\"\" Model The model is a simplified version of the canonical macroeconomic model with housing. The agents' optimal value is ```math \\begin align V 0 h 0, d 0 &\\max c t, h t 1 \\sum j 0 ^ J 1 \\beta^j u c t, h t 1 \\beta^ J 1 \\psi h J \\\\ &\\begin aligned \\text s.t. & c t p x t \\pi t y \\\\ & x t h t 1 1 \\delta h t \\\\ & \\pi t 1 r d t d t 1 \\\\ &d J \\leq 0 &\\end aligned \\end align ``` \"\"\" md\"\"\" agents life for ``J`` periods and earn a deterministic income ``y`` in each period agents consume a non durable consumption good ``c`` and durable housing ``h`` which depreciates at rate ``\\delta`` agents can borrow debt ``d`` at interest rate ``r`` ``\\beta 1 r 1`` agents cannot die with debt ``d J \\leq 0`` ``p`` follows a Markov Chain on ``\\ p 1, p 2\\ ``, with transition matrix ``\\begin pmatrix 1 \\varepsilon & \\varepsilon \\\\ \\varepsilon & 1 \\varepsilon \\end pmatrix `` with ``\\varepsilon \\to 0``. That is agents think that the house price is constant. ``\\psi h `` captures a warm glow bequest motive. Old agents get some utility of passing on their house to the next generation. Absent a bequest motive agents would sell off their house before their death. The functional form is chosen to allow a closed form solution. \"\"\" md\"\"\" Parameters and Solution \"\"\" Base. kwdef struct SimpleHousingModel β 1 1 0.0245 δ 0.022 ξ 1 0.8875 J 60 y 1.0 d₀ 0.0 end rate β 1 β 1 θ J,r sum 1 1 r ^j for j in 0 J 1 bad name function solve tractable δ, β, ξ, y , d₀, J, p r rate β 𝒴 θ J,r y d₀ κ₁ ξ β 1 δ 1 β 1 δ κ₂ 1 β 1 δ 1 ξ ξ p ^ 1 ξ κ₃ 1 β 1 δ 1 ξ ξ Ω κ₃ ph 𝒴 1 δ θ J,r δ κ₃ h ph p c κ₃ ph π y ph δ c d zeros J d 1 d₀ ph c y for j ∈ 2 J d j d j 1 1 r π end df DataFrame j 0 J 1, d, c, ph, h, π, y c, h, ph, π, d, df end function solve tractable param, p J, β, y, d₀ param r rate β 𝒴 θ J,r y d₀ solve tractable param, d₀, J, p end mod0 SimpleHousingModel PROJ DIR joinpath DIR , \"..\", \"..\", \"..\", \"Research\", \"housing wealth effects\" | normpath md\"\"\" Optimal policies \"\"\" md\"\"\" ``\\beta`` bind β1 Slider 0.8 0.001 1.0, default 1 1 0.0245 , show value true ``\\delta`` bind δ1 Slider 0.0 0.005 0.1, default 0.022, show value true depreciation rate of housing ``\\xi`` bind ξ1 Slider 0.0 0.001 1.0, default 1 0.8875, show value true utility weight of housing ``J`` bind J1 Slider 10 5 400, default 60, show value true length of working life ``y`` bind y1 Slider 0.5 0.5 5.0, default 1, show value true income ``d 0`` bind d₀1 Slider 5 0.5 5, default 0, show value true initial debt if negative asset bind compare1 CheckBox default true compare with defaults \"\"\" policies0 solve tractable mod0, 1.0 .df policies slider let mod1 SimpleHousingModel β β1, δ δ1, J J1, ξ ξ1, y y1, d₀ d₀1 p 1.0 df solve tractable mod1, p .df end let if compare1 df vcat policies slider, policies0, source parameters \"sliders\", \"default\" else df transform policies slider, parameters \"sliders\" end chain df begin transform age j 25 stack Not age, j, parameters data mapping age, value, color variable, layout parameters visual ScatterLines, markersize 5 draw end end md\"\"\" Housing Wealth Effects \"\"\" md\"\"\" ``\\frac p 1 p 0 `` bind q by p Slider 0.5 0.1 1.5, default 0.9, show value true size of shock \"\"\" md\"\"\" An unexpected house price shock \"\"\" md\"\"\" ``j \\text shock `` bind j shock Slider 0 mod0.J 1, default 10, show value true age at which the shock hits \"\"\" let mod0 p₀ 1 p₁ q by p p₀ J, β, d₀, δ mod0 r rate β df₀ solve tractable mod0, d₀, J, p p₀ .df nt subset df₀, j j shock 1 | only | NamedTuple subset df₀, j j shock d₁ nt.d nt.ph p₀ p₁ 1 δ 1 r df₁ solve tractable mod0, d₀ d₁, J J j shock, p p₁ .df transform df₁, j j j shock df df₀ df₁ chain df begin transform age j 25 stack Not age, j data mapping age, value, color variable visual ScatterLines, markersize 5 draw end end md\"\"\" Consumption response over the lifecycle \"\"\" md\"\"\" ``\\beta`` bind β2 Slider 0.8 0.01 1.0, default 1 1 0.0245 , show value true ``\\delta`` bind δ2 Slider 0.0 0.005 0.1, default 0.022, show value true depreciation rate of housing ``\\xi`` bind ξ2 Slider 0.0 0.05 1.0, default 1 0.8875, show value true utility weight of housing ``J`` bind J2 Slider 10 5 400, default 60, show value true length of working life ``y`` bind y2 Slider 0.5 0.5 5.0, default 1, show value true income bind compare2 CheckBox default true compare with defaults \"\"\" function consumption response J, δ, β, ξ , q by p r rate β κ₃ 1 β 1 δ 1 ξ ξ Ω κ₃ df map 0 J 1 do j num 1 δ q by p θ J j,r δ Ω den 1 δ θ J j,r δ Ω c res num den 1 j, c res end | DataFrame transform df, age j 25 end cres df consumption response mod0, q by p let mod2 SimpleHousingModel β β2, δ δ2, J J2, ξ ξ2, y y2 df consumption response mod2, q by p if compare2 df vcat df, cres df, source parameters \"sliders\", \"default\" else transform df, parameters \"sliders\" end data df mapping age, c res \"consumption response\", color parameters visual ScatterLines | draw end ages cres df.age md\"\"\" Assignment Housing Wealth Effects in an Ageing Society In this assignment we will explore how demographic change is affecting the aggregate response to house price changes. \"\"\" md\"\"\" Exercise 1 Calibration 4 points 👉 Choose ``n \\geq 1`` statistics that can be computed in the model and in the Survey of Consumer Finances. Choose ``n`` parameters from the model. Set the parameter values so that the statistics in the model match those in the data. 👉 Discuss your choice. \"\"\" answer1 md\"\"\" I adopt y 1 as a normalization so that one unit of the consumption corresponds to the average annual income. The depreciation rate of housing \\delta and the length of the agents' lives J can be set according to external information. Moreover, the model defines the discount factor \\beta as \\beta 1 1 r and the real interest rate r can be set according to external information. So the only parameter which remains for internal calibration is the utility weight on housing services \\xi . If households place more weight on housing in their Cobb Douglas utility function, they will spend a larger share of their financial resources on housing. For a fixed depreciation rate \\delta and interest rate r , this means that they will buy larger houses. So the natural choice as the targeted moment is aggregate housing wealth aggregate income. I divide by aggregate income due to the y 1 normalization. With \\xi 0.094 instead of the old default value \\xi 0.113 , the chosen moment has almost the same value in the model as in the data. This means that a lot of information in the data is not used for calibration, e.g. net wealth income and debt income. You can still use these moments for model validation, i.e. to check whether the model is able to match moments which were not targeted during the calibration. As a side note, I find it a bit unsatisfying that the strength of the bequest motive cannot be calibrated in this model even though it is important for the relationship of MPCs with age stronger bequest motive less steep increase of MPCs with age . \"\"\" md\"\"\" Some words on calibration in general The decisions involved when calibrating a model can seem very arbitrary. For this reason, I'll briefly describe my approach to calibration. This is not necessarily the best way to do it. 1 Which parameter are set according to external information and which are calibrated \"internally\"? With internal calibration I mean to choose parameter values according to some method of moments algorithm. In my opinion, it makes a lot of sense to use external information to set parameter values whenever possible. The remaining parameters which need to be calibrated internally are often related to preferences. 2 Which moments should be selected for \"internal\" calibration? A good starting point is to pick moments such that each moment is particularly informative about one parameter. Of course, in the method of moments algorithm all moments determine jointly the parameter values. Moreover, models typically feature some type of normalization such as \"one unit of the consumption good is equal to the average annual income\". When selecting moments you need to take into account the normalization. \"\"\" model raw chain policies slider begin stack d, c, ph, h, y , π groupby variable combine value mean value, weights π NamedTuple tuple Symbol. .variable ... tuple .value... end model statistics ph model raw.ph model raw.y model statistics md\"\"\" Exercise 2 Housing Wealth Effects in an Aging Society 6 points Across many countries the demographic structure is changing. The figure below shows historical and forecast age structures for the USA. One notable feature of this figure is the hump that moves from left to right over time. This hump represents the generation of baby boomers . Given that age is an important determinant of housing wealth effects we want to ask the question How do aggregate housing wealth effects change as the society ages? \"\"\" md\"\"\" 👉 Aggregate response 3 points | Compute the aggregate consumption response to a 10% reduction in house prices for varying age structures. You can use `cres df` and `age weights`. \"\"\" md\"\"\" 👉 External validity 3 points | A politician asks you to forecast the consumption response to house price shock in 2030. Would you use the given model? Discuss some aspects of the real world that are missing from the model. The figure below provides two hints that you may pick up or ignore. \"\"\" answer2 md\"\"\" It is helpful to consider the Berger et al. 2018 formula which says that the consumption response to a house price shock is approximately the product of housing wealth and the MPC out of a transitory income shock ```math \\begin align \\frac dc it dp t p t \\approx p t h it MPC it \\end align ``` The response of aggregate consumption can therefore be written as ```math \\begin align \\frac dC t dp t p t \\sum i\\frac dc it dp t p t \\approx \\sum i p t h it MPC it \\end align ``` Using the approximation, we can see that the model is a good choice if ... 1 it captures the covariation of housing wealth with age well 2 it captures the covariation of MPCs with age well 1 The two figures below show that according to survey data older households tend to own more housing wealth than younger households, both because they are more likely to be homeowners and because they tend to live in more expensive houses conditional on being homeowners . In contrast, housing wealth is flat over the life cycle in the model. Therefore, the model might underestimate the effect of the demographic structure on the consumption response to house price shocks. Adding a rent vs. buy choice and a loan to value constraint to the model should help to match the data better. 2 The model predicts that MPCs increase with age, in particular among old retirees. It would be a good idea to find some empirical evidence regarding the relationship of MPCs with age to check if this is actually true. Moreover, it seems as if the average MPC in the model is much lower than in the empirical literature on MPCs. For this reason, it would make sense to add some model features which increase the overall level of MPCs, such as income risk and housing adjustment costs. \"\"\" md\"\"\" Appendix \"\"\" import CSV TableOfContents md\"\"\" Data \"\"\" md\"\"\" SCF \"\"\" const SCF YEARS 1989 3 2019 begin using DataDeps ENV \"DATADEPS ALWAYS ACCEPT\" true for year in SCF YEARS register DataDep \"SCF year \", \"\", \"https www.federalreserve.gov econres files scfp year excel.zip\", scf checksums year checksum Union String,Vector String ... , Optional, if not provided will generate post fetch method unpack end end function get scf year assert year ∈ SCF YEARS str \"SCF year \" path datadep str str CSV.File joinpath path, \"SCFP year .csv\" | DataFrame end data raw chain get scf 2019 begin stack INCOME, NETWORTH, ASSET, DEBT, NH MORT, HOUSES , WGT groupby variable combine value mean value, weights WGT NamedTuple tuple Symbol. .variable ... tuple .value... end data statistics ph data raw.HOUSES data raw.INCOME data statistics chain get scf 2019 begin transform age bin bycol cut AGE, weights WGT , 20 transform age bin Meta.parse get age bin groupby age bin combine \"house value\" mean HOUSES, weights WGT , \"ownership rate\" mean HOUSES . 0, weights WGT , age mean AGE, weights WGT stack \"house value\", \"ownership rate\" , age data mapping age, value \"\", row variable visual ScatterLines draw facet linkyaxes false end md\"\"\" Demographics TODO for 2023 reproducibly compile the data in the notebook \"\"\" import HTTP ages url \"https greimel.github.io distributional macroeconomics assets datasets age.csv\" age df0 CSV.File HTTP.get ages url .body | DataFrame age df chain age df0 begin subset year ∈ 1980 10 2040 transform age range from to select age range, share share length age range , year flatten age range rename age range age end chain age df begin subset year ∈ 1980 20 2040 groupby year combine age, pmf share, cdf cumsum share transform inverse cdf 1 cdf stack pmf, inverse cdf , age, year data mapping age, value \"\", row variable, color year nonnumeric visual Lines draw facet linkyaxes false aside Label .figure 0,1 , \"The age distribution over time\", tellwidth false end age weights chain age df begin subset year ∈ 1980 10 2040 subset age ∈ ages aside wgts80 sum subset , year 1980 .share transform raw share share, share share wgts80 end agg res chain age weights begin subset year 1980 leftjoin cres df, on age groupby year combine agg sum c res, weights share end scatterlines agg res.year, 100 agg res.agg, axis xlabel \"age distribution\", ylabel \"%\", title \"The Aggregate Response Given Demographic Change\" md\"\"\" Infrastructure \"\"\" function wordcount text stripped text strip replace string text , r\"\\s\" \" \" words split stripped text, ' ', ' ', '.', ',', ' ', ' ', '\"', ' ', ' ', '\\'' length filter \"\" , words end show words answer md\" approximately wordcount answer words \" begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end function show words limit answer, limit count wordcount answer if count 1.02 limit return show words answer else return almost md\"You are at count words. Please shorten your text a bit, to get below limit words .\" end end "},{"url":"tutorials/stopping-time-problem-solution/","title":"Tutorial 3B (Solution)","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 7 order 7.5 title \"Tutorial 3B Solution \" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils using PlutoUI using AlgebraOfGraphics, CairoMakie using Parameters using LinearAlgebra using SparseArrays using LCPsolve using DataFrames using Chain chain md\"\"\" `stopping time problem solution.jl` | Version 1.1 | last updated May 2, 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" Optimal stopping problems Durable good \"\"\" md\"\"\" Example taken from Ben Moll's website Model description https benjaminmoll.com wp content uploads 2020 06 car.pdf , Matlab code https benjaminmoll.com wp content uploads 2020 06 car.m Also useful Exercising an option https benjaminmoll.com wp content uploads 2020 06 option simple.pdf \"\"\" md\"\"\" Model \"\"\" with kw struct DurableModel σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference r Float64 0.045 interest rate y Float64 0.1 income κ Float64 0.25 utility from durable good p₀ Float64 0.2 buying price p₁ Float64 0.1 selling price asset grid parameters N a Int64 500 aₘᵢₙ Float64 0.02 aₘₐₓ Float64 3 da Float64 aₘₐₓ aₘᵢₙ N a 1 end function construct a m N a, aₘᵢₙ, aₘₐₓ m aᵢ for aᵢ in range aₘᵢₙ, aₘₐₓ, N a | hcat asset grid column vector end md\"\"\" The value function for agents that do not own a car is v 0 a . The value function for agents that own a car is v 1 a . The value of buying a car is v 0^ a v 1 a p 0 if a p 0 \\ge \\underline a , else v 0^ a \\infty . The value of selling the car is v 1^ a v 0 \\max\\ a p 1, a \\max\\ . HJB variational inequalities ```math \\begin align 0 & \\min\\ \\rho v 0 a \\max c\\ u c v' 0 a y ra c \\ , v 0 a v 0^ a \\ \\\\ 0 & \\min\\ \\rho v 1 a \\max c\\ u c \\kappa v' 1 a y ra c \\ , v 1 a v 1^ a \\ \\\\ \\end align ``` \"\"\" md\"\"\" Exercise 1 Solution algorithm \"\"\" md\"\"\" Finite difference method \\implies ```math \\begin align 0 & \\min\\ \\frac v 0^ n 1 v 0^n \\Delta \\rho v 0^ n 1 u v 0^n A v 0^n v 0^ n 1 , v 0^ n 1 v 0^ ^n\\ \\\\ 0 & \\min\\ \\frac v 1^ n 1 v 1^n \\Delta \\rho v 1^ n 1 u v 1^n A v 1^n v 1^ n 1 , v 1^ n 1 v 1^ ^n\\ \\\\ \\end align ``` where v 0 , v 1 , etc. denote column vectors now the value functions evaluated on the discrete grid . Stacking both equations \\implies ```math \\begin align 0 & \\min\\ \\frac v^ n 1 v^n \\Delta \\rho v^ n 1 u A v^ n 1 , v^ n 1 v^ ^n\\ \\end align ``` where v \\begin pmatrix v 0 \\\\ v 1 \\end pmatrix , A \\begin pmatrix A v 0 & 0 \\\\ 0 & A v 1 \\end pmatrix , etc. \"\"\" md\"\"\" We will solve the equation for the updated value function v^ n 1 by writing the equation above as a Linear Complementarity Problem LCP ```math \\begin align z' Bz q & 0 \\\\ z &\\ge 0 \\\\ Bz q &\\ge 0 \\end align ``` Then we can use the LCP solver from the ```LCPsolve.jl``` package to solve for z . 👉 Rewrite the equation 0 \\min\\ \\dots\\ above as a LCP. Express z , B and q in terms of v^ n 1 , v^n , v^ ^n , u , A , \\rho and \\Delta . \"\"\" md\"\"\" Writing as Linear Complementarity Problem \\implies ```math \\begin align v^ n 1 v^ ^n ' \\frac v^ n 1 v^n \\Delta \\rho v^ n 1 u A v^ n 1 & 0 \\\\ v^ n 1 v^ ^n &\\ge 0 \\\\ \\frac v^ n 1 v^n \\Delta \\rho v^ n 1 u A v^ n 1 &\\ge 0 \\end align ``` Convert into ```LCPsolve.jl``` parameterization \\implies z v^ n 1 v 0^ ^n B 1 \\Delta \\rho I A q u v^n \\Delta B v^ ^n This means that after finding the correct z from the LCP solver, we can obtain the updated value function as follows v^ n 1 z v^ ^n \"\"\" md\"\"\" 👉 Use your result to complete the code below. \"\"\" function solve HJBVI m DurableModel maxit 100, crit 1e 6, Δ 1000 σ, ρ, r, y, κ, p₀, p₁, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m initialize arrays for forward and backward difference dvf zeros N a, 2 dvb zeros N a, 2 v star zeros N a, 2 initial guess for value function v₀ zeros N a, 2 v₀ , . y . r a .^ 1 σ 1 σ ρ v v₀ initialize vector that keeps track of convergence dist ones maxit i buy ceil Int, p₀ da p₀ equals i buy grid points i sell ceil Int, p₁ da p₁ equals i sell grid points for it in range 1, maxit forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, . y . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, . y . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf y . r . a . cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb y . r . a . cb consumption and derivate of value function at steady state c0 y . r . a . zeros N a, 2 dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state c cf . If cb . Ib c0 . I0 u zeros N a, 2 u ,1 c ,1 .^ 1 σ 1 σ u ,2 c ,2 .^ 1 σ 1 σ . κ X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da A11 spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 A22 spdiagm 1 X 2 N a,2 , 0 Y ,2 , 1 Z 1 N a 1,2 A blockdiag A11, A22 value of buying car if currently, don't own car v star i buy 1 N a,1 v 1 N a i buy,2 instead of setting Vstar 1 i buy,1 Inf, do something smoother slope v star i buy 2,1 v star i buy 1,1 da v star 1 i buy,1 v star i buy 1,1 . slope a 1 i buy . a i buy 1 value of selling car if currently own car v star 1 N a i sell,2 v i sell 1 N a,1 v star N a i sell 1 N a,2 . v N a,1 assume p min p,amax a YOUR CODE B ρ 1 Δ sparse I, 2 N a, 2 N a A q vec u vec v Δ B vec v star z₀ vec v vec v star res solve LCP B, q , z₀ z res.sol LCP error maximum abs. z. B z q if LCP error 1e 5 error \"LCP not solved\" end v new reshape z vec v star , N a, 2 v change v new v dist it maximum abs. v change v v new if dist it crit ȧ y . r . a . c return v, v star, c, ȧ, it, dist end end error \"Algorithm did not converge\" end function results to df m DurableModel v, v star, c, ȧ N a m d 0 1 a construct a m df DataFrame df.a a ones 1, 2 | vec df.d ones Int, N a, 1 d | vec df.c c | vec df.ȧ ȧ | vec df.v v | vec df.v star v star | vec df.action v star .≈ v | vec df.c df.action . NaN df.ȧ df.action . NaN df end md\"\"\" Exercise 2 Results \"\"\" m DurableModel md\"\"\" 👉 Interpret the diagram below. \"\"\" md\"\"\" Left panel agent does not own car d 0 low wealth v 0 v 0^ \\implies agents does not buy car sufficiently high wealth v 0 v 0^ \\implies agent buys car Right panel agent owns car d 1 high wealth v 1 v 1^ \\implies agents does not sell car sufficiently low wealth v 1 v 1^ \\implies agent sells car Note that \"value matching\" and \"smooth pasting\" hold even though we did not impose them. \"\"\" md\"\"\" 👉 Interpret the diagram below. \"\"\" md\"\"\" There is a large range of wealth values for which owners do not sell but non owners do not buy. This is because of the difference between the selling and the buying price. \"\"\" md\"\"\" Retirement see Fahri and Panageas 2007 https www.sciencedirect.com science article pii S0304405X06001127 and Grochulski and Zhang 2020 https papers.ssrn.com sol3 papers.cfm?abstract id 3473117 \"\"\" md\"\"\" Model \"\"\" with kw struct RetirementModel σ Float64 2. risk aversion coefficient u' c c^ σ ρ Float64 0.05 rate of time preference r Float64 0.05 interest rate y Float64 0.1 income κ Float64 0.25 utility from leisure in retirement asset grid parameters N a Int64 500 aₘᵢₙ Float64 5. aₘₐₓ Float64 20. da Float64 aₘₐₓ aₘᵢₙ N a 1 end md\"\"\" The value function for working agents is v a \\max c t \\int 0^\\tau e^ \\rho t \\Big \\frac c t ^ 1 \\sigma 1 \\sigma \\Big dt e^ \\rho \\tau v^ a subject to \\dot a y ra c . Working agents have the option to retire. \\tau is the stopping time. The value function for retired agents is v^ a \\max c t \\int 0^\\infty e^ \\rho t \\Big \\frac c t ^ 1 \\sigma 1 \\sigma \\kappa \\Big dt subject to \\dot a ra c . Retired agents do not have the option to start working again. Trade off Retired agents receive utility from leisure \\kappa , but do no longer receive any income y . If r \\rho , c t ra and hence v^ a \\frac 1 \\rho \\Big \\frac ra ^ 1 \\sigma 1 \\sigma \\kappa \\Big HJB variational inequality ```math \\begin align 0 & \\min\\ \\rho v a \\max c\\ u c v' a y ra c \\ , v a v^ a \\ \\end align ``` \"\"\" md\"\"\" Exercise 3 Solution algorithm \"\"\" md\"\"\" 👉 Adapt the solution algorithm for the durable goods model to solve the retirement model. \"\"\" function solve HJBVI m RetirementModel maxit 100, crit 1e 6, Δ 1000 σ, ρ, r, y, κ, N a, aₘᵢₙ, aₘₐₓ, da m construct asset grid a construct a m v star 1 ρ r a .^ 1 σ 1 σ . κ initialize arrays for forward and backward difference dvf zeros N a, 1 dvb zeros N a, 1 initial guess for value function v₀ 1 ρ y . r a .^ 1 σ 1 σ v v₀ initialize vector that keeps track of convergence dist ones maxit for it in range 1, maxit forward difference dvf 1 N a 1, v 2 N a, v 1 N a 1, da dvf N a, . y . r aₘₐₓ .^ σ boundary condition a a max backward difference dvb 2 N a, v 2 N a, v 1 N a 1, da dvb 1, . y . r aₘᵢₙ .^ σ boundary condition a a min I concave dvb . dvf problems if value function not concave consumption and savings with forward difference cf dvf .^ 1 σ ȧf y . r . a . cf consumption and savings with backward difference cb dvb .^ 1 σ ȧb y . r . a . cb consumption and derivate of value function at steady state c0 y . r . a dv0 c0 .^ σ If ȧf . 0 positive drift forward difference Ib ȧb . 0 negative drift backward difference Ib N a, . 1. make sure backward difference is used at last grid point If N a, . 0. I0 1 . If . Ib steady state c cf . If cb . Ib c0 . I0 u c .^ 1 σ 1 σ X min. ȧb,0 da Y max. ȧf,0 da min. ȧb,0 da Z max. ȧf,0 da A spdiagm 1 X 2 N a,1 , 0 Y ,1 , 1 Z 1 N a 1,1 B ρ 1 Δ sparse I, N a, N a A q vec u vec v Δ B vec v star z₀ vec v vec v star res solve LCP B, q , z₀ z res.sol LCP error maximum abs. z. B z q if LCP error 1e 5 error \"LCP not solved\" end v new z v star v change v new v dist it maximum abs. v change v v new if dist it crit ȧ y . r . a . c return v, v star, c, ȧ, it, dist end end error \"Algorithm did not converge\" end function results to df m RetirementModel v, v star, c, ȧ N a m a construct a m df DataFrame df.a a | vec df.c c | vec df.ȧ ȧ | vec df.v v | vec df.v star v star | vec df.action v star .≈ v | vec df.c df.action . NaN df.ȧ df.action . NaN df end function solve df m maxit 100, crit 1e 6, Δ 1000 v, v star, c, ȧ, it, dist solve HJBVI m maxit, crit, Δ df results to df m v, v star, c, ȧ return df end df solve df m let figure resolution 800, 400 chain df begin stack v star, v data mapping a, value, layout d nonnumeric, color variable nonnumeric visual Lines draw figure, facet linkyaxes false, , legend position top, titleposition left end end chain df begin stack c, ȧ, action data mapping a, value, layout variable, color d nonnumeric visual Lines draw facet linkyaxes false, , legend position top, titleposition left end md\"\"\" Exercise 4 Results \"\"\" m2 RetirementModel df2 solve df m2 md\"\"\" 👉 Interpret the diagrams below. \"\"\" md\"\"\" high wealth household chooses to retire intermediate wealth household saves in order to reach retirement wealth threshold in the future low wealth household never reaches retirement threshold because \\dot a 0 \"\"\" let figure resolution 600, 300 chain df2 begin stack v star, v data mapping a, value, color variable nonnumeric visual Lines draw figure end end chain df2 begin stack c, ȧ, action data mapping a, value, layout variable visual Lines draw facet linkyaxes false, , legend position top, titleposition left end md\"\"\" Appendix \"\"\" md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"tutorials/welfare-huggett-solution/","title":"Tutorial 2 (Solution)","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 5 order 5.5 title \"Tutorial 2 Solution \" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using Roots find zero, Brent using PlutoUI TableOfContents, Slider using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using LinearAlgebra using Statistics mean using StatsBase weights using QuantEcon md\"\"\" `welfare huggett solution.jl` | Version 1.2 | last updated June 2, 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" Welfare analysis \"\"\" md\"\"\" This notebook provides a brief introduction to welfare analysis in models with household heterogeneity. There are two approaches 1. How much are newborn agents in the stationary equilibrium with the reform better off compared to the stationary equilibrium without the reform? 2. How much are agents of any age who are alive at the time of the reform better off compared to the stationary equilibrium without the reform? The second approach is more difficult because we need to take transitional dynamics after the reform into account. Therefore, this notebook covers only the first approach. We consider the introduction of an income tax in a perpetual youth version of the Huggett model. \"\"\" md\"\"\" Partial equilibrium \"\"\" md\"\"\" ```math \\begin align &\\max \\ c t\\ \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u c t \\Bigr \\\\ &\\begin aligned \\text subject to &c t k t k t 1 1 r y t T y t \\\\ &y t \\sim \\text some Markov Chain \\\\ &y 0, k 1 \\text given \\end aligned \\end align ``` There are two changes compared to the households' problem in the ```aiyagari.jl``` notebook the income tax T y t which depends on current income the death probability m Since the death probability in our model does not depend on age, the optimization problem of a 100 year old household looks the same as the one of a newborn household. This is why a model with such a demographic structure is also referred to as \"perpetual youth model\". \"\"\" md\"\"\" Parameterization \"\"\" function Household σ 1.0, β 0.96, m 1 50, u σ 1 ? log x x^ 1 σ 1 σ β, m, u end function uniform distribution n k, n z i max n k π₀ zeros n k n z π₀ 1 i max . 0.5 i max π₀ n k 1 n k i max . 0.5 i max assert sum π₀ ≈ 1. π₀' end begin death probability m 1 50 preference parameters σ 2. β 0.94 hh Household β, σ, m interest rate r 0.03 prices q 1 1 r , w 1.0, Δr 0. income process n y 2 y 1 0.75 y 2 1.25 ρ 0.75 y trans ρ 1 ρ 1 ρ ρ y chain MarkovChain y trans, y 1, y 2 asset grid n k 100 k min 0.5 k max 4.5 k vals range k min, k max, length n k distribution of newborn households over the state space π₀ uniform distribution n k, n y end md\"\"\" We start with a partial equilibrium version of the model. The interest rate r round r,digits 4 is exogenous. The death probability is m which implies an expected lifetime as an adult of 1 m years. The income process has only two states y^1 y^2 and the transition matrix is symmetric. In this case, the probability \\rho to stay in the current income state completely determines the transition matrix. We assume that there is no income tax in the initial stationary equilibrium, i.e. T y 0 . With a probability of 50% a newborn household is born into the high income state. The distribution of assets of newborn households is uniform over the asset grid. \"\"\" md\"\"\" Solving the households' problem \"\"\" md\"\"\" To solve the households' problem, we treat the perpetual youth agents as infinitely lived agents with a modified discount factor \\tilde \\beta \\beta 1 m . \"\"\" md\"\"\" Stationary distribution \"\"\" md\"\"\" The ```QuantEcon``` framework gives us a matrix Q^ with transition probabilities from y, k to y', k' for households that do not die in between periods. To compute the correct stationary distribution, we also need to take the death probability into account see lecture 1 \\pi \\infty 1 m \\cdot Q^ \\cdot \\pi \\infty m \\cdot \\pi 0 \\implies \\pi \\infty I 1 m \\cdot Q^ ^ 1 m \\cdot \\pi 0 where \\pi 0 is the distribution of newborn agents over the state space. \"\"\" function stationary distribution Q AbstractMatrix, m, π₀ π m π₀ I 1 m Q π' end md\"\"\" Tax reform \"\"\" md\"\"\" Now, let us consider the introduction of a income tax \\tau y that redistributes an amount \\tau from households in the high income state to households in the low income state T y^1 \\tau T y^2 \\tau \"\"\" τ 0.05 md\"\"\" Since there are as many households in the high income state as in the low income state, such a income tax would generate no revenues for the government. From the perspective of the households, the introduction of such an income tax is equivalent to modifying the income process y^1 \\tau y^1 T y^1 y^1 \\tau y^2 \\tau y^2 T y^2 y^2 \\tau \"\"\" y chain τ MarkovChain y trans, y 1 τ, y 2 τ md\"\"\" Below, we compute the solution to the households' problem in the stationary equilibrium with the reform. Since we consider the partial equilibrium case here, we keep the interest rate fixed. \"\"\" md\"\"\" Conditional welfare changes \\Delta k, y \"\"\" md\"\"\" We can see whether an agent who is born into state k, y is better off or not by comparing the value function in the original stationary equilibrium V k, y with the value function in the stationary equilibrium with the redistributive income tax V \\tau k, y . \"\"\" md\"\"\" \"\"\" md\"\"\" Exercise 1 Economic intuition The plot of the value functions above shows that agents who are born into the low income state are better off, as expected. However, the plot also shows that agents who are born into the high income state are better off. 👉 How is this possible? \"\"\" md\"\"\" The introduction of the redistributive income tax has two effects on the agent in the high income state 1. Current net income and expected future net incomes decrease 2. Income risk in the future decreases The first effect decreases the value function in the high income state, the second effect increases it the agents dislike income risk . It depends on the parameter values which of the two effects is more important quantitatively. \"\"\" md\"\"\" \"\"\" md\"\"\" In order to quantify the welfare changes due to the income tax, we need to transform the differences in the value functions into units of the consumption good. First, we need to make a few definitions The value function in the stationary equilibrium without the reform is ```math \\begin align V k 1 , y 0 & \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u c k t 1 , y t \\Bigr \\\\ &\\begin aligned \\text subject to &k t k t 1 1 r y t c k t 1 , y t \\\\ \\end aligned \\end align ``` The value function in the stationary equilibrium with the reform is ```math \\begin align V \\tau k 1 , y 0 & \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u c \\tau k t 1 , y t \\Bigr \\\\ &\\begin aligned \\text subject to &k t k t 1 1 r y t T y t c \\tau k t 1 , y t \\\\ \\end aligned \\end align ``` where c k,y is optimal consumption in the stationary equilibrium without the reform and c \\tau k, y is the optimal consumption in the stationary equilibrium with the reform. If consumption in the stationary equilibrium without the reform is increased by a fraction \\Delta in each state of the world, the sum of expected utilities becomes ```math \\begin align W k 1 , y 0 \\Delta & \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u 1 \\Delta c k t 1 , y t \\Bigr \\\\ &\\begin aligned \\text subject to &k t k t 1 1 r y t c k t 1 , y t \\\\ \\end aligned \\end align ``` Note that we do not allow the agent to reoptimize with respect to the relative consumption increase \\Delta in the definition of W k, y \\Delta . We can finally define the conditional welfare change for an agent born into state k,y as the relative increase in consumption \\Delta k,y in the stationary equilibrium without the reform that makes the agent as well off as in the stationary equilibrium with the reform V \\tau k,y W k,y \\Delta k,y \"\"\" md\"\"\" \"\"\" md\"\"\" Exercise 2 Formula for CRRA utility Usually the equation above needs to be solved numerically for \\Delta k,y . However, with the utility function chosen in this notebook u c \\frac c^ 1 \\sigma 1 \\sigma a simpler approach is possible. 👉 Derive a simple analytical formula for \\Delta k,y in terms of V k,y and V \\tau k,y . Hint Try to express W k,y \\Delta in terms of V k,y . \"\"\" md\"\"\" Step 1 ```math \\begin align u 1 \\Delta c & \\frac 1 \\Delta c ^ 1 \\sigma 1 \\sigma 1 \\Delta ^ 1 \\sigma u c \\\\ \\implies W k,y \\Delta & \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u 1 \\Delta c k t 1 , y t \\Bigr 1 \\Delta ^ 1 \\sigma V k, y \\end align ``` Step 2 ```math \\begin align V \\tau k,y & W k,y \\Delta \\\\ \\implies V \\tau k,y & 1 \\Delta ^ 1 \\sigma V k, y \\\\ \\implies \\Delta & \\Bigl \\frac V \\tau k,y V k,y \\Bigr ^ 1 1 \\sigma 1 \\end align ``` \"\"\" md\"\"\" 👉 Write a Julia function ```Δ CRRA``` that computes \\Delta for given values ```v τ``` and ```v``` and a given risk aversion coefficient \\sigma . \"\"\" function Δ CRRA v τ, v, σ v τ v ^ 1 1 σ 1 end md\"\"\" \"\"\" md\"\"\" After finishing the exercise above, activate the cells below, and Julia will generate a plot of \\Delta k,y . \"\"\" md\"\"\" Unconditional welfare change \\Delta \"\"\" md\"\"\" Since all agents benefit from the reform considered above, we can be sure that the aggregate welfare change is also possible regardless of how the individual utilities are aggregated . But if some agents lose and others gain, simply computing conditional welfare changes is not sufficient to understand whether a certain tax policy is desirable. For this purpose, we need to define a welfare function to aggregate the maximized utility among the newborn agents. We choose a utilitarian welfare function here V \\sum y\\in\\ y^1, y^2\\ \\int k \\min ^\\infty V k,y \\pi 0 k,y dk Since we only consider newborn agents, we integrate with respect to the distribution \\pi 0 and not with respect to the stationary distribution \\pi . The unconditional welfare change is then defined as the relative change in consumption \\Delta such that \\underbrace \\sum y\\in\\ y^1, y^2\\ \\int k \\min ^\\infty V \\tau k,y \\pi 0 k,y dk V \\tau \\sum y\\in\\ y^1, y^2\\ \\int k \\min ^\\infty W k,y \\Delta \\pi 0 k,y dk \"\"\" md\"\"\" In the special case of a CRRA utility function, the right hand side simplifies to 1 \\Delta ^ 1 \\sigma V and the unconditional welfare change is simply \\Delta \\Bigl \\frac V \\tau V \\Bigr ^ 1 1 \\sigma 1 \"\"\" md\"\"\" The unconditional welfare benefit corresponds to a relative change in consumption of approximately 1%. \"\"\" md\"\"\" It is even possible to compute welfare changes conditional on the income state y but to integrate over the asset space \"\"\" md\"\"\" \"\"\" md\"\"\" Exercise 3 Comparative statics \"\"\" md\"\"\" Explore the conditional and the unconditional welfare changes using the sliders below. \\Delta 0 k,y refers to the welfare change under the baseline parameterization, and \\Delta k,y to the welfare change with the current position of the sliders. 👉 Can you find a parameterization such that agents in the high income state have a welfare loss? \"\"\" md\"\"\" Agents in the high income state are worse off with the reform if the persistence parameter \\rho is sufficiently high e.g. \\rho 0.95 . \"\"\" md\"\"\" 👉 Try to understand how changes in the parameters \\rho and \\sigma affect the welfare of the agents. \"\"\" md\"\"\" \\sigma \\uparrow Agents in both income states decrease of income risk is valued more by agents \\implies \\Delta k,y increases \\rho \\uparrow Agents in low income state stronger positive effect on expected future incomes \\implies \\Delta k,y y^1 increases Agents in high income state stronger negative effect on expected future incomes \\implies \\Delta k,y y^2 decreases \"\"\" md\"\"\" Persistence parameter \\rho bind ρ sl Slider 0.5 0.025 0.975, show value true, default ρ \"\"\" md\"\"\" Risk aversion \\sigma bind σ sl Slider 1.25 0.25 3., show value true, default σ \"\"\" md\"\"\" \"\"\" md\"\"\" General equilibrium \"\"\" md\"\"\" Net asset supply is zero. The market clearing condition is \\sum y\\in\\ y^1, y^2\\ \\int k \\min ^\\infty k \\pi k,y dk 0 \"\"\" md\"\"\" Finding the equilibrium interest rate \"\"\" initial bracket 0.0, 0.1 md\"\"\" \"\"\" md\"\"\" Exercise 4 Economic intuition 👉 Why does the introduction of the redistributive income tax cause the interest rate in the stationary equilibrium to increase? \"\"\" md\"\"\" The higher the difference in net incomes across the two income states, the higher asset demand in the model both because of consumption smoothing and for precautionary reasons . Since the tax reform decreases the difference in net incomes, asset demand decreases and hence the interest rate has to increase. \"\"\" md\"\"\" \"\"\" md\"\"\" Welfare analysis in GE \"\"\" md\"\"\" \"\"\" md\"\"\" Exercise 5 Economic intuition 👉 Explain why the conditional welfare changes are different in general equilibrium GE compared to the partial equilibrium PE case. \"\"\" md\"\"\" Higher interest rates are bad for households that borrow, and good for households that lend. This is why the welfare gain for agents with little or no assets is lower in GE than in PE, while the welfare gain for wealthy assets is higher in GE than in PE. \"\"\" md\"\"\" \"\"\" md\"\"\" Appendix Functions from ```aiyagari.jl``` \"\"\" function statespace k vals range 1e 10, 20.0, length 200 , z chain states k, z for k ∈ k vals, z ∈ z chain.state values | vec states indices k i, z i for k i ∈ 1 length k vals , z i ∈ 1 length z chain.state values | vec policies k next for k next ∈ k vals | vec policies indices k next i for k next i ∈ 1 length k vals | vec states, states indices, policies, policies indices, z chain end function setup Q Q, states indices, policies indices, z chain for i next state, next ∈ enumerate states indices for i policy, k next i ∈ enumerate policies indices for i state, z i ∈ enumerate states indices if next.k i k next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end function consumption z, k , k next , q, w, Δr if k next 0 && Δr 0 r 1 q 1 k next 0 Δr q 1 1 r end c w z k q k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, policies, prices, u for k i, policy ∈ enumerate policies for s i, state ∈ enumerate states R s i, k i reward state, policy, prices, u end end return R end function setup R states, policies, prices, u R zeros length states , length policies setup R R, states, policies, prices, u end function setup DDP household, statespace, prices β, u, m household states, policies, states indices, policies indices statespace R setup R states, policies, prices, u Q setup Q states indices, policies indices, statespace.z chain DiscreteDP R, Q, β 1 m end md\"\"\" The function below is similar to the ```solve details``` functions from the ```aiygari.jl``` notebook \"\"\" function results to df results, states, policies, prices df DataFrame states DataFrame policies results.sigma df.state states df.value results.v df.policy policies results.sigma chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end df end function solve PE hh, ss, prices, π₀ ddp setup DDP hh, ss, prices results QuantEcon.solve ddp, PFI df results to df results, ss.states, ss.policies, prices df.π₀ π₀' , Q star RQ sigma ddp, results.sigma df.π stationary distribution Q star, hh.m, π₀ df.income ifelse. df.z . ss.z chain.state values 1 , \"low\", \"high\" df end begin ss statespace k vals, z chain y chain df solve PE hh, ss, prices, π₀ end let figure resolution 600, 300 chain df begin data mapping k, π, color income visual Lines draw figure end end begin ss τ statespace k vals, z chain y chain τ df τ solve PE hh, ss τ, prices, π₀ end let figure resolution 600, 300 df big vcat df, df τ, source \"tax reform\" \"no\", \"yes\" chain df big begin data mapping k, value, linestyle \"tax reform\", color income visual Lines draw figure end end begin dfΔ copy df dfΔ.Δ Δ CRRA. df τ.value, df.value, σ end let figure resolution 600, 300 chain dfΔ begin data mapping k, Δ, color income visual Lines draw figure end end let value mean df.value, weights df.π₀ value τ mean df τ.value, weights df τ.π₀ Δ CRRA value τ, value, σ end let Δ z zeros n y df groups groupby df, z df τ groups groupby df τ, z for i y in 1 n y df z df groups i y df τ z df τ groups i y value mean df z.value, weights df z.π₀ value τ mean df τ z.value, weights df τ z.π₀ Δ z i y Δ CRRA value τ, value, σ end Δ z end let solve model in both stationary equilibria hh sl Household β β, σ σ sl, m m y trans sl ρ sl 1 ρ sl 1 ρ sl ρ sl y chain sl MarkovChain y trans sl, y 1, y 2 y chain τ sl MarkovChain y trans sl, y 1 τ, y 2 τ ss sl statespace k vals, z chain y chain sl ss τ sl statespace k vals, z chain y chain τ sl df sl solve PE hh sl, ss sl, prices, π₀ df τ sl solve PE hh sl, ss τ sl, prices, π₀ compute conditional and unconditional welfare changes df sl.Δ Δ CRRA. df τ sl.value, df sl.value, σ sl value mean df.value, weights df.π₀ value τ mean df τ.value, weights df τ.π₀ Δ Δ CRRA. value τ, value, σ value sl mean df sl.value, weights df sl.π₀ value τ sl mean df τ sl.value, weights df τ sl.π₀ Δ sl Δ CRRA. value τ sl, value sl, σ sl print \"Δ₀ \", round Δ 100, digits 2 , \"%\\n\" print \"Δ \", round Δ sl 100, digits 2 , \"%\" plot conditional welfare changes figure resolution 600, 300 df big vcat dfΔ, df sl, source parameters \"default\", \"sliders\" chain df big begin data mapping k, Δ, linestyle parameters \"parameters\", color income nonnumeric \"income\" visual Lines draw figure end end function net asset demand hh, ss, r, π₀ prices q 1 1 r , w 1.0, Δr 0. df solve PE hh, ss, prices, π₀ mean df.k, weights df.π end r eq find zero r net asset demand hh, ss, r, π₀ , initial bracket, Brent , atol 1e 6, rtol 1e 6, xatol 1e 6, xrtol 1e 6 r eq τ find zero r net asset demand hh, ss τ, r, π₀ , initial bracket, Brent , atol 1e 6, rtol 1e 6, xatol 1e 6, xrtol 1e 6 begin prices eq q 1 1 r eq , w 1.0, Δr 0. prices τ eq q 1 1 r eq τ , w 1.0, Δr 0. df eq solve PE hh, ss, prices eq, π₀ df τ noeq solve PE hh, ss τ, prices eq, π₀ df τ eq solve PE hh, ss τ, prices τ eq, π₀ df τ noeq.Δ Δ CRRA. df τ noeq.value, df eq.value, σ df τ eq.Δ Δ CRRA. df τ eq.value, df eq.value, σ end let value mean df eq.value, weights df eq.π₀ value τ mean df τ eq.value, weights df τ eq.π₀ Δ CRRA value τ, value, σ end let figure resolution 600, 300 df big vcat df τ noeq, df τ eq, source equilibrium \"PE\", \"GE\" chain df big begin data mapping k, Δ, linestyle equilibrium, color income visual Lines draw figure end end md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"tutorials/welfare-huggett/","title":"Tutorial 2","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 7 section 5 order 5 title \"Tutorial 2\" layout \"layout.jlhtml\" tags \"assignments\" description \"\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using Roots find zero, Brent using PlutoUI TableOfContents, Slider using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using LinearAlgebra using Statistics mean using StatsBase weights using QuantEcon md\"\"\" `welfare huggett.jl` | Version 1.2 | last updated June 2, 2023 | created by Daniel Schmidt https github.com danieljschmidt \"\"\" md\"\"\" Welfare analysis \"\"\" md\"\"\" This notebook provides a brief introduction to welfare analysis in models with household heterogeneity. There are two approaches 1. How much are newborn agents in the stationary equilibrium with the reform better off compared to the stationary equilibrium without the reform? 2. How much are agents of any age who are alive at the time of the reform better off compared to the stationary equilibrium without the reform? The second approach is more difficult because we need to take transitional dynamics after the reform into account. Therefore, this notebook covers only the first approach. We consider the introduction of an income tax in a perpetual youth version of the Huggett model. \"\"\" md\"\"\" Partial equilibrium \"\"\" md\"\"\" ```math \\begin align &\\max \\ c t\\ \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u c t \\Bigr \\\\ &\\begin aligned \\text subject to &c t k t k t 1 1 r y t T y t \\\\ &y t \\sim \\text some Markov Chain \\\\ &y 0, k 1 \\text given \\end aligned \\end align ``` There are two changes compared to the households' problem in the ```aiyagari.jl``` notebook the income tax T y t which depends on current income the death probability m Since the death probability in our model does not depend on age, the optimization problem of a 100 year old household looks the same as the one of a newborn household. This is why a model with such a demographic structure is also referred to as \"perpetual youth model\". \"\"\" md\"\"\" Parameterization \"\"\" function Household σ 1.0, β 0.96, m 1 50, u σ 1 ? log x x^ 1 σ 1 σ β, m, u end function uniform distribution n k, n z i max n k π₀ zeros n k n z π₀ 1 i max . 0.5 i max π₀ n k 1 n k i max . 0.5 i max assert sum π₀ ≈ 1. π₀' end begin death probability m 1 50 preference parameters σ 2. β 0.94 hh Household β, σ, m interest rate r 0.03 prices q 1 1 r , w 1.0, Δr 0. income process n y 2 y 1 0.75 y 2 1.25 ρ 0.75 y trans ρ 1 ρ 1 ρ ρ y chain MarkovChain y trans, y 1, y 2 asset grid n k 100 k min 0.5 k max 4.5 k vals range k min, k max, length n k distribution of newborn households over the state space π₀ uniform distribution n k, n y end md\"\"\" We start with a partial equilibrium version of the model. The interest rate r r is exogenous. The death probability is m which implies an expected lifetime as an adult of 1 m years. The income process has only two states y^1 y^2 and the transition matrix is symmetric. In this case, the probability \\rho to stay in the current income state completely determines the transition matrix. We assume that there is no income tax in the initial stationary equilibrium, i.e. T y 0 . With a probability of 50% a newborn household is born into the high income state. The distribution of assets of newborn households is uniform over the asset grid. \"\"\" md\"\"\" Solving the households' problem \"\"\" md\"\"\" To solve the households' problem, we treat the perpetual youth agents as infinitely lived agents with a modified discount factor \\tilde \\beta \\beta 1 m . \"\"\" md\"\"\" Stationary distribution \"\"\" md\"\"\" The ```QuantEcon``` framework gives us a matrix Q^ with transition probabilities from y, k to y', k' for households that do not die in between periods. To compute the correct stationary distribution, we also need to take the death probability into account see lecture 1 \\pi \\infty 1 m \\cdot Q^ \\cdot \\pi \\infty m \\cdot \\pi 0 \\implies \\pi \\infty I 1 m \\cdot Q^ ^ 1 m \\cdot \\pi 0 where \\pi 0 is the distribution of newborn agents over the state space. \"\"\" function stationary distribution Q AbstractMatrix, m, π₀ π m π₀ I 1 m Q π' end md\"\"\" Tax reform \"\"\" md\"\"\" Now, let us consider the introduction of a income tax \\tau y that redistributes an amount \\tau from households in the high income state to households in the low income state T y^1 \\tau T y^2 \\tau \"\"\" τ 0.05 md\"\"\" Since there are as many households in the high income state as in the low income state, such a income tax would generate no revenues for the government. From the perspective of the households, the introduction of such an income tax is equivalent to modifying the income process y^1 \\tau y^1 T y^1 y^1 \\tau y^2 \\tau y^2 T y^2 y^2 \\tau \"\"\" y chain τ MarkovChain y trans, y 1 τ, y 2 τ md\"\"\" Below, we compute the solution to the households' problem in the stationary equilibrium with the reform. Since we consider the partial equilibrium case here, we keep the interest rate fixed. \"\"\" md\"\"\" Conditional welfare changes \\Delta k, y \"\"\" md\"\"\" We can see whether an agent who is born into state k, y is better off or not by comparing the value function in the original stationary equilibrium V k, y with the value function in the stationary equilibrium with the redistributive income tax V \\tau k, y . \"\"\" md\"\"\" \"\"\" md\"\"\" Exercise 1 Economic intuition The plot of the value functions above shows that agents who are born into the low income state are better off, as expected. However, the plot also shows that agents who are born into the high income state are better off. 👉 How is this possible? \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" \"\"\" md\"\"\" In order to quantify the welfare changes due to the income tax, we need to transform the differences in the value functions into units of the consumption good. First, we need to make a few definitions The value function in the stationary equilibrium without the reform is ```math \\begin align V k 1 , y 0 & \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u c k t 1 , y t \\Bigr \\\\ &\\begin aligned \\text subject to &k t k t 1 1 r y t c k t 1 , y t \\\\ \\end aligned \\end align ``` The value function in the stationary equilibrium with the reform is ```math \\begin align V \\tau k 1 , y 0 & \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u c \\tau k t 1 , y t \\Bigr \\\\ &\\begin aligned \\text subject to &k t k t 1 1 r y t T y t c \\tau k t 1 , y t \\\\ \\end aligned \\end align ``` where c k,y is optimal consumption in the stationary equilibrium without the reform and c \\tau k, y is the optimal consumption in the stationary equilibrium with the reform. If consumption in the stationary equilibrium without the reform is increased by a fraction \\Delta in each state of the world, the sum of expected utilities becomes ```math \\begin align W k 1 , y 0 \\Delta & \\operatorname E 0\\Bigl \\sum t 0 ^\\infty \\beta^t 1 m ^t u 1 \\Delta c k t 1 , y t \\Bigr \\\\ &\\begin aligned \\text subject to &k t k t 1 1 r y t c k t 1 , y t \\\\ \\end aligned \\end align ``` Note that we do not allow the agent to reoptimize with respect to the relative consumption increase \\Delta in the definition of W k, y \\Delta . We can finally define the conditional welfare change for an agent born into state k,y as the relative increase in consumption \\Delta k,y in the stationary equilibrium without the reform that makes the agent as well off as in the stationary equilibrium with the reform V \\tau k,y W k,y \\Delta k,y \"\"\" md\"\"\" \"\"\" md\"\"\" Exercise 2 Formula for CRRA utility Usually the equation above needs to be solved numerically for \\Delta k,y . However, with the utility function chosen in this notebook u c \\frac c^ 1 \\sigma 1 \\sigma a simpler approach is possible. 👉 Derive a simple analytical formula for \\Delta k,y in terms of V k,y and V \\tau k,y . Hint Try to express W k,y \\Delta in terms of V k,y . \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 Write a Julia function ```Δ CRRA``` that computes \\Delta for given values ```v τ``` and ```v``` and a given risk aversion coefficient \\sigma . \"\"\" function Δ CRRA v τ, v, σ NaN Your code goes here end md\"\"\" \"\"\" md\"\"\" After finishing the exercise above, activate the cells below, and Julia will generate a plot of \\Delta k,y . \"\"\" md\"\"\" Unconditional welfare change \\Delta \"\"\" md\"\"\" Since all agents benefit from the reform considered above, we can be sure that the aggregate welfare change is also possible regardless of how the individual utilities are aggregated . But if some agents lose and others gain, simply computing conditional welfare changes is not sufficient to understand whether a certain tax policy is desirable. For this purpose, we need to define a welfare function to aggregate the maximized utility among the newborn agents. We choose a utilitarian welfare function here V \\sum y\\in\\ y^1, y^2\\ \\int k \\min ^\\infty V k,y \\pi 0 k,y dk Since we only consider newborn agents, we integrate with respect to the distribution \\pi 0 and not with respect to the stationary distribution \\pi . The unconditional welfare change is then defined as the relative change in consumption \\Delta such that \\underbrace \\sum y\\in\\ y^1, y^2\\ \\int k \\min ^\\infty V \\tau k,y \\pi 0 k,y dk V \\tau \\sum y\\in\\ y^1, y^2\\ \\int k \\min ^\\infty W k,y \\Delta \\pi 0 k,y dk \"\"\" md\"\"\" In the special case of a CRRA utility function, the right hand side simplifies to 1 \\Delta ^ 1 \\sigma V and the unconditional welfare change is simply \\Delta \\Bigl \\frac V \\tau V \\Bigr ^ 1 1 \\sigma 1 \"\"\" md\"\"\" The unconditional welfare benefit corresponds to a relative change in consumption of approximately 1%. \"\"\" md\"\"\" It is even possible to compute welfare changes conditional on the income state y but to integrate over the asset space \"\"\" md\"\"\" \"\"\" md\"\"\" Exercise 3 Comparative statics \"\"\" md\"\"\" Explore the conditional and the unconditional welfare changes using the sliders below. \\Delta 0 k,y refers to the welfare change under the baseline parameterization, and \\Delta k,y to the welfare change with the current position of the sliders. 👉 Can you find a parameterization such that agents in the high income state have a welfare loss? \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" 👉 Try to understand how changes in the parameters \\rho and \\sigma affect the welfare of the agents. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" Persistence parameter \\rho bind ρ sl Slider 0.5 0.025 0.975, show value true, default ρ \"\"\" md\"\"\" Risk aversion \\sigma bind σ sl Slider 1.25 0.25 3., show value true, default σ \"\"\" md\"\"\" \"\"\" md\"\"\" General equilibrium \"\"\" md\"\"\" Net asset supply is zero. The market clearing condition is \\sum y\\in\\ y^1, y^2\\ \\int k \\min ^\\infty k \\pi k,y dk 0 \"\"\" md\"\"\" Finding the equilibrium interest rate \"\"\" initial bracket 0.0, 0.1 md\"\"\" \"\"\" md\"\"\" Exercise 4 Economic intuition 👉 Why does the introduction of the redistributive income tax cause the interest rate in the stationary equilibrium to increase? \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" \"\"\" md\"\"\" Welfare analysis in GE \"\"\" md\"\"\" \"\"\" md\"\"\" Exercise 5 Economic intuition 👉 Explain why the conditional welfare changes are different in general equilibrium GE compared to the partial equilibrium PE case. \"\"\" md\"\"\" Your answer goes here ... \"\"\" md\"\"\" \"\"\" md\"\"\" Appendix Functions from ```aiyagari.jl``` \"\"\" function statespace k vals range 1e 10, 20.0, length 200 , z chain states k, z for k ∈ k vals, z ∈ z chain.state values | vec states indices k i, z i for k i ∈ 1 length k vals , z i ∈ 1 length z chain.state values | vec policies k next for k next ∈ k vals | vec policies indices k next i for k next i ∈ 1 length k vals | vec states, states indices, policies, policies indices, z chain end function setup Q Q, states indices, policies indices, z chain for i next state, next ∈ enumerate states indices for i policy, k next i ∈ enumerate policies indices for i state, z i ∈ enumerate states indices if next.k i k next i Q i state, i policy, i next state z chain.p z i, next.z i end end end end return Q end function setup Q states indices, policies indices, z chain Q zeros length states indices , length policies indices , length states indices setup Q Q, states indices, policies indices, z chain Q end function consumption z, k , k next , q, w, Δr if k next 0 && Δr 0 r 1 q 1 k next 0 Δr q 1 1 r end c w z k q k next end function reward state, policy, prices, u c consumption state, policy, prices if c 0 u c else 100 000 100 c end end function setup R R, states, policies, prices, u for k i, policy ∈ enumerate policies for s i, state ∈ enumerate states R s i, k i reward state, policy, prices, u end end return R end function setup R states, policies, prices, u R zeros length states , length policies setup R R, states, policies, prices, u end function setup DDP household, statespace, prices β, u, m household states, policies, states indices, policies indices statespace R setup R states, policies, prices, u Q setup Q states indices, policies indices, statespace.z chain DiscreteDP R, Q, β 1 m end md\"\"\" The function below is similar to the ```solve details``` functions from the ```aiygari.jl``` notebook \"\"\" function results to df results, states, policies, prices df DataFrame states DataFrame policies results.sigma df.state states df.value results.v df.policy policies results.sigma chain df begin transform consumption consumption state, policy, prices transform saving k next k select Not state, policy end df end function solve PE hh, ss, prices, π₀ ddp setup DDP hh, ss, prices results QuantEcon.solve ddp, PFI df results to df results, ss.states, ss.policies, prices df.π₀ π₀' , Q star RQ sigma ddp, results.sigma df.π stationary distribution Q star, hh.m, π₀ df.income ifelse. df.z . ss.z chain.state values 1 , \"low\", \"high\" df end begin ss statespace k vals, z chain y chain df solve PE hh, ss, prices, π₀ end let figure resolution 600, 300 chain df begin data mapping k, π, color income visual Lines draw figure end end begin ss τ statespace k vals, z chain y chain τ df τ solve PE hh, ss τ, prices, π₀ end let figure resolution 600, 300 df big vcat df, df τ, source \"tax reform\" \"no\", \"yes\" chain df big begin data mapping k, value, linestyle \"tax reform\", color income visual Lines draw figure end end begin dfΔ copy df dfΔ.Δ Δ CRRA. df τ.value, df.value, σ end let figure resolution 600, 300 chain dfΔ begin data mapping k, Δ, color income visual Lines draw figure end end let value mean df.value, weights df.π₀ value τ mean df τ.value, weights df τ.π₀ Δ CRRA value τ, value, σ end let Δ z zeros n y df groups groupby df, z df τ groups groupby df τ, z for i y in 1 n y df z df groups i y df τ z df τ groups i y value mean df z.value, weights df z.π₀ value τ mean df τ z.value, weights df τ z.π₀ Δ z i y Δ CRRA value τ, value, σ end Δ z end let solve model in both stationary equilibria hh sl Household β β, σ σ sl, m m y trans sl ρ sl 1 ρ sl 1 ρ sl ρ sl y chain sl MarkovChain y trans sl, y 1, y 2 y chain τ sl MarkovChain y trans sl, y 1 τ, y 2 τ ss sl statespace k vals, z chain y chain sl ss τ sl statespace k vals, z chain y chain τ sl df sl solve PE hh sl, ss sl, prices, π₀ df τ sl solve PE hh sl, ss τ sl, prices, π₀ compute conditional and unconditional welfare changes df sl.Δ Δ CRRA. df τ sl.value, df sl.value, σ sl value mean df.value, weights df.π₀ value τ mean df τ.value, weights df τ.π₀ Δ Δ CRRA. value τ, value, σ value sl mean df sl.value, weights df sl.π₀ value τ sl mean df τ sl.value, weights df τ sl.π₀ Δ sl Δ CRRA. value τ sl, value sl, σ sl print \"Δ₀ \", round Δ 100, digits 2 , \"%\\n\" print \"Δ \", round Δ sl 100, digits 2 , \"%\" plot conditional welfare changes figure resolution 600, 300 df big vcat dfΔ, df sl, source parameters \"default\", \"sliders\" chain df big begin data mapping k, Δ, linestyle parameters \"parameters\", color income nonnumeric \"income\" visual Lines draw figure end end function net asset demand hh, ss, r, π₀ prices q 1 1 r , w 1.0, Δr 0. df solve PE hh, ss, prices, π₀ mean df.k, weights df.π end r eq find zero r net asset demand hh, ss, r, π₀ , initial bracket, Brent , atol 1e 6, rtol 1e 6, xatol 1e 6, xrtol 1e 6 r eq τ find zero r net asset demand hh, ss τ, r, π₀ , initial bracket, Brent , atol 1e 6, rtol 1e 6, xatol 1e 6, xrtol 1e 6 begin prices eq q 1 1 r eq , w 1.0, Δr 0. prices τ eq q 1 1 r eq τ , w 1.0, Δr 0. df eq solve PE hh, ss, prices eq, π₀ df τ noeq solve PE hh, ss τ, prices eq, π₀ df τ eq solve PE hh, ss τ, prices τ eq, π₀ df τ noeq.Δ Δ CRRA. df τ noeq.value, df eq.value, σ df τ eq.Δ Δ CRRA. df τ eq.value, df eq.value, σ end let value mean df eq.value, weights df eq.π₀ value τ mean df τ eq.value, weights df τ eq.π₀ Δ CRRA value τ, value, σ end let figure resolution 600, 300 df big vcat df τ noeq, df τ eq, source equilibrium \"PE\", \"GE\" chain df big begin data mapping k, Δ, linestyle equilibrium, color income visual Lines draw figure end end md\"\"\" Imported packages \"\"\" TableOfContents "},{"url":"unfinished/athreya/","title":"Athreya (consumer bankruptcy)","tags":["unfinished"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 8 section 1 order 1 title \"Athreya consumer bankruptcy \" layout \"layout.jlhtml\" tags \"unfinished\" description \"\" using Markdown using InteractiveUtils using PlutoUI using AlgebraOfGraphics, CairoMakie using AlgebraOfGraphics draw using DataFrameMacros using Chain chain using DataFrames using StatsBase weights using Statistics mean using LinearAlgebra using QuantEcon md\"\"\" danger \"Under construction \" This notebook is not ready for public consumption. Use at your own risk. \"\"\" md\"\"\" `athreya.jl` | Version 0.1 | last updated Mar 24 2022 \"\"\" md\"\"\" Unsecured debt and default Athreya 2002 \"\"\" md\"\"\" Households' problem \"\"\" md\"\"\" Setup \"\"\" function statespace a vals range 1e 10, 20.0, length 200 , z chain, d vals 0, 1 solvent, borrowing constrained states a, d, z for a ∈ a vals, d ∈ d vals, z ∈ z chain.state values | vec states indices a i, d i, z i for a i ∈ 1 length a vals , d i ∈ 1 length d vals , z i ∈ 1 length z chain.state values | vec policies a next, d next for a next ∈ a vals, d next ∈ d vals | vec policies indices a next i, d next i for a next i ∈ 1 length a vals , d next i ∈ 1 length d vals | vec states, states indices, policies, policies indices, z chain end function Household σ 1.0, β 0.96, u σ 1 ? log x x^ 1 σ 1 1 σ β, u end function consumption z, a, d , d next, a next , q, w , Δr default d 0 && d next 1 constrained d 1 || d next 1 if a next 0 && Δr 0 r 1 q 1 a next 0 Δr q 1 1 r end repay default ? 0 a c w z repay q a next end function reward state, policy, prices, params, u d state d next, a next policy λ params default d 0 && d next 1 constrained d 1 || d next 1 if constrained && a next 0 c 999999.0 100 a next else c consumption state, policy, prices, params end if c 0 u c λ default else 1 000 000 c end end reward. am.s vals new, permutedims am.a vals new , Ref am.prices , am.u function setup R R, states, policies, prices, params, u for a i, policy ∈ enumerate policies for s i, state ∈ enumerate states R s i, a i reward state, policy, prices, params, u end end return R end function setup R states, policies, prices, params, u R zeros length states , length policies setup R R, states, policies, prices, params, u end md\"\"\" State space \"\"\" q r 1 1 r Create an instance of Household am Household md\"\"\" Solve Households' problem \"\"\" function solve details ddp, states, policies solver PFI results solve ddp, solver df DataFrame states DataFrame policies results.sigma df.state states df.policy policies results.sigma df.π stationary distributions results.mc , 1 1 df end md\"\"\" Policy functions – How much to invest next period? \"\"\" md\"\"\" Parameters to play with policy parameters ``\\lambda`` punishment stigma and ``\\rho`` exclusion from financial markets \"\"\" λ 0.6 ρ 0.75 function setup Q Q, states, states indices, policies, policies indices, z chain, params for I next, next, i next ∈ enumerate zip states, states indices d next next.d for I policy, policy, i policy ∈ enumerate zip policies, policies indices d chosen policy.d next for I state, state, i state ∈ enumerate zip states, states indices d state.d if i next.a i i policy.a next i pr z chain.p i state.z i, i next.z i if d 0 && d next d chosen Q I state, I policy, I next pr elseif d 1 && 1 d next Q I state, I policy, I next 1 ρ pr elseif d 1 && 0 d next Q I state, I policy, I next ρ pr end end end end end return Q end function setup Q states, states indices, policies, policies indices, z chain, params Q zeros length states indices , length policies indices , length states indices setup Q Q, states, states indices, policies, policies indices, z chain, params Q end r 0.0188 Δr 0.3 prices q q r , w 1.0, Δr params λ, Δr, ρ ε 0.25 z chain MarkovChain 1 ε ε ε 1 ε , 1.25, 0.75 function setup DDP household, statespace, prices, params β, u household states, policies, states indices, policies indices statespace R setup R states, policies, prices, params, u Q setup Q states, states indices, policies, policies indices, z chain, params DiscreteDP R, Q, β end ss statespace a vals range 1, 1.0, length 200 , z chain Use the instance to build a discrete dynamic program am ddp setup DDP am, ss, prices, params Solve using policy function iteration results0 solve details am ddp, ss.states, ss.policies, solver PFI results chain results0 begin transform consumption consumption state, policy, prices, params transform saving a next a select Not state, policy end results let fg chain results begin stack Not a, z, π, d a next, consumption, saving data mapping a L\"current assets a \", value \"policy\", layout variable, color z nonnumeric, linestyle d nonnumeric visual Lines select Not d next draw facet linkyaxes false, , legend position top, titleposition left end ax content fg.figure 2,1 abline ax, 0, 1, color gray, linestyle dash, loose fg end chain results begin subset a next a groupby z combine first a end md\"\"\" Stationary distribution \"\"\" chain results begin data mapping a, π, linestyle d nonnumeric, color z nonnumeric visual Lines draw end chain results begin groupby a combine π sum π data mapping a, π visual Lines draw end md\"\"\" Aggregate outcomes \"\"\" chain results begin stack Not π groupby variable combine mean value, weights π end md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"unfinished/hank-econpdes/","title":"HANK with EconPDEs.jl","tags":["unfinished"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 8 section 2 order 2 title \"HANK with EconPDEs.jl\" layout \"layout.jlhtml\" tags \"unfinished\" description \"\" using Markdown using InteractiveUtils using Distributions using CairoMakie using PlutoUI using EconPDEs using EconPDEs StateGrid md\"\"\" `hank econpdes.jl` | Version 0.1 | last updated May 10 2022 \"\"\" md\"\"\" HANK \"\"\" u c, γ c 0 ? γ 1 ? log c c^ 1 γ 1 γ 100 c 1000 u prime c, γ c^ γ u prime inv x, γ x^ 1 γ rb b, rb pos, rb neg b 0 ? rb neg rb pos ra a, ra, τ, amax ra 1 1.33 amax a ^ 1 τ χ d, a, χ₀, χ₁ χ₀ abs d χ₁ d^2 2 max a,10^ 5 ^ 1 function two asset kinked foc va, vb, a, χ₀, χ₁ d min va vb 1 χ₀, 0 a χ₁ max va vb 1 χ₀,0 a χ₁ end function c bdot vb, b, z , param ξ, w param vb max vb, √√eps c star u prime inv vb, param b dot c 1 ξ w z b rb b, param c star bdrift1 Hc u c star, param vb b dot c vb c vb, c star, b dot c, Hc end function c bdot₀ b, z , param ξ, w param c star 1 ξ w z rb b, param b bdrift1 0 vb c u prime c star, param b dot c 0.0 Hc u c star, param vb c, c star, b dot c, Hc end function d bdot va, vb, a, b, z , param va max va, √eps vb max vb, √eps d star two asset kinked foc va, vb, a, param b dot d d star χ d star, a, param bdrift2 a dot d d star adrift2 d Hd va a dot d vb b dot d va d va, vb d vb, d star, b dot d, a dot d, Hd end function d bdot₀ a, b, z , param a dot d 0.0 d star 0.0 b dot d 0.0 va d 0.0, vb d 0.0, d star, b dot d, a dot d end function policies drifts₀ a, b, z , param ξ, w param c star 1 ξ w z rb b, param b vk u prime c star γ b dot c 0.0 c star, b dot c end begin Base. kwdef struct SimpleHANK γ 2.0 ga 2 %CRRA utility with parameter gamma ra 0.05 rb pos 0.03 rb neg 0.12 ρ 0.06 %discount rate χ₀ 0.03 χ₁ 2.0 τ 10 ξ 0.1 %fraction of income that is automatically deposited if ra 1 cχ₁ 0 warn \"Warning ra 1 χ₁ 0\" end Income process two state Poisson process w 4 Nz 2 z .8, 1.3 la mat 1 3 1 3 1 3 1 3 bmin 2.0 0 bmax 40 amin 0 amax 70 κz 0.1 zbar 1.0 σz 0.07 end function m SimpleHANK state NamedTuple, y NamedTuple ρ, ξ, w, amax, amin, bmin m Only relevant for RBC if haskey state, z z state vz up, vz down, vzz y κz, zbar, σz m μz κz zbar z vz μz 0 ? vz up vz down exo μz vz 0.5 vzz σz^2 else exo 0 state z 2, state... end a, b, z state v, va up, va down, vb up, vb down, vaa, vbb, vab y consumption U c bdot vb up, state, m D c bdot vb down, state, m O c bdot₀ state, m if U.b dot c 0.0 && D.b dot c ≥ 0.0 || U.Hc ≥ D.Hc && U.Hc ≥ O.Hc out c U elseif D.b dot c 0.0 && U.b dot c 0.0 || D.Hc ≥ U.Hc && D.Hc ≥ O.Hc out c D else out c O end if b ≈ bmin && out c.b dot c ≤ 0.0 out c O end vb c, c star, b dot c out c deposits try all combinations of va and vb UU d bdot va up, vb up, state, m DD d bdot va down, vb down, state, m UD d bdot va up, vb down, state, m DU d bdot va down, vb up, state, m OO d bdot₀ state, m vb d max vb up vb down 2, eps validUU UU.a dot d 0 && UU.b dot d 0 && UU.Hd 0 && a amax validDD DD.a dot d 0 && DD.b dot d 0 && DD.Hd 0 && a amin validUD UD.a dot d 0 && UD.b dot d 0 && UD.Hd 0 && a amax validDU DU.a dot d 0 && DU.b dot d 0 && DU.Hd 0 && a amin valid d sum validUU, validDD, validUD, validDD if validUD && validDU || UD.Hd ≥ DU.Hd && validDD || UD.Hd ≥ DD.Hd out UD dir 1 elseif validDU && validUD || DU.Hd ≥ UD.Hd && validDD || DU.Hd ≥ DD.Hd out DU dir 2 elseif validDD && validUD || DD.Hd ≥ UD.Hd && validDU || DD.Hd ≥ DU.Hd out DD dir 3 elseif validUU && validUD || DD.Hd ≥ UD.Hd && validDU || DD.Hd ≥ DU.Hd out UU dir 4 elseif DU.a dot 0 && DU.b dot d 0 out DU dir 4 elseif validDD && validUD && validDU out OO dir 5 else error \"Unreachable reached\" end va d, vb d, d star, a dot d, b dot d out va a a 0 ? va down va up endo u c star, m vb c b dot c vb d b dot d va d a dot d va a ra a, m a vt ρ v endo exo vt , c star, d star, dir, valid d end end grids bmin, bmax, amin, amax, κz, zbar, σz let I 50 100 bmax 40 b grid range bmin,bmax,I J 25 50 amin 0 amax 70 a grid range amin, amax, J distribution Gamma 2 κz zbar σz^2, σz^2 2 κz z grid range quantile distribution, 0.01 , quantile distribution, 0.99 , length 5 a grid, b grid , z grid end v0 a, b, z, ρ, ξ, ra, rb neg, γ, w u 1 ξ w z ra a rb neg b, γ ρ begin m SimpleHANK amax 100, bmax 50 g grids m yend OrderedDict v v0 a, b, 1, m for a ∈ g.a grid, b ∈ g.b grid , z ∈ g.z grid stategrid OrderedDict a g.a grid, b g.b grid , z g.z grid result pdesolve m, stategrid, yend , 0.0001 0.0001 0.0010 assert result.residual norm 1e 5 end surface result.zero v , axis type Axis3, .zero v | allunique surface result.optional c star , axis type Axis3, surface g.a grid, g.b grid, result.optional d star , axis type Axis3, hist vec result.optional dir hist vec result.optional valid d md\"\"\" Appendix \"\"\" TableOfContents begin admonition kind, title, text Markdown.MD Markdown.Admonition kind, title, text hint text, title \"Hint\" admonition \"hint\", title, text warning text, title \"Warning\" admonition \"warning\", title, text danger text, title \"Danger\" admonition \"danger\", title, text correct text, title \"Correct\" admonition \"correct\", title, text almost text warning text, \"Almost there \" keep working text md\"The answer is not quite right.\" danger text, \"Keep working on it \" yays md\"Great \", md\"Yay ❤\", md\"Great 🎉\", md\"Well done \", md\"Keep it up \", md\"Good job \", md\"Awesome \", md\"You got the right answer \", md\"Let's move on to the next section.\" got it text rand yays correct text, \"Got it \" end danger md\" This notebook is not ready for public consumption. Use at your own risk.\", \"Under construction \" md\"\"\" Patching `EconPDEs.jl` EconPDEs doesn't allow three state variables \"\"\" Δy up y, i, Δx y i 1 y i Δx Δy down y, i, Δx y i y i 1 Δx Δy central y, i, Δx y i 1 y i 1 Δx function Δgrid grid, i last length grid inbounds down grid max i, 2 grid max i 1, 1 inbounds up grid min i 1, last grid min i, last 1 central up down avg central 2 up, down, avg, central end deriv names fun name, state name Symbol fun name, state name, \" \", up , Symbol fun name, state name, \" \", down , Symbol fun name, state name, state name function Δy y, bc, i, Δx, fun name, state name up i length y ? Δy up y, i, Δx.up bc i down i 1 ? Δy down y, i, Δx.down bc i second up down Δx.avg NamedTuple deriv names fun name, state name up, down, second end function cross difference y, grids, inds assert length grids length inds length size y 2 i1, i2 Tuple inds grid1, grid2 grids Δx1 Δgrid grid1, i1 Δx2 Δgrid grid2, i2 i1 lo max i1 1, 1 i1 hi min i1 1, length grid1 if i2 1 a Δy up view y, i1 hi, , i2, Δx2.central use Δx2.up? b Δy up view y, i1 lo, , i2, Δx2.central use Δx2.up? elseif i2 length grid2 a Δy down view y, i1 hi, , i2, Δx2.central use Δx2.down? b Δy down view y, i1 lo, , i2, Δx2.central use Δx2.down? else a Δy central view y, i1 hi, , i2, Δx2.central b Δy central view y, i1 lo, , i2, Δx2.central end vab a b Δx1.central adjust Δx1.central when i1 is adjusted? end function select all but one dim y0, dim inds drop y reshape view y0, , size y0 for dim drop, i drop ∈ reverse dim inds drop y selectdim y, dim drop, i drop end y end three state variables function differentiate Tsolution, grid StateGrid Any, 3, NamedTuple , y, inds, bc solnames Tsolution.parameters 1 grids grid.x statenames collect keys grids dim inds dim, i for dim, i ∈ enumerate Tuple inds n states length grids nts map enumerate solnames do k, solname yk selectdim y, n states 1, k bck selectdim bc, n states 1, k upwind differences for each state nts1 map enumerate statenames do dim, statename i inds dim grid grids statename Δx Δgrid grid, i dim inds drop dim inds Not dim y sub select all but one dim yk, dim inds drop bc sub select all but one dim bck, dim inds drop va Δy y sub, bc sub, i, Δx, solname, statename end upwind cross differences for each combination of state nts2 map dim inds do dim drop, i drop state drop statenames dim drop sub grids delete grids, state drop sub inds Tuple inds ... Not dim drop sub y selectdim yk, dim drop, i drop sub bc selectdim bck, dim drop, i drop sub statenames filter state drop , statenames vab cross difference sub y, sub grids, sub inds cross name Symbol solname, sub statenames... Symbol solname, sub statenames... vab end solname yk Tuple inds ... , merge nts1... ..., merge nts2... ... end merge nts... end "},{"url":"unfinished/housing-ct/","title":"Housing in CT","tags":["unfinished"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 8 section 3 order 3 title \"Housing in CT\" layout \"layout.jlhtml\" tags \"unfinished\" description \"\" using Markdown using InteractiveUtils using EconPDEs using Optim using Roots using CairoMakie, AlgebraOfGraphics using DataFrames, Chain, DataFrameMacros using PlutoTest using ForwardDiff using PlutoUI md\"\"\" ```math \\begin align &\\max c t, x t t \\geq 0 \\int 0^\\infty \\exp \\rho t u c t, h t dt \\\\ &\\begin aligned \\text s.t. & \\dot a t ra t c t p x t \\\\ &\\dot h t x t \\delta h t \\\\ &a t \\geq \\theta p h t \\end aligned \\end align ``` The HJB equation is ```math r \\cdot v a, h \\max c, x u c,h v a a, h \\cdot r a c p x v h a, h \\cdot x \\delta h ``` The first order conditions are ```math \\begin align u c c, h & v a a, h \\\\ 0 & v a a, h p v h a, h \\end align ``` \"\"\" md\"\"\" Simple Housing no adjustment costs \"\"\" md\"\"\" ```math \\begin align &\\max c t, x t t \\geq 0 \\int 0^\\infty \\exp \\rho t u c t, h t dt \\\\ &\\begin aligned \\text s.t. & w t a t p h t \\\\ &\\dot w t r w t ph t c t \\delta p h t \\\\ &w t \\geq 1 \\theta p h t \\end aligned \\end align ``` The HJB equation is ```math r \\cdot v w \\max c, h u c,h v w w \\cdot r w t p h t c p \\delta h t ``` The first order conditions are ```math \\begin align u c c, h & v w w \\\\ u h c, h & v w w \\cdot p r \\delta \\\\ \\end align ``` \"\"\" function u c, h, ε, ξ, σ assert h 0 assert c 0 C 1 ξ c^ 1 ε ξ h^ 1 ε ^ 1 1 ε C 0 ? C^ 1 σ 1 σ 1000 100 C end u c c, h, par ForwardDiff.derivative cc u cc, h, par , c u h c, h, par ForwardDiff.derivative hh u c, hh, par , h biggest house w , p, θ w 1 θ p function w drift w, h, c , p, r, δ a w p h drift r a c δ p h end md\"\"\" Optimal policides away from the constraint \"\"\" md\"\"\" Closed forms for optimal policies 1. Solve for ``c`` given ``h`` Combining the first order conditions gives ```math \\frac u h c, h u c c, h p r \\delta . ``` Assume that ``u c, h \\frac 1 \\xi c^ 1 \\varepsilon \\xi h^ 1 \\varepsilon ^\\frac 1 \\sigma 1 \\varepsilon 1 \\sigma `` ```math \\begin align u c c, h & 1 \\xi 1 \\xi c^ 1 \\varepsilon \\xi h^ 1 \\varepsilon ^\\tau c^ \\varepsilon \\\\ u h c, h & \\xi 1 \\xi c^ 1 \\varepsilon \\xi h^ 1 \\varepsilon ^\\tau h^ \\varepsilon \\\\ \\implies \\frac u h c, h u c c, h & \\frac \\xi 1 \\xi \\Big \\frac c h \\Big ^ \\varepsilon p r \\delta \\\\ \\implies c & h \\Big p r \\delta \\frac 1 \\xi \\xi \\Big ^ 1 \\varepsilon \\kappa 1 h \\\\ \\tau & \\Big \\frac 1 \\sigma 1 \\varepsilon 1\\Big \\frac \\varepsilon \\sigma 1 \\varepsilon \\\\ \\end align ``` \"\"\" τ ε, σ ε σ 1 ε 1 σ 1 ε 1 κ₁ p, r, δ, ξ, ε p r δ 1 ξ ξ ^ 1 ε c given h h, par h κ₁ par md\"\"\" Some tests \"\"\" ╠═╡ function u c man c, h, par p, r, δ, ξ, ε par tmp 1 ξ c^ 1 ε ξ h^ 1 ε 1 ξ tmp^τ par c^ ε end ╠═╡ ╠═╡ function u h man c, h, par p, r, δ, ξ, ε par tmp 1 ξ c^ 1 ε ξ h^ 1 ε ξ tmp^τ par h^ ε end ╠═╡ md\"\"\" 2. Use ``c h `` to solve for ``h`` ```math \\begin align u c c h , h & u c \\kappa 1 h, h \\\\ & 1 \\xi h^ 1 \\varepsilon ^ \\tau 1 \\xi \\kappa 1^ 1 \\varepsilon \\xi ^ \\tau \\kappa 1 h ^ \\varepsilon \\\\ &\\stackrel h^ \\sigma 1 \\xi 1 \\xi \\kappa 1^ 1 \\varepsilon \\xi ^\\tau \\kappa 1^ \\varepsilon \\\\ & h^ \\sigma 1 \\xi \\kappa 2 \\end align ``` This uses ```math \\quad \\tau 1 \\varepsilon \\varepsilon \\Big \\frac 1 \\sigma 1 \\varepsilon 1\\Big 1 \\varepsilon \\varepsilon \\sigma \\\\ ``` This allows us to solve for the optimal ``h`` ```math \\begin align u c c h , h & h^ \\sigma 1 \\xi \\kappa 2 \\stackrel v w w \\\\ \\implies h & \\Big \\frac v w w 1 \\xi \\kappa 2 \\Big ^ 1 \\sigma \\end align ``` \"\"\" function κ₂ par ξ, σ, ε par κ̃₁ κ₁ par τ̃ τ par 1 ξ κ̃₁^ σ τ̃ ξ κ̃₁^ ε τ̃ ^τ̃ end function u c h, par ξ, σ par κ̃₂ κ₂ par 1 ξ h^ σ κ̃₂ end let par σ 2, ε 0.01, ξ 0.1, p 1, r 0.01, δ 0.5 h 1.2345 c1 π 3 test u h c1, h, par ≈ u h man c1, h, par test u c c1, h, par ≈ u c man c1, h, par cc c given h h, par test u c cc, h, par ≈ u c h, par ξ, ε, r, δ, p par test u h cc, h, par u c cc, h, par ≈ ξ 1 ξ cc h ^ε ≈ p r δ end function optimal h v w, par ξ, σ par κ̃₂ κ₂ par v w 1 ξ κ̃₂ ^ 1 σ end md\"\"\" We can slightly rewrite ``\\kappa 2`` but it doesn't buy us anything ```math \\begin align \\kappa 2 & 1 \\xi \\kappa 1^ 1 \\varepsilon \\xi ^\\tau \\kappa 1^ \\varepsilon \\tau \\tau \\\\ & 1 \\xi \\kappa 1^ 1 \\varepsilon \\varepsilon \\tau \\kappa 1^ \\varepsilon \\tau \\xi ^\\tau \\\\ & 1 \\xi \\kappa 1^ \\sigma \\tau \\kappa 1^ \\varepsilon \\tau \\xi ^\\tau \\\\ \\end align ``` This uses ```math \\begin align 1 \\varepsilon \\frac \\varepsilon \\tau & 1 \\varepsilon \\frac 1 \\varepsilon \\varepsilon \\varepsilon \\sigma \\\\ & 1 \\varepsilon 1 \\frac \\varepsilon \\varepsilon \\sigma \\\\ & 1 \\varepsilon \\frac \\sigma \\varepsilon \\sigma \\\\ & \\sigma \\frac 1 \\varepsilon \\varepsilon \\sigma \\frac \\sigma \\tau \\\\ \\end align ``` \"\"\" md\"\"\" Doing some tests \"\"\" begin obj c, h, w, v w, par begin p, r, δ par u c, h, par v w r w c p h r δ end function consumption given h num h, v w, par, bracket 1e 50, 300 optimize c obj c, h, 0, v w, par , bracket... .minimizer end function test policies v w, h̄, par res optimize h obj consumption given h num h, v w, par , h, 0, v w, par , eps , h̄ h opt res.minimizer h h opt, c consumption given h num h opt, v w, par end end md\"\"\" Optimal policies at the constraint ``\\bar h`` There is no closed form here I think ```math \\begin align u c c, \\bar h &\\stackrel v w w \\\\ u c c, \\bar h & 1 \\xi 1 \\xi c^ 1 \\varepsilon \\varepsilon \\tau \\xi c^ \\varepsilon \\tau \\bar h^ 1 \\varepsilon ^\\tau \\\\ & 1 \\xi 1 \\xi c^ \\sigma \\tau \\xi c^ \\varepsilon \\tau \\bar h^ 1 \\varepsilon ^\\tau \\end align ``` solve numerically \"\"\" function consumption when constrained v w, h̄, par, bracket eps , 100 c opt find zero c u c c, h̄, par v w, bracket end let par σ 2, ε 0.01, ξ 0.11, p 4.0, r 0.01, δ 0.02 v w 0.01 h̄ 1.2345 cc c h, par v w 0.1 cc consumption when constrained v w, h̄, par test pol test policies v w, h̄, par test test pol.c ≈ cc test pol end md\"\"\" ``c 0``, ``h 0`` ```math \\begin align \\dot w & 0 \\\\ r w t ph t c t \\delta p h t & 0 \\\\ \\implies r w t c t & p h t \\delta r \\\\ \\implies c 0 h & rw t ph \\delta r \\end align ``` We need to find ``h 0`` such that ```math \\begin align \\max h u c 0 h , h v w w \\cdot 0 \\\\ c 0 h c \\text min \\implies h \\frac r w c \\text min p \\delta r \\\\ h \\frac w 1 \\theta p \\end align ``` \"\"\" c₀ h, w, δ, r, p r w p h δ r function policies₀ w , par p, δ, r, θ par cₘᵢₙ √eps hₘₐₓ coll biggest house w , par hₘₐₓ cons r w cₘᵢₙ p δ r h̄ min hₘₐₓ coll, hₘₐₓ cons hₘᵢₙ √eps res optimize h u c₀ h, w, par , h, par , hₘᵢₙ, h̄ h res.minimizer c c₀ h, w, par h, c, drift 0, h̄ hₘₐₓ coll, hₘₐₓ cons, vw 0 end md\"\"\" Partial equilibrium given ``p`` and ``r`` \"\"\" function policies drifts vw, w , par vw max vw, √eps h̄ biggest house w , par h optimal h vw, par if h ≤ h̄ c c given h h, par else h h̄ c consumption given h num h̄, vw, par c consumption when constrained v w, h̄, par end drift w drift w, c, h , par c, h, drift, vw, h̄ end begin Base. kwdef struct SimpleHousing θ 0.8 maximal LTV δ 0.02 depreciation rate of housing preferences ρ 0.05 discount rate σ 2.0 inv. intertemporal elasticity of substitution ξ 0.11 utility weight of housing ε 0.01 ≈ elasticity of subsitution between consumption and housing prices r 0.05 interest rate p 4 house price grid w min 2.0 √eps w max 20 end function m SimpleHousing state NamedTuple, y NamedTuple w state v, vw up, vw down y out policies drifts vw up, state, m if out.drift ≤ 0 out policies drifts vw down, state, m elseif out.drift ≥ 0 out policies₀ state, m end c, h, drift, vw out endo u c, h, m vw drift exo 0 ρ m vt ρ v endo exo vt , state..., out... c, h, h̄, drift c star, d star, dir, valid d end end let par SimpleHousing σ 2, ε 0.01, ξ 0.11, p 4.0, r 0.01, δ 0.02 v w 0.01 num test policies v w, 100, par hh optimal h v w, par cc c given h hh, par ana h hh, c cc test num.h ≈ ana.h test num.c ≈ ana.c info ana, num num end begin m SimpleHousing θ 0.1, ξ 0.15, r 0.059, w max 50 w grid range m.w min, m.w max, 300 g w grid yend OrderedDict v log w m.ρ for w ∈ g.w grid stategrid OrderedDict w g.w grid result pdesolve m, stategrid, yend , 0.0001 0.0001 0.0010 assert result.residual norm 1e 5 end let par m w 1.0 p, δ, r, θ par cₘᵢₙ √eps hₘᵢₙ √eps hₘₐₓ coll biggest house w , par hₘₐₓ cons r w cₘᵢₙ p δ r h̄ min hₘₐₓ coll, hₘₐₓ cons hhs range hₘᵢₙ, h̄, 100 ccs c₀. hhs, Ref w , Ref par fig Figure ax Axis fig 1,1 lines fig 1,1 , hhs, u. ccs, hhs, Ref par , label \"u\" lines fig 1,2 , hhs, ccs, label \"c\" info hhs axislegend ax fig end chain result.optional begin DataFrame stack Not w subset w 2.5 data mapping w, value, layout variable visual Lines draw facet linkyaxes false, end lines w grid, result.optional c lines w grid, result.zero v md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"unfinished/redistributive-growth-fabian/","title":"redistributive-growth-fabian","tags":[],"text":" A Pluto.jl notebook v0.19.38 using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using DataFrameMacros, Chain using ForwardDiff using Roots using CairoMakie using DataFrames using NamedTupleTools using AlgebraOfGraphics using PlutoUI Slider, TableOfContents md\"\"\" Redistributive Growth \"\"\" md\"\"\" Parameters \"\"\" Base. kwdef struct RedistributiveGrowthModel v log utility of housing L̄ 1 supply of land ϕ 0.5 fraction with high human capital h̃ 0.8 inelastic supply of high skilled labor l̃ 0.7 inelastic supply of low skilled labor α 0.3 capital share ρ 0.1 ≈ elasticity of substitution between physical and intangible capital η 0.5 relative productivity of intangible capital & high skilled labor ε 0.05 share of experts ω 0.3 fraction of intangibles that can be \"stolen\" by innovators ψ 1 2 cost for producing intangibles A 30 productivity end function F K, H, l, h, A, η, α, ρ, ϕ hh ϕ h ll 1 ϕ l A η H^α hh^ 1 α ^ρ 1 η K^α ll^ 1 α ^ρ ^ 1 ρ end F K, H, l̃, h̃, ϕ, η, α, ρ, A F K, H, l̃, h̃, A, η, α, ρ, ϕ F xx, par F xx..., par function get prices K, H, mod l̃, h̃, ϕ mod xx K, H, l̃, h̃ oneplusr, R H, w, q ForwardDiff.gradient x F x, mod , xx Y F xx, mod q q ϕ this manual intervention here should not be necessary w w 1 ϕ this manual intervention here should not be necessary check Y w 1 ϕ l̃ q ϕ h̃ oneplusr K R H H eps check, oneplusr, R H, w, q, Y end md\"\"\" Solving the steady state using equations \"\"\" md\"\"\" ``\\bar L`` bind L̄1 Slider 0.1 0.3 5.0, default 1.0, show value true available land ``\\phi`` bind ϕ1 Slider 0.1 0.1 0.9, default 0.2, show value true fraction with high human capital ``\\tilde h`` bind h̃1 Slider 1 1 100, default 50, show value true inelastic supply of high skilled labor ``\\tilde l`` bind l̃1 Slider 0.5 0.5 50, default 12.5, show value true inelastic supply of low skilled labor ``\\alpha`` bind α1 Slider 0.1 0.01 0.9, default 0.33, show value true capital share ``\\rho`` bind ρ1 Slider 0.1 0.1 2.0, default 1.7, show value true elasticity of substitution between physical and intangible capital ``\\eta`` bind η1 Slider 0.01 0.01 0.95, default 0.45, show value true relative productivity of intangible capital & high skilled labor ``\\varepsilon`` bind ε1 Slider 0.01 0.01 0.2, default 0.05, show value true share of experts ``\\omega`` bind ω1 Slider 0.1 0.05 0.9, default 0.55, show value true fraction of intangibles that can be \"stolen\" by innovators ``\\psi`` bind ψ1 Slider 0.1 0.1 2.0, default 1., show value true cost for producing intangibles ``A`` bind A1 Slider 0.1 0.1 5, default 1, show value true productivity \"\"\" function solve more solution, mod nt subset solution, r 0 | only | NamedTuple K, H, p, f nt q, w get prices K, H, mod q, w, nt... l̃, h̃, L̄ mod assets low w l̃ p L̄ assets high q h̃ p L̄ assets low, assets high, p, f, ineq q w end md\"\"\" Helper functions \"\"\" v prime L, v ForwardDiff.derivative v, L house price ss r, mod v prime mod.L̄, mod r stock price ss r, d d r function solve analytical equations mod function Y RH K, H, mod α, η, ω, ψ mod Y F K, H, mod A.7 R H α η Y H A.2 check H ω ψ R H A.3 Y, R H, check end function get h K, mod, bracket eps , 10 find zero H Y RH K, H, mod .check, bracket | maximum only end function everything K, mod α, η, ω, L̄, l̃, h̃, ψ mod H get h K, mod Y, R H Y RH K, H, mod r α 1 η Y K 1 A.1 d 1 ω R H H A.4' f d r f stock price ss d, r A.4' p house price ss r, mod A.5 check 1 α Y p L̄ f K A.6 K, H, Y, R H, r, f, p, check end Ks find zeros K everything K, mod .check, eps , 100 map Ks do K delete everything K, mod , check end | DataFrame end outout let mod RedistributiveGrowthModel A A1, L̄ L̄1, ψ ψ1, l̃ l̃1, h̃ h̃1, ϕ ϕ1, η η1, ε ε1, ρ ρ1, α α1, ω ω1 out1 solve analytical equations mod out1, mod end solve more outout... md\"\"\" Simulation \"\"\" md\"\"\" Digging deeper It's getting messier below here \"\"\" md\"\"\" Firm Given prices `` w t, q t, r t, Q t `` the firm's problem is to maximize dividends profits ``d t``. ```math \\begin align d^ t &\\max l, h, K F K t, H t, l t, h t w t l t q t h t 1 r t K t Q t H t \\\\ &\\begin aligned \\text s.t. &H t H^ R H,t && \\text from innovators \\\\ & Q t \\geq \\omega R H,t && \\text IC for innovators \\\\ \\end aligned \\end align ``` In optimum ```math \\begin align w t & F l \\\\ q t & F h\\\\ 1 r t & F K \\\\ Q t & \\omega R H,t \\\\ R H,t & F H \\quad \\text where exactly does this come from? \\\\ d t & 1 \\omega R H,t H t \\end align ``` \"\"\" md\"\"\" Find the level of tangibles ``H`` given ``K`` \"\"\" foo L, pₜ, pₜ₊₁, rₜ₊₁ , v pₜ pₜ₊₁ ForwardDiff.derivative v, L 1 rₜ₊₁ prices pₜ 1.0, pₜ₊₁ 1.0, rₜ₊₁ 0.05 md\"\"\" Innovators optimality condition ``H^ R H \\frac \\omega \\psi R H`` \"\"\" intangible capital R H, ω, ψ ω R H ψ function get H aux K, H, mod R H get prices K, H, mod H new intangible capital R H, mod H H new end function get H K, mod find zeros H get H aux K, H, mod , 0, 3 end md\"\"\" Consumers Consumers take wages ``y^i t \\in \\ \\tilde l w t, \\tilde h q t \\ ``, prices and dividends `` p t, f t, d t `` as given and choose the amount of land ``L``, consumption ``c``, shares ``S`` and debt ``D``. ``y t 1 `` is non zero for innovators only. `` y t, p t, r t, f t, d t \\mapsto L, c, S, D `` ```math \\begin align &\\max c t 1 , L t, S t, D t c t 1 v L t \\\\ &\\begin aligned \\text s.t. &p t L t f t S t D t \\leq y^i t \\\\ &c t 1 \\leq y^i t 1 p t 1 L t f t 1 d t 1 S t 1 r t 1 D t \\\\ &c t 1 , L t, S t \\geq 0 \\end aligned \\end align ``` The first order conditions are ```math \\begin align p t & \\frac p t 1 v' L t 1 r t 1 \\\\ f t & \\frac f t 1 d t 1 r t 1 \\end align ``` The first one gives the optimal amount of land ``L t`` , the second one makes sure that the agent indifferent between the two assets. Thus, only the total investment matters for the agent. ```math \\tilde D t \\underbrace D t f t S t \\text net savings y t p t L t ``` \"\"\" md\"\"\" Simplified consumers problem in terms of net savings ``\\tilde D`` ```math \\begin align &\\max c t 1 , L t, \\tilde D t c t 1 v L t \\\\ &\\begin aligned \\text s.t. &p t L t \\tilde D t y^i t \\\\ &c t 1 y^i t 1 p t 1 L t 1 r t 1 \\tilde D t \\\\ &c t 1 , L t \\geq 0 \\end aligned \\end align ``` In optimum `` p t, r t, y t \\mapsto \\tilde D t `` ```math \\begin align p t & \\frac p t 1 v' L^ t 1 r t 1 \\\\ \\tilde D^ t & y i^t p t L^ t \\\\ c^ t 1 & y^ t 1 p t 1 L^ t 1 r t 1 \\tilde D^ t \\end align ``` \"\"\" md\"\"\" Aggregate consumers The total net saving is total income minus total land purchases ``\\tilde D^\\text agg w t \\tilde l t q t \\tilde h t p t \\bar L`` this uses that total land is fixed and that consumers supply labor inelastically We know that the labor share `` 1 \\alpha `` is split between high skilled and low skilled labor. `` 1 \\alpha Y t 1 \\phi w t \\tilde l \\phi q t \\tilde h`` \"\"\" md\"\"\" Equilibrium Market clearing ``l \\tilde l``, ``h \\tilde h`` Innovators ``R H \\mapsto H`` Firm maximization `` w, q, r, H, R H \\mapsto l, h, K, d `` Workers `` \\mapsto `` \"\"\" bind K Slider 10 0.1 10, default 1, show value true function everything given K K, mod ω, L̄, α mod K 5.0 H get H K, mod | only oneplusr, R H, w, q, Y get prices K, H, mod d 1 ω R H H r oneplusr 1 K, H, d, r d 1 ω R H H f stock price ss d, r p house price ss r, mod lhs 1 α Y p L̄ rhs K f check lhs rhs lhs, rhs, r, f, K, p, H, d, q, w, check end function get K mod find zeros K everything given K K, mod .check, eps , 10 | only end mod0 mod RedistributiveGrowthModel ψ 0.5, ϕ 0.1, η 0.6, ε 0.01, ρ 0.0001 RedistributiveGrowthModel ψ 0.5, η 0.5, ε 0.1 get prices 1,1, mod0 get K mod0 df map 1.0 0.01 2.0 do K everything given K K, mod0 end | DataFrame begin fig Figure ax Axis fig 1,1 lines ax, df.K, df.lhs, label \"lhs\" lines ax, df.K, df.rhs, label \"rhs\" lines fig 1,2 , df.K, df.r lines fig 2,1 , df.K, df.p df.q . df.w lines fig 2,2 , df.K, df.H axislegend ax fig end house price ss 0.1, mod0 let η, l̃, h̃, ϕ mod0 ineq η 1 η l̃ h̃ 1 ϕ ϕ end md\"\"\" Adapting Yasmine's Code Solving stuff backwards \"\"\" Base. kwdef struct Yasmine v log utility of housing A 1 beta 1 L 0 1 omega 1 h 24.438 l 15.945 eta 0 0.6 eta end 0.8 alpha 0.3 phi 0.3 End Capital H26 end 1.588 K26 end 2.840 end output H, K, h, l, A, η, α A H^α h^ 1 α ^η K^α l^ 1 α ^ 1 η function output26 H26, K26, eta26, h, l, A, alpha output H26, K26, h, l, η eta26, α alpha, A end function prices26 H, K, η, h, l, A, alpha xs H, K, h, l par A, α alpha, η prices ForwardDiff.gradient x output x..., par , xs R, rp1, q, w prices R, rp1, q, w end begin intangible capital g26 Y26, p26, L26, e26, alpha 1 alpha Y26 p26 L26 e26 intang cap26 eta26, Y26, alpha, beta, omega √ alpha beta eta26 Y26 omega omega beta end par26 Yasmine let H26 end, K26 end, h, l, A, eta end, alpha par26 prices26 H26 end, K26 end, eta end, par26 end out let H26 end, K26 end, eta end, alpha, omega, L 0 par26 keys Y26, H26, K26, r26, R26, w26, q26, RH26, div26, e26, L26, p26, m26, eta26 nt NamedTuple keys tuple fill 1.0, length keys ... NT typeof t 1, nt... outt NT T 10 ηs fill par26.eta 0, 2T range par26.eta 0, par26.eta end, T fill par26.eta end, 2T Initialization H26 H26 end K26 K26 end eta26 ηs end Y26 output26 H26, K26, eta26, par26 r26 alpha 1 eta26 Y26 K26 Lnext par26.L 0 pnext v prime Lnext, par26 r26 for t ∈ length ηs 1 1 eta26 ηs t if you interpret this as a transition path, Y26 and H26 need to be consistent in each period iterate a few times until convergence for it ∈ 1 20 Y26 output26 H26, K26, eta26, par26 H26 new intang cap26 eta26, Y26, par26 if H26 new ≈ H26 info it break else H26 H26 new end end R, rp1, q, w prices26 H26, K26, eta26, par26 r26 alpha 1 eta26 Y26 K26 1 r R26 alpha eta26 Y26 H26 w26 1 alpha 1 eta26 Y26 par26.l q26 1 alpha eta26 Y26 par26.h r26 rp1 should be rp1 1 R26 R q26 q w26 w RH26 R26 H26 div26 1 omega RH26 e26 div26 r26 L26 Lnext constant K26 g26 Y26, pnext, Lnext, e26, par26 p26 pnext v prime Lnext, par26 1 r26 m26 max 0, 1 par26.phi p26 L26 1 par26.alpha 1 eta26 Y26 eta26 eta26 eta end par26.eta 0 T Appending push outt, t, Y26, H26, K26, r26, R26, w26, q26, RH26, div26, e26, L26, p26, m26, eta26 pnext p26 end outt end | DataFrame chain out begin DataFrame stack Not t data mapping t, value, layout variable visual Lines draw facet linkyaxes false, end md\"\"\" Appendix \"\"\" TableOfContents "},{"url":"unfinished/two-assets-ct/","title":"Two assets in CT","tags":["unfinished"],"text":" A Pluto.jl notebook v0.19.38 frontmatter chapter 8 section 4 order 4 title \"Two assets in CT\" layout \"layout.jlhtml\" tags \"unfinished\" description \"\" using Markdown using InteractiveUtils using LinearAlgebra using StructArrays using EconPDEs using NamedTupleTools delete using QuantEcon gth solve using InfinitesimalGenerators InfinitesimalGenerators using PlutoTest using CairoMakie, AlgebraOfGraphics using SparseArrays using DataFrames, DataFrameMacros, Chain using PlutoUI md\"\"\" Solving the HJB Implicit scheme \"\"\" md\"\"\" Setup \"\"\" md\"\"\" Solving the HJB equation \"\"\" md\"\"\" HJB Moll \"\"\" function two asset kinked cost new d,a, χ₀, χ₁ χ₀ abs d χ₁ d^2 2 max a,10^ 5 ^ 1 end function two asset kinked FOC new pa, pb, a, χ₀, χ₁ min pa pb 1 χ₀, 0.0 a χ₁ max pa pb 1 χ₀, 0.0 a χ₁ end function two asset kinked cost d,a, chi0, chi1 chi0 abs d chi1 d^2 2 max a,10^ 5 ^ 1 end function two asset kinked FOC pa,pb,a, chi0, chi1 min pa pb 1 chi0, 0.0 a chi1 max pa pb 1 chi0, 0.0 a chi1 end function solve HJB base maxit 35 ga 2 CRRA utility with parameter gamma ra 0.05 rb pos 0.03 rb neg 0.12 rho 0.06 discount rate chi0 0.03 chi1 2 xi 0.1 fraction of income that is automatically deposited if ra 1 chi1 0 warn \"Warning ra 1 chi1 0\" end Income process two state Poisson process w 4 Nz 2 z .8, 1.3 la mat 1 3 1 3 1 3 1 3 crit 10^ 5 Delta 100 maxit 35 grids I 100 bmin 2 bmin 0 bmax 40 b range bmin,bmax,length I db bmax bmin I 1 J 50 amin 0 amax 70 a range amin,amax,length J da amax amin J 1 bb b ones 1,J aa ones I,1 a' zz ones J,1 z' dist zeros maxit bbb zeros I,J,Nz aaa zeros I,J,Nz zzz zeros I,J,Nz for nz 1 Nz bbb , ,nz . bb aaa , ,nz . aa zzz , ,nz . z nz end Bswitch LinearAlgebra.I I J la mat 1,1 LinearAlgebra.I I J la mat 1,2 LinearAlgebra.I I J la mat 2,1 LinearAlgebra.I I J la mat 2,2 Preallocation VbF zeros I,J,Nz VbB zeros I,J,Nz VaF zeros I,J,Nz VaB zeros I,J,Nz c zeros I,J,Nz updiag zeros I J,Nz lowdiag zeros I J,Nz centdiag zeros I J,Nz AAi Array AbstractArray undef, Nz BBi Array AbstractArray undef, Nz d B zeros I,J,Nz d F zeros I,J,Nz Id B zeros I,J,Nz Id F zeros I,J,Nz c zeros I,J,Nz u zeros I,J,Nz INITIAL GUESS v0 1 xi w zzz ra. aaa rb neg. bbb .^ 1 ga 1 ga rho v copy v0 return at different points in state space matrix of liquid returns Rb rb pos . bbb . 0 . rb neg . bbb . 0 raa ra . ones 1,J if ra rb, impose tax on ra a at high a, otherwise some households accumulate infinite illiquid wealth not needed if ra is close to or less than rb tau 10 raa ra . 1 . 1.33 . amax . a .^ 1 tau plot a,raa. a matrix of illiquid returns Ra zeros I,J,Nz Ra , ,1 . raa' Ra , ,2 . raa' for n 1 maxit V v DERIVATIVES W.R.T. b forward difference VbF 1 I 1, , . V 2 I, , . V 1 I 1, , . db VbF I, , 1 xi w zzz I, , Rb I, , . bmax .^ ga state constraint boundary condition backward difference VbB 2 I, , V 2 I, , V 1 I 1, , db VbB 1, , 1 xi w zzz 1, , Rb 1, , . bmin .^ ga state constraint boundary condition DERIVATIVES W.R.T. a forward difference VaF ,1 J 1, V ,2 J, V ,1 J 1, da backward difference VaB ,2 J, V ,2 J, V ,1 J 1, da useful quantities c B max. VbB,10^ 6 .^ 1 ga c F max. VbF,10^ 6 .^ 1 ga dBB two asset kinked FOC. VaB,VbB,aaa, Ref chi0, chi1 dFB two asset kinked FOC. VaB,VbF,aaa, Ref chi0, chi1 VaF ,J, VbB ,J, . 1 ra. chi1 chi1 w zzz ,J, . a ,J, dBF two asset kinked FOC. VaF,VbB,aaa, Ref chi0, chi1 VaF ,J, VbF ,J, . 1 ra. chi1 chi1 w zzz ,J, . a ,J, dFF two asset kinked FOC. VaF,VbF,aaa, Ref chi0, chi1 UPWIND SCHEME d B . dBF . 0 . dBF . dBB . 0 . dBB state constraints at amin and amax d B ,1, dBF ,1, . 10^ 12 . dBF ,1, make sure d 0 at amax, don't use VaB ,1, d B ,J, dBB ,J, . 10^ 12 . dBB ,J, make sure d 0 at amax, don't use VaF ,J, d B 1,1, max. d B 1,1, ,0 split drift of b and upwind separately sc B 1 xi . w . zzz . Rb . bbb . c B sd B d B two asset kinked cost. d B, aaa, Ref chi0, chi1 d F . dFF . 0 . dFF dFB . 0 . dFB state constraints at amin and amax d F ,1, dFF ,1, . 10^ 12 . dFF ,1, make sure d 0 at amin, don't use VaB ,1, d F ,J, dFB ,J, . 10^ 12 . dFB ,J, make sure d 0 at amax, don't use VaF ,J, split drift of b and upwind separately sc F 1 xi w zzz . Rb. bbb . c F sd F d F . two asset kinked cost. d F,aaa, Ref chi0, chi1 sd F I, , min. sd F I, , ,0.0 Ic B sc B . 10^ 12 Ic F sc F . 10^ 12 . 1 . Ic B Ic 0 1 . Ic F . Ic B Id F . sd F . 10^ 12 Id B . sd B . 10^ 12 . 1 . Id F Id B 1, , . 0 Id F I, , . 0 Id B I, , . 1 don't use VbF at bmax so as not to pick up articial state constraint Id 0 1 . Id F . Id B c 0 1 xi w zzz Rb . bbb c . c F . Ic F c B . Ic B c 0 . Ic 0 u . c .^ 1 ga . 1 ga CONSTRUCT MATRIX BB SUMMARING EVOLUTION OF b X Ic B . sc B . db . Id B . sd B . db Y Ic B . sc B . Ic F . sc F . db . Id B . sd B . Id F . sd F . db Z Ic F. sc F db Id F. sd F db for i 1 Nz centdiag ,i reshape Y , ,i ,I J,1 end lowdiag 1 I 1, X 2 I,1, updiag 2 I, Z 1 I 1,1, for j 2 J lowdiag 1 j I, lowdiag 1 j 1 I, X 2 I,j, zeros 1,Nz updiag 1 j I, updiag 1 j 1 I, zeros 1,Nz Z 1 I 1,j, end for nz 1 Nz BBi nz spdiagm I J, I J, 0 centdiag ,nz , 1 updiag 2 end,nz , 1 lowdiag 1 end 1,nz end BB cat BBi..., dims 1,2 CONSTRUCT MATRIX AA SUMMARIZING EVOLUTION OF a dB Id B . dBB . Id F . dFB dF Id B . dBF . Id F . dFF MB min. dB,0.0 MF max. dF,0.0 . xi . w . zzz . Ra . aaa MB ,J, xi . w . zzz ,J, . dB ,J, . Ra ,J, . amax this is hopefully negative MF ,J, . 0.0 chi MB . da yy MB MF . da zeta MF . da MATRIX AAi for nz 1 Nz This will be the upperdiagonal of the matrix AAi AAupdiag zeros I,1 This is necessary because of the peculiar way spdiags is defined. for j 1 J AAupdiag AAupdiag zeta ,j,nz end This will be the center diagonal of the matrix AAi AAcentdiag yy ,1,nz for j 2 J 1 AAcentdiag AAcentdiag yy ,j,nz end AAcentdiag AAcentdiag yy ,J,nz This will be the lower diagonal of the matrix AAi AAlowdiag chi ,2,nz for j 3 J AAlowdiag AAlowdiag chi ,j,nz end info AAcentdiag info AAlowdiag info AAupdiag Add up the upper, center, and lower diagonal into a sparse matrix AAi nz spdiagm I J, I J, 0 AAcentdiag, I AAlowdiag, I AAupdiag begin I end I end AA cat AAi..., dims 1,2 A AA BB Bswitch if maximum abs, sum A,dims 2 10^ 12 warn \"Improper Transition Matrix\" break end if maximum abs, sum A, dims 2 10^ 9 warn \"Improper Transition Matrix\" break end B 1 Delta rho LinearAlgebra.I I J Nz A u stacked reshape u,I J Nz,1 V stacked reshape V,I J Nz,1 vec u stacked V stacked Delta V stacked B\\vec SOLVE SYSTEM OF EQUATIONS V reshape V stacked,I,J,Nz Vchange V v v V dist n maximum abs, Vchange info \"Value Function, Iteration n | max Vchange dist n \" if dist n crit info \"Value Function Converged, Iteration n\" break end end d Id B . d B Id F . d F m d xi w zzz Ra. aaa s 1 xi w zzz Rb. bbb d two asset kinked cost. d, aaa, Ref chi0, chi1 c sc 1 xi w zzz Rb. bbb c sd d two asset kinked cost. d,aaa, Ref chi0, chi1 df DataFrame a vec aaa , b vec bbb , z vec zzz , c vec c , d vec d , s vec s , m vec m , u vec u , sc vec sc , sd vec sd , v vec v end df base solve HJB base ╠═╡ chain df begin stack s, d data mapping b, a, value, col z nonnumeric, row variable visual Surface draw axis type Axis3, end ╠═╡ md\"\"\" HJB Greimel \"\"\" md\"\"\" if ``r a \\gg r b``, impose tax on ``ra \\cdot a`` at high ``a``, otherwise some households accumulate infinite illiquid wealth not needed if ``r a`` is close to or less than ``r b`` \"\"\" R a a, ra, amax, τ ra 1 1.33 amax a ^ 1 τ a R b b, rb pos, rb neg b ≥ 0 ? rb pos rb neg b function check ra, χ₁ if ra 1 χ₁ 0 warn \"Warning ra 1 χ₁ 0\" end end util c, γ c^ 1 γ 1 γ u prime c, γ c^ γ u prime inv x, γ x^ 1 γ function get d VaB, VaF, Vb, a, b , model amax, amin, bmin, bmax model dxB two asset kinked FOC new VaB,Vb,a, model dxF two asset kinked FOC new VaF,Vb,a, model if dxF 0 && dxB 0 d dxF dxB elseif dxF 0 d dxF elseif dxB 0 d dxB else d 0.0 end if a amin d dxF dxF 10^ 12 end if a amax d dxB dxB 10^ 12 end if a amin && b bmin d max d, 0.0 end sd d two asset kinked cost new d, a, model d, dxB, dxF, sd end function get c Vb, b, z , model γ, ξ, w model c u prime inv. max. Vb,10^ 6 , Ref γ sc 1 ξ w z R b b, model c c, sc end function get c₀ b, z , model γ, ξ, w model sc 0.0 c 1 ξ w z R b b, model c, sc end function get c upwind VbB, VbF, state, model out F get c VbF, state, model if out F.sc 10^ 12 return out F end out B get c VbB, state, model if out B.sc 10^ 12 return out B end return get c₀ state, model end function initial guess a, b, z , model ξ, w, ϱ, rb neg, ra model c init 1 ξ w z ra a rb neg b should be c init 1 xi w z R a a, model rb neg R b b, model util c init, model ϱ end function ȧ fixed a, z , model ξ, w model ξ w z R a a, model end function get d upwind VaB, VaF, VbB, VbF, state, model amax, amin, bmin, bmax model a, b state outB get d VaB, VaF, VbB, state, model outF get d VaB, VaF, VbF, state, model d B outB.d d F outF.d sd B outB.sd sd F outF.sd if b bmax sd F min sd F, 0.0 end Id F false Id B false Id 0 false if b bmax Id B true dB min outB.dxB, 0.0 dF max outB.dxF, 0.0 d d B sd outB.sd elseif sd F 10^ 12 && b bmax Id F true dB min outF.dxB, 0.0 dF max outF.dxF, 0.0 d d F sd outF.sd elseif sd B 10^ 12 && b bmin Id B true dB min outB.dxB, 0.0 dF max outB.dxF, 0.0 d d B sd outB.sd vb d VbB else Id 0 true dB 0.0 dF 0.0 d 0.0 sd 0.0 end if a amax MF dF ȧ fixed state, model MB dB else a amax MF 0.0 MB dB ȧ fixed state, model this is hopefully negative end d B, d F, dB, dF, sd B, sd F, Id B, Id F, Id 0, d, sd, MF, MB end begin Base. kwdef struct TwoAssets γ 2 CRRA utility with parameter gamma ra 0.05 rb pos 0.03 rb neg 0.12 ϱ 0.06 discount rate χ₀ 0.03 χ₁ 2 ξ 0.1 fraction of income that is automatically deposited Income process two state Poisson process w 4 Nz 2 z .8, 1.3 Λ 1 3 1 3 1 3 1 3 crit 10^ 5 Δ 100 grids I 100 bmin 2 bmax 40 b range bmin,bmax,length I db bmax bmin I 1 J 50 amin 0 amax 70 a range amin,amax,length J da amax amin J 1 τ 10 end function model TwoAssets state NamedTuple, vb up, vb down, va up, va down out d get d upwind va down, va up, vb down, vb up, state, model out c get c upwind vb down, vb up, state, model out d, out c c, sc out c sd, MF, MB out d endo util c, model va down MB va up MF vb down min sd, 0.0 min sc, 0.0 vb up max sd, 0.0 max sc, 0.0 out d, out c, endo end end md\"\"\" EconPDEs \"\"\" function clean variables nt, solname, statename, n map 1 n do i sol key Symbol solname, i up key Symbol sol key, statename, \" up\" Symbol solname, statename, \" up\" down key Symbol sol key, statename, \" down\" Symbol solname, statename, \" down\" solname nt sol key , up key 2 nt up key 1 , down key 2 nt down key 1 end | DataFrame end function f econ pdes state NamedTuple, sol NamedTuple, m ϱ, Λ, z m zgrid z nz length z sol clean clean variables sol, v, a, nz nts map enumerate eachrow sol clean do i, row state state..., z zgrid i out d, out c m state, row endo u out.c, m out.dv out.ȧ i, out..., endo end v sol clean endo, ȧ, c DataFrame nts vt ρ v endo Λ v Symbol v, i, t vt i for i ∈ 1 nz ... , Symbol c, i c i for i ∈ 1 nz ..., Symbol s, i ȧ i for i ∈ 1 nz ..., end md\"\"\" Differentiate \"\"\" begin Δy up y, i, Δx y i 1 y i Δx Δy down y, i, Δx y i y i 1 Δx Δy central y, i, Δx y i 1 y i 1 Δx function Δgrid grid, i last length grid inbounds down grid max i, 2 grid max i 1, 1 inbounds up grid min i 1, last grid min i, last 1 central up down avg central 2 up, down, avg, central end function Δy y, bc, i, Δx, fun name, state name up i length y ? Δy up y, i, Δx.up bc i down i 1 ? Δy down y, i, Δx.down bc i second up down Δx.avg NamedTuple deriv names fun name, state name up, down, second end deriv names fun name, state name Symbol fun name, state name, \" \", up , Symbol fun name, state name, \" \", down , Symbol fun name, state name, state name end function cross difference y, grids, inds assert length grids length inds length size y 2 i1, i2 Tuple inds grid1, grid2 grids Δx1 Δgrid grid1, i1 Δx2 Δgrid grid2, i2 i1 lo max i1 1, 1 i1 hi min i1 1, length grid1 if i2 1 a Δy up view y, i1 hi, , i2, Δx2.central use Δx2.up? b Δy up view y, i1 lo, , i2, Δx2.central use Δx2.up? elseif i2 length grid2 a Δy down view y, i1 hi, , i2, Δx2.central use Δx2.down? b Δy down view y, i1 lo, , i2, Δx2.central use Δx2.down? else a Δy central view y, i1 hi, , i2, Δx2.central b Δy central view y, i1 lo, , i2, Δx2.central end vab a b Δx1.central adjust Δx1.central when i1 is adjusted? end function select all but one dim y0, dim inds drop y reshape view y0, , size y0 for dim drop, i drop ∈ reverse dim inds drop y selectdim y, dim drop, i drop end y end function selectdims A0, ds, is A reshape view A0, , size A0 for d, i ∈ zip ds, is A selectdim A, d, i end A end function differentiate 1 naive y, grids, inds, bc, solname v statename only keys grids i only Tuple inds n states 1 grid only grids Δx Δgrid grid, i va Δy y, bc, i, Δx, solname, statename solname y Tuple inds ... , va... end function differentiate 2 naive y, grids, inds, bc, solname v statenames keys grids dim inds dim, i for dim, i ∈ enumerate Tuple inds n states length grids simple differences nts simple map enumerate statenames do dim, statename i inds dim grid grids statename Δx Δgrid grid, i dim inds drop dim inds Not dim y sub select all but one dim y, dim inds drop bc sub select all but one dim bc, dim inds drop va Δy y sub, bc sub, i, Δx, solname, statename end out solname y Tuple inds ... , merge nts simple... ... cross differences if n states 2 vab cross difference y, grids, inds cross name Symbol solname, statenames... out out..., cross name vab elseif n states 3 nts cross map dim inds do dim drop, i drop state drop statenames dim drop sub grids delete grids, state drop sub inds Tuple inds ... Not dim drop sub y selectdim y, dim drop, i drop sub bc selectdim bc, dim drop, i drop sub statenames filter state drop , statenames vab cross difference sub y, sub grids, sub inds cross name Symbol solname, sub statenames... Symbol solname, sub statenames... vab end out merge out, merge nts cross... end out end function differentiate y, grids, inds, bc, solname v statenames collect keys grids dim inds dim, i for dim, i ∈ enumerate Tuple inds n states length grids simple upwind differences for each state nts simple map enumerate statenames do dim, statename i inds dim grid grids statename Δx Δgrid grid, i dim inds drop dim inds Not dim y sub select all but one dim y, dim inds drop bc sub select all but one dim bc, dim inds drop va Δy y sub, bc sub, i, Δx, solname, statename end out solname y Tuple inds ... , merge nts simple... ... upwind cross differences for each combination of state cross Pair for i in 1 n states for j in 1 i 1 drop dim inds Not i, j dim drop first. drop i drop last. drop state drop statenames dim drop sub grids delete grids, state drop... sub inds Tuple inds ... Not dim drop sub y selectdims y, dim drop, i drop sub bc selectdims bc, dim drop, i drop sub statenames filter ∉ state drop , statenames vab cross difference sub y, sub grids, sub inds cross name Symbol solname, sub statenames... push cross, cross name vab end end merge out, cross... end md\"\"\" Constructing the Intensity Matrix \"\"\" md\"\"\" Intensity matrix Moll \"\"\" function construct A moll sc , Id B, sd B, Id F, sd F, MB, MF , I, J, Nz, db, da updiag zeros I J,Nz lowdiag zeros I J,Nz centdiag zeros I J,Nz AAi Array AbstractArray undef, Nz BBi Array AbstractArray undef, Nz X min. sc, 0.0 . db . Id B . sd B . db Y min. sc, 0.0 max. sc, 0.0 . db . Id B . sd B . Id F . sd F . db Z max. sc, 0.0 db Id F. sd F db for i 1 Nz centdiag ,i reshape Y , ,i ,I J,1 end lowdiag 1 I 1, X 2 I,1, updiag 2 I, Z 1 I 1,1, for j 2 J lowdiag 1 j I, lowdiag 1 j 1 I, X 2 I,j, zeros 1,Nz updiag 1 j I, updiag 1 j 1 I, zeros 1,Nz Z 1 I 1,j, end for nz 1 Nz BBi nz spdiagm I J, I J, 0 centdiag ,nz , 1 updiag 2 end,nz , 1 lowdiag 1 end 1,nz end BB cat BBi..., dims 1,2 CONSTRUCT MATRIX AA SUMMARIZING EVOLUTION OF a chi MB . da yy MB da MF da zeta MF . da MATRIX AAi for nz 1 Nz This will be the upperdiagonal of the matrix AAi AAupdiag zeros I,1 This is necessary because of the peculiar way spdiags is defined. for j 1 J AAupdiag AAupdiag zeta ,j,nz end This will be the center diagonal of the matrix AAi AAcentdiag yy ,1,nz for j 2 J 1 AAcentdiag AAcentdiag yy ,j,nz end AAcentdiag AAcentdiag yy ,J,nz This will be the lower diagonal of the matrix AAi AAlowdiag chi ,2,nz for j 3 J AAlowdiag AAlowdiag chi ,j,nz end Add up the upper, center, and lower diagonal into a sparse matrix AAi nz spdiagm I J, I J, 0 AAcentdiag, I AAlowdiag, I AAupdiag begin I end I end AA cat AAi..., dims 1,2 A AA BB AA, BB end md\"\"\" Intensity matrix Greimel \"\"\" function construct A new sc , Id B, sd B, Id F, sd F, MB, MF , b, a, z, db, da, Λ , with exo false statespace b, a, z for b ∈ b, a ∈ a, z ∈ z N length statespace state inds i b, i a, i z for i b ∈ eachindex b , i a ∈ eachindex a , i z ∈ eachindex z linind LinearIndices size statespace T typeof from 1, to 1, λ 0.1 entries B T entries A T entries switch T entries T for from, i a, i b, i z ∈ enumerate state inds scᵢ sc from if i b 1 to linind i b 1, i a, i z λ min scᵢ, 0.0 db Id B from sd B from db entry from, to, λ push entries B, entry push entries, entry end if i b length b to linind i b 1, i a, i z λ max scᵢ, 0.0 db Id F from sd F from db entry from, to, λ push entries B, entry push entries, entry end if i a 1 to linind i b, i a 1, i z λ MB from da entry from, to, λ push entries A, entry push entries, entry end if i a length a to linind i b, i a 1, i z λ MF from da entry from, to, λ push entries A, entry push entries, entry end for i z next ∈ eachindex z if i z next i z to linind i b, i a, i z next λ Λ i z, i z next entry from, to, λ push entries switch, entry with exo && push entries, entry end end end from, to, λ StructArray entries B B sparse from, to, λ, N, N BB B spdiagm dropdims sum B, dims 2 , dims 2 from, to, λ StructArray entries A A sparse from, to, λ, N, N AA A spdiagm dropdims sum A, dims 2 , dims 2 from, to, λ StructArray entries A sparse from, to, λ, N, N A A spdiagm dropdims sum A, dims 2 , dims 2 from, to, λ StructArray entries switch switch sparse from, to, λ, N, N switch switch spdiagm dropdims sum switch, dims 2 , dims 2 A , AA, BB, A alt AA BB end function solve HJB new model, maxit 35 ϱ model Δ, crit model a, b, z model initialize vector that keeps track of convergence dists grids b, a, z statespace b, a, z for b ∈ b, a ∈ a, z ∈ z INITIAL GUESS v initial guess. statespace, Ref model bc zeros size v c bd get c₀. statespace end, , , Ref model | StructArray bc end, , u prime. c bd.c, Ref model state constraint boundary condition c bd get c₀. statespace begin, , , Ref model | StructArray bc begin, , u prime. c bd.c, Ref model state constraint boundary condition for n 1 maxit V v out map CartesianIndices V do inds Forward and backward differences w.r.t. b and a ∂s differentiate V, grids, inds, bc state statespace inds model state, ∂s end | StructArray out d StructArray out.out d out c StructArray out.out c A construct A new out c, out d, model, true if maximum abs, sum A,dims 2 10^ 12 warn \"Improper Transition Matrix\" break end if maximum abs, sum A, dims 2 10^ 9 warn \"Improper Transition Matrix\" break end B 1 Δ ϱ LinearAlgebra.I A c out c u util. c, Ref model V new B\\ vec u vec V Δ SOLVE SYSTEM OF EQUATIONS V reshape V new, size statespace Vchange V v v . V dist maximum abs, Vchange push dists, dist info \"Value Function, Iteration n | max Vchange dist\" if dist crit info \"Value Function Converged, Iteration n\" d, sd out d sc out c ξ, w model m d ξ w z R a a, model for d, z, a ∈ zip d, statespace s sc sd df ss DataFrame vec statespace df out DataFrame c vec c , d vec d , s vec s , m vec m , u vec u , sc vec sc , sd vec sd , v vec v df df ss df out return df, out c, out d end end error \"Algorithm did not converge after maxit iterations\" end begin m TwoAssets df, out c, out d solve HJB new m df new df end test df new.v ≈ df base.v test df new.c ≈ df base.c test df new.d ≈ df base.d test df new.s ≈ df base.s test df new.m ≈ df base.m test df new.sd ≈ df base.sd test df new.sc ≈ df base.sc ss b, a, z for b ∈ m.b, a ∈ m.a, z ∈ m.z out3, agrid3 let bgrid m.b agrid m.a zgrid m.z statespace b, a, z for b ∈ m.b, a ∈ m.a, z ∈ m.z INITIAL GUESS v initial guess. statespace, Ref m stategrid OrderedDict b bgrid, a agrid solend OrderedDict Symbol v, i v , ,i for i ∈ 1 length zgrid info solend out pdesolve a, b f econ pdes a, b, m , stategrid, solend maxdist √eps out, a, b grid end let y reshape df.v, size ss ,20,1 bc zeros size y inds 10, grids m.b info length grids length size y length inds differentiate y, grids, inds, bc end let y reshape df.v, size ss , ,1 bc zeros size y differentiate y, m.b, m.a , 10,20 , bc end let y reshape df.v, size ss grids m.b, m.a, m.z inds 10,20,1 bc zeros size y out differentiate y, grids , inds, bc check differentiate 2 naive y, grids, inds, bc out, check end construct A new out c, out d, m begin time A construct A moll out c, out d, m time A new construct A new out c, out d, m .A test A ≈ A new end function construct A new simple s, m , b, a, z, db, da, Λ with exo false statespace b, a, z for b ∈ b, a ∈ a, z ∈ z N length statespace state inds i b, i a, i z for i b ∈ eachindex b , i a ∈ eachindex a , i z ∈ eachindex z linind LinearIndices size statespace T typeof from 1, to 1, λ 0.1 entries B T entries A T entries switch T entries T for from, i a, i b, i z ∈ enumerate state inds if i b 1 to linind i b 1, i a, i z λ min s from , 0.0 db entry from, to, λ push entries B, entry push entries, entry end if i b length b to linind i b 1, i a, i z λ max s from , 0.0 db entry from, to, λ push entries B, entry push entries, entry end if i a 1 to linind i b, i a 1, i z λ min m from , 0.0 da entry from, to, λ push entries A, entry push entries, entry end if i a length a to linind i b, i a 1, i z λ max m from , 0.0 da entry from, to, λ push entries A, entry push entries, entry end for i z next ∈ eachindex z if i z next i z to linind i b, i a, i z next λ Λ i z, i z next entry from, to, λ push entries switch, entry with exo && push entries, entry end end end from, to, λ StructArray entries B B sparse from, to, λ, N, N BB B spdiagm dropdims sum B, dims 2 , dims 2 from, to, λ StructArray entries A A sparse from, to, λ, N, N AA A spdiagm dropdims sum A, dims 2 , dims 2 from, to, λ StructArray entries A sparse from, to, λ, N, N A A spdiagm dropdims sum A, dims 2 , dims 2 from, to, λ StructArray entries switch switch sparse from, to, λ, N, N switch switch spdiagm dropdims sum switch, dims 2 , dims 2 A, AA, BB , A alt AA BB end md\"\"\" Solving for the stationary distribution \"\"\" function solve KF iterate A, Δ, g₀ fill 1 size A,1 , size A,1 g copy g₀ B I Δ A' for i ∈ 1 50000 g new B g crit maximum abs, g new g i % 1000 0 && info crit if isfinite crit throw ArgumentError \"Got non finite results. Try different Δ.\" end if crit 1e 12 info \"converged after i iterations\" return g end g . g new end g end function solve KF moll A N size A, 1 AT copy transpose A b zeros N i fix 1 b i fix .1 AT i fix, . 0.0 AT i fix,i fix 1.0 g AT\\b g . sum g end function stationary distribution A δ 0.0, ψ InfinitesimalGenerators.Zeros size A, 1 δ 0 || throw ArgumentError \"δ needs to be positive\" if δ 0 g abs. δ I A' \\ δ ψ else η, g InfinitesimalGenerators.principal eigenvalue A' abs η 1e 5 || warn \"Principal Eigenvalue does not seem to be zero\" end g . sum g end function solve KF death A N size A, 1 g₀ fill 1 N, N stationary distribution A, δ 1e 14, ψ g₀ end function solve KF eigs A stationary distribution A end df π let model m da, db model m, s df m reshape m, size ss s reshape s, size ss A construct A new simple m, s , model with exo true df new copy df df new.π1 solve KF death A df new.π2 solve KF eigs A df new.π3 solve KF moll A df new end chain df π begin data mapping b, a, π1, layout z nonnumeric visual Surface draw axis type Axis3, end df base let model m db, da, Nz, I, J, Λ model la mat Λ s, m df base Bswitch LinearAlgebra.I I J la mat 1,1 LinearAlgebra.I I J la mat 1,2 LinearAlgebra.I I J la mat 2,1 LinearAlgebra.I I J la mat 2,2 s reshape s, size ss m reshape m, size ss updiag zeros I J,Nz lowdiag zeros I J,Nz centdiag zeros I J,Nz AAi Array AbstractArray undef, Nz BBi Array AbstractArray undef, Nz X min. s,0 . db Y min. s,0 . db . max. s,0 . db Z max. s,0 . db sum Y . 0 centdiag reshape Y , ,1 , I J, 1 for i 1 Nz centdiag ,i . reshape Y , ,i ,I J end centdiag lowdiag 1 I 1, X 2 I,1, updiag 2 I, Z 1 I 1,1, for j 2 J lowdiag 1 j I, lowdiag 1 j 1 I, X 2 I,j, zeros 1,Nz updiag 1 j I, updiag 1 j 1 I, zeros 1,Nz Z 1 I 1,j, end for nz 1 Nz BBi nz spdiagm I J, I J, 0 centdiag ,nz , 1 updiag 2 end,nz , 1 lowdiag 1 end 1,nz end BB cat BBi..., dims 1,2 CONSTRUCT MATRIX AA SUMMARIZING EVOLUTION OF a chi min. m,0 . da yy min. m,0 . da . max. m,0 . da zeta max. m,0 . da MATRIX AAi for nz 1 Nz This will be the upperdiagonal of the matrix AAi AAupdiag zeros 0 This is necessary because of the peculiar way spdiags is defined. for j 1 J AAupdiag AAupdiag zeta ,j,nz end This will be the center diagonal of the matrix AAi AAcentdiag yy ,1,nz for j 2 J 1 AAcentdiag AAcentdiag yy ,j,nz end AAcentdiag AAcentdiag yy ,J,nz This will be the lower diagonal of the matrix AAi AAlowdiag chi ,2,nz for j 3 J AAlowdiag AAlowdiag chi ,j,nz end Add up the upper, center, and lower diagonal into a sparse matrix AAi nz spdiagm I J,I J, 0 AAcentdiag, I AAlowdiag, 1 end I , I AAupdiag I 1 end end AA cat AAi..., dims 1,2 A AA BB Bswitch M I J Nz AT A' Fix one value so matrix isn't singular vec zeros M,1 iFix 1657 vec iFix .01 AT iFix, . 0.0 AT iFix, . zeros iFix 1 1 zeros M iFix Solve system g stacked AT\\vec g sum g stacked' ones M,1 da db g stacked g stacked . g sum fig Figure ax Axis3 fig 1,1 surface ax, reshape g stacked, size ss , ,1 ax Axis3 fig 1,2 surface ax, reshape g stacked, size ss , ,2 fig g , ,1 reshape g stacked 1 I J ,I,J g , ,2 reshape g stacked I J 1 I J 2 ,I,J end md\"\"\" Appendix \"\"\" TableOfContents "}]